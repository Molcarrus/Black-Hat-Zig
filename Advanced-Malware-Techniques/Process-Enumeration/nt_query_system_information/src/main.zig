const std = @import("std");
const windows = std.os.windows;
const print = std.debug.print;
const windows_structs = @import("./windows_structs.zig");

// Windows API types
const DWORD = windows.DWORD;
const HANDLE = windows.HANDLE;
const BOOL = windows.BOOL;
const ULONG = windows.ULONG;
const NTSTATUS = windows.NTSTATUS;
const PVOID = ?*anyopaque;
const USHORT = windows.USHORT;
const PWSTR = windows.PWSTR;
const SIZE_T = windows.SIZE_T;
const LPCWSTR = windows.LPCWSTR;
const HMODULE = windows.HMODULE;
const WINAPI = windows.WINAPI;

// Configuration
const TARGET_PROCESS = "notepad.exe";

// Convert UTF-8 to UTF-16 at compile time
const W = std.unicode.utf8ToUtf16LeStringLiteral;

const UNICODE_STRING = windows_structs.UNICODE_STRING;

const SYSTEM_INFORMATION_CLASS = windows_structs.SYSTEM_INFORMATION_CLASS;

const SYSTEM_PROCESS_INFORMATION = windows_structs.SYSTEM_PROCESS_INFORMATION;

// Function pointer type for NtQuerySystemInformation
const NtQuerySystemInformationFn = *const fn (
    SystemInformationClass: SYSTEM_INFORMATION_CLASS,
    SystemInformation: PVOID,
    SystemInformationLength: ULONG,
    ReturnLength: ?*ULONG,
) callconv(WINAPI) NTSTATUS;

// ProcessResult structure (equivalent to Rust's Option<(u32, HANDLE)>)
const ProcessResult = struct {
    pid: DWORD,
    handle: HANDLE,

    pub fn deinit(self: ProcessResult) void {
        _ = CloseHandle(self.handle);
    }
};

// External function declarations
extern "kernel32" fn GetProcAddress(hModule: HMODULE, lpProcName: [*:0]const u8) callconv(WINAPI) PVOID;
extern "kernel32" fn GetModuleHandleW(lpModuleName: LPCWSTR) callconv(WINAPI) ?HMODULE;
extern "kernel32" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(WINAPI) ?HANDLE;
extern "kernel32" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;
extern "kernel32" fn GetLastError() callconv(WINAPI) DWORD;
extern "kernel32" fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) callconv(WINAPI) PVOID;
extern "kernel32" fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: PVOID) callconv(WINAPI) BOOL;
extern "kernel32" fn GetProcessHeap() callconv(WINAPI) HANDLE;

// Constants
const PROCESS_ALL_ACCESS = 0x001F0FFF;
const HEAP_ZERO_MEMORY = 0x00000008;
const STATUS_SUCCESS: NTSTATUS = windows.NTSTATUS.SUCCESS;

// Helper function to convert UNICODE_STRING to Zig slice
fn unicodeStringToSlice(unicode_str: UNICODE_STRING) []u16 {
    if (unicode_str.Buffer == null or unicode_str.Length == 0) {
        return &[_]u16{};
    }
    return @as([*]u16, @ptrCast(unicode_str.Buffer))[0 .. unicode_str.Length / 2];
}

// Helper function to convert string to lowercase
fn toLowercase(allocator: std.mem.Allocator, input: []const u8) ![]u8 {
    var result = try allocator.alloc(u8, input.len);
    for (input, 0..) |char, i| {
        result[i] = std.ascii.toLower(char);
    }
    return result;
}

// Function to get remote process handle using dynamic loading (equivalent to Rust function)
fn getRemoteProcessHandle(allocator: std.mem.Allocator, process_name: []const u8) ?ProcessResult {
    // Load NtQuerySystemInformation dynamically
    const ntdll = GetModuleHandleW(W("ntdll.dll")) orelse {
        print("[!] GetModuleHandleW failed!\n", .{});
        return null;
    };

    const nt_query_proc = GetProcAddress(ntdll, "NtQuerySystemInformation") orelse {
        print("[!] GetProcAddress failed!\n", .{});
        return null;
    };

    // Cast to function pointer (equivalent to Rust's transmute)
    const nt_query_sys_info = @as(NtQuerySystemInformationFn, @ptrCast(nt_query_proc));

    var return_length: ULONG = 0;

    // First call to get buffer size
    _ = nt_query_sys_info(.SystemProcessInformation, null, 0, &return_length);

    if (return_length == 0) {
        print("[!] Failed to get buffer size.\n", .{});
        return null;
    }

    // Allocate buffer (equivalent to Rust's HeapAlloc)
    const heap = GetProcessHeap();
    const proc_info_ptr = HeapAlloc(heap, HEAP_ZERO_MEMORY, return_length) orelse {
        print("[!] HeapAlloc failed!\n", .{});
        return null;
    };
    defer _ = HeapFree(heap, 0, proc_info_ptr);

    // Second call to get actual data
    const status = nt_query_sys_info(
        .SystemProcessInformation,
        proc_info_ptr,
        return_length,
        &return_length,
    );

    if (status != STATUS_SUCCESS) {
        print("[!] NtQuerySystemInformation failed!\n", .{});
        return null;
    }

    // Convert target process name to lowercase for comparison
    const target_lower = toLowercase(allocator, process_name) catch {
        print("[!] Memory allocation failed for target name.\n", .{});
        return null;
    };
    defer allocator.free(target_lower);

    // Iterate through processes (equivalent to Rust's loop)
    var proc_info = @as(*SYSTEM_PROCESS_INFORMATION, @ptrCast(@alignCast(proc_info_ptr)));

    while (true) {
        // Get process name from UNICODE_STRING
        const image_name_ptr = proc_info.ImageName.Buffer;
        const process_id = @as(DWORD, @intCast(@intFromPtr(proc_info.UniqueProcessId)));

        if (image_name_ptr != null and proc_info.ImageName.Length > 0) {
            // Convert Unicode string to UTF-8 (equivalent to Rust's OsString::from_wide)
            const wide_chars = unicodeStringToSlice(proc_info.ImageName);

            // Convert UTF-16 to UTF-8
            var utf8_buffer: [260]u8 = undefined;
            if (std.unicode.utf16LeToUtf8(&utf8_buffer, wide_chars)) |utf8_len| {
                const process_name_str = utf8_buffer[0..utf8_len];

                // Convert to lowercase for comparison (equivalent to Rust's to_lowercase())
                const process_lower = toLowercase(allocator, process_name_str) catch continue;
                defer allocator.free(process_lower);

                // Compare process names (case-insensitive, equivalent to Rust comparison)
                if (std.mem.eql(u8, process_lower, target_lower)) {
                    const handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id) orelse {
                        print("[!] OpenProcess failed for PID: {}\n", .{process_id});
                        continue;
                    };

                    return ProcessResult{
                        .pid = process_id,
                        .handle = handle,
                    };
                }
            } else |_| {
                // Skip processes with encoding errors
                continue;
            }
        }

        // Move to next process (equivalent to Rust's pointer arithmetic)
        if (proc_info.NextEntryOffset == 0) {
            break;
        }

        proc_info = @as(*SYSTEM_PROCESS_INFORMATION, @ptrCast(@alignCast(@as([*]u8, @ptrCast(proc_info)) + proc_info.NextEntryOffset)));
    }

    return null;
}

// Wait for user input (equivalent to Rust's stdin().read_line())
fn waitForInput() !void {
    print("[#] Press Enter to exit...\n", .{});
    const stdin = std.io.getStdIn().reader();
    _ = try stdin.readByte();
}

// Main function (equivalent to Rust's main)
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Get remote process handle (equivalent to Rust's match statement)
    if (getRemoteProcessHandle(allocator, TARGET_PROCESS)) |result| {
        defer result.deinit();

        print("[+] Found process {s} with PID: {}\n", .{ TARGET_PROCESS, result.pid });
    } else {
        print("[!] Could not find process {s}\n", .{TARGET_PROCESS});
    }

    try waitForInput();
}
